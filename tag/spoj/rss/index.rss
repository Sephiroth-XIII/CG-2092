<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[SPOJ - Code Jedi]]></title><description><![CDATA[Code, algorithms and design.]]></description><link>http://code-jedi.chintanghate.me/</link><generator>Ghost 0.5</generator><lastBuildDate>Fri, 28 Nov 2014 17:58:27 GMT</lastBuildDate><atom:link href="http://code-jedi.chintanghate.me/tag/spoj/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[CRDS]]></title><description><![CDATA[<p>Maricruz have a lot of cards, she always uses her cards to build pyramids as shown in the following image:</p>

<p><img src="http://code-jedi.chintanghate.me/content/images/2014/11/francky-cards.png" alt="Cards"></p>

<p>A pyramid card of 3 levels. <br>
She always wonder how many cards does she need to make a pyramid card of N levels. Your task is to answer that question.</p>

<h6 id="input">Input</h6>

<p>The first line of the input contains an integer 1&lt;= T &lt;= 1,000. Each of the following T lines will have an integer 1&lt;= N &lt;= 1,000,000.</p>

<h6 id="output">Output</h6>

<p>For each case, output a single line consisting of the number of cards needed to build a pyramid card of level N modulo 1,000,007.</p>

<p>Example</p>

<p>Input: <br>
2 <br>
3 <br>
7</p>

<p>Output: <br>
15 <br>
77</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        unsigned long long levels;
        cin &gt;&gt; levels;
        unsigned long long cards = 
        (((levels * (levels + 1) / 2) * 3) - levels);
        cout &lt;&lt; cards % 1000007 &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/crds/</link><guid isPermaLink="false">80d9e6f9-0109-4490-a9b5-32d931259a55</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 17:25:46 GMT</pubDate></item><item><title><![CDATA[EGYPIZZA]]></title><description><![CDATA[<p>Abotrika is having a party because his team won the african cup so he is inviting his friends to eat some pizza. Unfortunately, Abotrika's friends can't eat an entire pizza but all of them know exactly how much pizza they can eat and insist on getting the exact amount of pizza but Abotrika eats one complete pizza and all of them wants his amount of pizza in one slice.</p>

<p>Their requests break down to three different pizza slices-either one quarter or a half or three quarters of pizza. write a program that will help Abotrika to find out what is the minimal number of pizzas he has to order so that everyone gets exact amount of pizza they want.</p>

<h6 id="input">Input</h6>

<p>First line contains an integer N, 0&lt;=N&lt;=10000, number of friends. In each of next N lines there is amount of pizza that each of Abotrika's friends wants to eat,that is the fraction 1/4, 1/2 or 3/4.</p>

<h6 id="output">Output</h6>

<p>In the first and only line you should write the minimal number of pizzas Abotrika has order don't forget to order one complete pizza for Abotrika</p>

<p>Example</p>

<p>Input: <br>
3 <br>
1/2 <br>
3/4 <br>
3/4</p>

<p>Output: <br>
4</p>

<p>Input: <br>
5 <br>
1/2 <br>
3/4 <br>
1/2 <br>
1/4 <br>
1/4</p>

<p>Output: <br>
4</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {  
    int N;
    cin &gt;&gt; N;
    long long a = 1,
              q = 0,
              h = 0,
              t = 0;
    for (;N--;) {
        string s;
        cin &gt;&gt; s;
        if (s == "1/2") {
            ++h;
        } else if (s == "3/4") {
            ++t;
        } else {
            ++q;
        }
    }
    a += h / 2;
    a += (h % 2);
    if (h % 2 == 1) {
        q -= 2;
    }
    if (t &gt;= q) {
        a += t;
    } else {
        a += t;
        q -= t;
        a += q/4;
        a += (q % 4 &gt; 0 ? 1 : 0);
    }
    cout &lt;&lt; a &lt;&lt; "\n";
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/egypizza/</link><guid isPermaLink="false">848e8203-7cb7-4208-8e48-e6956466548d</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 15:38:00 GMT</pubDate></item><item><title><![CDATA[OLOLOL]]></title><description><![CDATA[<p>Onotole has a lot of pyani. Each pyani has a number, writing on it. Pyanis with equal numbers are indistinguishable. Onotole knows everything, so, he knows that each pyani appeared twice, and only one pyani is unique. He wants to get вздръжни эффект, and he needs the unique pyani. Given the list of pyanis denote which one of them appeared once (it is guaranteed that other pyanis appeared twice).</p>

<h6 id="input">Input</h6>

<p>First line of input contains number of pyanis N&lt;=500 000. Next N lines contain a single positive integer 1 &lt;= Pi &lt;= 10^9.</p>

<h6 id="output">Output</h6>

<p>Output one positive integer on pyani, which appeared once.</p>

<p>Example</p>

<p>Input: <br>
3 <br>
1 <br>
8 <br>
1</p>

<p>Output: <br>
8</p>

<p>Onotole has found not optimal AC algorithms, so all solutions will be rejudged. He is watching you.</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;

using namespace std;

int main() {  
    int n;
    scanf("%d",&amp;n);
    long long x, res = 0;
    for (;n--;) {
        scanf("%lld",&amp;x);
        res ^= x;
    }
    cout &lt;&lt; res &lt;&lt; "\n";
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/ololol/</link><guid isPermaLink="false">d8be6bbf-e8dd-4d91-b1b3-1098c55c5425</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 13:18:27 GMT</pubDate></item><item><title><![CDATA[HYPNOS]]></title><description><![CDATA[<p>The process of “breaking” an integer is defined as summing the squares of its digits. For example, the result of breaking the integer 125 is (12 + 22 + 52) = 30. An integer N is happy if after “breaking” it repeatedly the result reaches 1. If the result never reaches 1 no matter how many times the “breaking” is repeated, then N is not a happy number.</p>

<h6 id="task">Task</h6>

<p>Write a program that given an integer N, determines whether it is a happy number or not.</p>

<h6 id="constraints">Constraints</h6>

<p>2 ≤ N ≤ 2,147,483,647</p>

<h6 id="input">Input</h6>

<p>A single line containing a single integer N.</p>

<h6 id="output">Output</h6>

<p>A single line containing a single integer T which is the number of times the process had to be done to determine that N is happy, or -1 if N is not happy.</p>

<p>Example</p>

<p>Input: <br>
19</p>

<p>Output: <br>
4</p>

<p>1) 19   : 12 + 92 = 82 <br>
2) 82   : 82 + 22 = 68 <br>
3) 68   : 62 + 82 = 100 <br>
4) 100 : 12 + 02 + 02 = 1</p>

<p>The solution is 4 because we discovered that the integer 19 is happy after we repeated the process 4 <br>
times.</p>

<p>Example</p>

<p>Input: <br>
204</p>

<p>Output: <br>
-1</p>

<p>204 –> 20 –> 4 –> 16 –> 37 –> 58 –> 89 –> 145 –> 42 –> 20 –> 4 –> 16 –> 37 –> 58 –> 89 –> 145 ……..</p>

<p>204 is not a happy number because after breaking it several times the results start repeating so we can deduce that if we continue breaking it, the result will never reach 1.</p>

<p>Number of test cases is 32.</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

typedef long long ll;

ll breakNumber(ll N) {  
    ll res = 0;
    while (N != 0) {
        int n = N % 10;
        res += (n * n);
        N /= 10;
    }
    return res;
}

int main() {  
    int N;
    cin &gt;&gt; N;
    set&lt;ll&gt; pows;
    pows.insert(N);
    ll count = 0;
    while (N != 1) {
        N = breakNumber(N);
        if (pows.find(N) != pows.end()) {
            count = -1;
            break;
        } else {
            pows.insert(N);
            ++count;
        }
    }
    cout &lt;&lt; count &lt;&lt; "\n";
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/hypnos/</link><guid isPermaLink="false">cb4b527e-e33c-4e14-b403-967f3a1b9757</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 13:09:53 GMT</pubDate></item><item><title><![CDATA[BITMAP]]></title><description><![CDATA[<p>There is given a rectangular bitmap of size n*m. Each pixel of the bitmap is either white or black, but at least one is white. The pixel in i-th line and j-th column is called the pixel (i,j). The distance between two pixels p1=(i1,j1) and p2=(i2,j2) is defined as:</p>

<p>d(p1,p2)=|i1-i2|+|j1-j2|.</p>

<h6 id="task">Task</h6>

<p>Write a program which:</p>

<ul>
<li>reads the description of the bitmap from the standard input,</li>
<li>for each pixel, computes the distance to the nearest white pixel,</li>
<li>writes the results to the standard output.</li>
</ul>

<h6 id="input">Input</h6>

<p>The number of test cases t is in the first line of input, then t test cases follow separated by an empty line. In the first line of each test case there is a pair of integer numbers n, m separated by a single space, 1&lt;=n &lt;=182, 1&lt;=m&lt;=182. In each of the following n lines of the test case exactly one zero-one word of length m, the description of one line of the bitmap, is written. On the j-th position in the line (i+1), 1 &lt;= i &lt;= n, 1 &lt;= j &lt;= m, is '1' if, and only if the pixel (i,j) is white.</p>

<h6 id="output">Output</h6>

<p>In the i-th line for each test case, 1&lt;=i&lt;=n, there should be written m integers f(i,1),...,f(i,m) separated by single spaces, where f(i,j) is the distance from the pixel (i,j) to the nearest white pixel.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
3 4 <br>
0001 <br>
0011 <br>
0110</p>

<p>Output: <br>
3 2 1 0 <br>
2 1 0 0 <br>
1 0 0 1</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

void bfs(vector&lt;vector&lt;int&gt; &gt; &amp;dist, int x, int y, int d) {  
    int n = dist.size(),
        m = dist[0].size();
    if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; dist[x][y] &gt; d) {
        dist[x][y] = d;
        bfs(dist, x + 1, y, d + 1);
        bfs(dist, x - 1, y, d + 1);
        bfs(dist, x, y + 1, d + 1);
        bfs(dist, x, y - 1, d + 1);
    }
    return;
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int n, m;
        cin &gt;&gt; n &gt;&gt; m;
        vector&lt;string&gt; grid(n);
        vector&lt;vector&lt;int&gt; &gt; dist(n, vector&lt;int&gt; (m, 400));
        for (int i = 0; i &lt; n; ++i) {
            cin &gt;&gt; grid[i];
        }
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; m; ++j) {
                if (grid[i][j] == '1') {
                    bfs(dist, i, j, 0);
                }
            }
        }
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; m; ++j) {
                cout &lt;&lt; dist[i][j] &lt;&lt; " ";
            }
            cout &lt;&lt; "\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/bitmap/</link><guid isPermaLink="false">09df0738-8c1b-4b87-8029-6ae6968f1869</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 04:07:25 GMT</pubDate></item><item><title><![CDATA[ACODE]]></title><description><![CDATA[<p>Alice and Bob need to send secret messages to each other and are discussing ways to encode their messages:  </p>

<pre><code>Alice: “Let’s just use a very simple code: We’ll assign ‘A’ the code word 1, ‘B’ will be 2, and so on down to ‘Z’ being assigned 26.”

Bob: “That’s a stupid code, Alice. Suppose I send you the word ‘BEAN’ encoded as 25114. You could decode that in many different ways!”

Alice: “Sure you could, but what words would you get? Other than ‘BEAN’, you’d get ‘BEAAD’, ‘YAAD’, ‘YAN’, ‘YKD’ and ‘BEKD’. I think you would be able to figure out the correct decoding. And why would you send me the word ‘BEAN’ anyway?”

Bob: “OK, maybe that’s a bad example, but I bet you that if you got a string of length 5000 there would be tons of different decodings and with that many you would find at least two different ones that would make sense.”

Alice: “How many different decodings?”

Bob: “Jillions!”  
</code></pre>

<p>For some reason, Alice is still unconvinced by Bob’s argument, so she requires a program that will determine how many decodings there can be for a given string using her code.</p>

<h6 id="input">Input</h6>

<p>Input will consist of multiple input sets. Each set will consist of a single line of at most 5000 digits representing a valid encryption (for example, no line will begin with a 0). There will be no spaces between the digits. An input line of ‘0’ will terminate the input and should not be processed.</p>

<h6 id="output">Output</h6>

<p>For each input set, output the number of possible decodings for the input string. All answers will be within the range of a 64 bit signed integer.</p>

<p>Example</p>

<p>Input: <br>
25114 <br>
1111111111 <br>
3333333333 <br>
0</p>

<p>Output: <br>
6 <br>
89 <br>
1</p>

<hr>

<h6 id="usingdynamicprogramming">Using Dynamic Programming:</h6>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int main() {  
    string s;
    while ((cin &gt;&gt; s) &amp;&amp; s != "0") {
        vector&lt;int&gt; ones(s.size(), 0),
                    tens(s.size(), 0),
                    ways(s.size(), 0);
        for (int i = 0; i &lt; s.size(); ++i) {
            ones[i] = s[i] - '0';
        }
        for (int i = 1; i &lt; s.size(); ++i) {
            tens[i] = 10 * ones[i - 1] + ones[i];
        }
        ways[0] = 1;
        if (s.size() &gt; 1) {
            ways[1] = (ones[1] != 0 ? 1 : 0);
            if (tens[1] &gt; 9 &amp;&amp; tens[1] &lt; 27) {
                ++ways[1];
            }
            for (int i = 2; i &lt; s.size(); ++i) {
                ways[i] = (ones[i] != 0 ? ways[i - 1] : 0);
                if (tens[i] &gt; 9 &amp;&amp; tens[i] &lt; 27) {
                    ways[i] += ways[i - 2];
                }
            }
        }
        cout &lt;&lt; ways.back() &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>

<hr>

<h6 id="using2variables">Using 2 variables:</h6>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {  
    string s;
    while ((cin &gt;&gt; s) &amp;&amp; s != "0") {
        int good = 1,
            bad = 0;
        for (int i = 1; i &lt; s.size(); ++i) {
            int n = (10 * (s[i - 1] - '0') + (s[i] - '0'));
            if (s[i] == '0') {
                if (n &gt;= 27) {
                    good = 0;
                    bad = 0;
                    break;
                }
                bad = good;
                good = 0; 
            } else if (n &lt; 27 &amp;&amp; n &gt; 9) {
                good += bad;
                bad = good - bad;
            } else {
                good += bad;
                bad = 0;
            }
        }
        cout &lt;&lt; good + bad &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/acode/</link><guid isPermaLink="false">66e0fc84-f274-4962-8e98-51a5c0ee2e29</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Thu, 27 Nov 2014 07:31:59 GMT</pubDate></item><item><title><![CDATA[MARBLES]]></title><description><![CDATA[<p>Hänschen dreams he is in a shop with an infinite amount of marbles. He is allowed to select n marbles. There are marbles of k different colors. From each color there are also infinitely many marbles. Hänschen wants to have at least one marble of each color, but still there are a lot of possibilities for his selection. In his effort to make a decision he wakes up. Now he asks you how many possibilites for his selection he would have had. Assume that marbles of equal color can't be distinguished, and the order of the marbles is irrelevant.</p>

<h6 id="input">Input</h6>

<p>The first line of input contains a number T &lt;= 100 that indicates the number of test cases to follow. Each test case consists of one line containing n and k, where n is the number of marbles Hänschen selects and k is the number of different colors of the marbles. You can assume that 1&lt;=k&lt;=n&lt;=1000000.</p>

<h6 id="output">Output</h6>

<p>For each test case print the number of possibilities that Hänschen would have had. You can assume that this number fits into a signed 64 bit integer.</p>

<p>Example</p>

<p>Input: <br>
2 <br>
10 10 <br>
30 7</p>

<p>Output: <br>
1 <br>
475020</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

unsigned long long gcd(unsigned long long a, unsigned long long b) {  
    return (b == 0 ? a : gcd(b, a % b));
}

unsigned long long NCR(unsigned long long N, unsigned long long K) {  
    if(K &gt; N) {
        return 0;
    }
    K = min(N - K, K);
    unsigned long long p = 1;
    for (unsigned long long i = 1; i &lt;= K ; ++i) {
        unsigned long long g = gcd(p, i);
        p /= g;
        p *= (N - i + 1) / (i / g);
    }
    return p;
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        unsigned long long N, K;
        cin &gt;&gt; N &gt;&gt; K;
        --N, --K;
        cout &lt;&lt; NCR(N, K) &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/marbles/</link><guid isPermaLink="false">bea21dd8-92e3-4b40-a042-f2f4e9f409fd</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Thu, 27 Nov 2014 04:19:00 GMT</pubDate></item><item><title><![CDATA[BYTESM2]]></title><description><![CDATA[<p>One of the secret chambers in Hogwarts is full of philosopher’s stones. The floor of the chamber is covered by h × w square tiles, where there are h rows of tiles from front (first row) to back (last row) and w columns of tiles from left to right. Each tile has 1 to 100 stones on it. Harry has to grab as many philosopher’s stones as possible, subject to the following restrictions:</p>

<ul>
<li>He starts by choosing any tile in the first row, and collects the philosopher’s stones on that tile. Then, he moves to a tile in the next row, collects the philosopher’s stones on the tile, and so on until he reaches the last row.</li>
<li>When he moves from one tile to a tile in the next row, he can only move to the tile just below it or diagonally to the left or right.</li>
</ul>

<p>Given the values of h and w, and the number of philosopher’s stones on each tile, write a program to compute the maximum possible number of philosopher’s stones Harry can grab in one single trip from the first row to the last row.</p>

<h6 id="input">Input</h6>

<p>The first line consists of a single integer T, the number of test cases. In each of the test cases, the first line has two integers. The first integer h (1&lt;=h&lt;=100) is the number of rows of tiles on the floor. The second integer w (1&lt;=w&lt;=100) is the number of columns of tiles on the floor. Next, there are h lines of inputs. The ith line of these, specifies the number of philosopher’s stones in each tile of the ith row from the front. Each line has w integers, where each integer m (0&lt;=m&lt;=100) is the number of philosopher’s stones on that tile. The integers are separated by a space character.</p>

<h6 id="output">Output</h6>

<p>The output should consist of T lines, (1&lt;=T&lt;=100), one for each test case. Each line consists of a single integer, which is the maximum possible number of philosopher’s stones Harry can grab, in one single trip from the first row to the last row for the corresponding test case.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
6 5 <br>
3 1 7 4 2 <br>
2 1 3 1 1 <br>
1 2 2 1 8 <br>
2 2 1 5 3 <br>
2 1 4 4 4 <br>
5 2 7 5 1</p>

<p>Output: <br>
32     </p>

<p>//7+1+8+5+4+7=32</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int h, w;
        cin &gt;&gt; h &gt;&gt; w;
        vector&lt;vector&lt;int&gt; &gt; grid(h, vector&lt;int&gt;(w));
        for (int i = 0; i &lt; h; ++i) {
            for (int j = 0; j &lt; w; ++j) {
                cin &gt;&gt; grid[i][j];
            }
        }
        for (int i = h - 2; i &gt;= 0; --i) {
            for (int j = 0; j &lt; w; ++j) {
                int maximum = 0;
                if (j - 1 &gt;= 0 &amp;&amp; grid[i + 1][j - 1] &gt; maximum) {
                    maximum = grid[i + 1][j - 1];
                }
                if (grid[i + 1][j] &gt; maximum) {
                    maximum = grid[i + 1][j];
                }
                if (j + 1 &lt; w &amp;&amp; grid[i + 1][j + 1] &gt; maximum) {
                    maximum = grid[i + 1][j + 1];
                }
                grid[i][j] += maximum;
            }
        }
        cout &lt;&lt; *max_element(grid[0].begin(), grid[0].end()) 
             &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/bytesm2/</link><guid isPermaLink="false">4ee19633-c9f6-4361-996d-71226822d994</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 20:01:46 GMT</pubDate></item><item><title><![CDATA[JAVAC]]></title><description><![CDATA[<p>Apologists of Java and C++ can argue for hours proving each other that their programming language is the best one. Java people will tell that their programs are clearer and less prone to errors, while C++ people will laugh at their inability to instantiate an array of generics or tell them that their programs are slow and have long source code.</p>

<p>Another issue that Java and C++ people could never agree on is identifier naming. In Java a multiword identifier is constructed in the following manner: the first word is written starting from the small letter, and the following ones are written starting from the capital letter, no separators are used. All other letters are small. Examples of a Java identifier are javaIdentifier, longAndMnemonicIdentifier, name, nEERC.</p>

<p>Unlike them, C++ people use only small letters in their identifiers. To separate words they use underscore character ‘<em>’. Examples of C++ identifiers are c</em>identifier, long<em>and</em>mnemonic<em>identifier, name (you see that when there is just one word Java and C++ people agree), n</em>e<em>e</em>r_c.</p>

<p>You are writing a translator that is intended to translate C++ programs to Java and vice versa. Of course, identifiers in the translated program must be formatted due to its language rules — otherwise people will never like your translator.</p>

<p>The first thing you would like to write is an identifier translation routine. Given an identifier, it would detect whether it is Java identifier or C++ identifier and translate it to another dialect. If it is neither, then your routine should report an error. Translation must preserve the order of words and must only change the case of letters and/or add/remove underscores.</p>

<h6 id="input">Input</h6>

<p>The input file consists of several lines that contains an identifier. It consists of letters of the English alphabet and underscores. Its length does not exceed 100.</p>

<h6 id="output">Output</h6>

<p>If the input identifier is Java identifier, output its C++ version. If it is C++ identifier, output its Java version. If it is none, output 'Error!' instead.</p>

<p>Example</p>

<p>Input: <br>
long_and_mnemonic_identifier <br>
anotherExample <br>
i <br>
bad_Style</p>

<p>Output: <br>
longAndMnemonicIdentifier <br>
another_example <br>
i <br>
Error!</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cctype&gt;

using namespace std;

bool isJavaIdentifier(string s) {  
    if (!islower(s[0])) {
        return false;
    }
    for (int i = 0; i &lt; s.size(); ++i) {
        if (!isalpha(s[i])) {
            return false;
        }
    }
    return true;
}

bool isCIdentifier(string s) {  
    if (!islower(s[0])) {
        return false;
    }
    for (int i = 0; i &lt; s.size(); ++i) {
        if (!islower(s[i]) &amp;&amp; s[i] != '_') {
            return false;
        }
        if (s[i] == '_' &amp;&amp; !islower(s[i+1])) {
            return false;
        }
    }
    return true;
}

int main() {  
    string s;
    while (cin &gt;&gt; s) {
        bool java = isJavaIdentifier(s),
             c = isCIdentifier(s);
        if (!java &amp;&amp; !c) {
            cout &lt;&lt; "Error!\n";
        } else if (java) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if (isupper(s[i])) {
                    o += '_';
                }
                o += tolower(s[i]);
            }
            cout &lt;&lt; o &lt;&lt; "\n";
        } else if (c) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] == '_') {
                    ++i;
                    o += toupper(s[i]);
                } else {
                    o += s[i];
                }
            }
            cout &lt;&lt; o &lt;&lt; "\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/javac/</link><guid isPermaLink="false">4077835d-1bca-4079-96f6-0e3e12e31991</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 18:49:32 GMT</pubDate></item><item><title><![CDATA[NY10A]]></title><description><![CDATA[<p>Penney’s game is a simple game typically played by two players.  One version of the game calls for each player to choose a unique three-coin sequence such as HEADS TAILS HEADS (HTH).  A fair coin is tossed sequentially some number of times until one of the two sequences appears.  The player who chose the first sequence to appear wins the game.</p>

<p>For this problem, you will write a program that implements a variation on the Penney Game.  You willread a sequence of 40 coin tosses and determine how many times each three-coin sequence appears.  Obviously there are eight such three-coin sequences: TTT, TTH, THT, THH, HTT, HTH, HHT and HHH. Sequences may overlap.  For example, if all 40 coin tosses are heads, then the sequence HHH appears 38 times.</p>

<h6 id="input">Input</h6>

<p>The first line of input contains a single integer P, (1 ≤ P ≤ 1000), which is the number of data sets that follow.  Each data set consists of 2 lines.  The first line contains the data set number N.  The second line contains the sequence of 40 coin tosses.  Each toss is represented as an upper case H or an upper case T, for heads or tails, respectively.  There will be no spaces on any input line.</p>

<h6 id="output">Output</h6>

<p>For each data set there is one line of output.  It contains the data set number followed by a single space, followed by the number of occurrences of each three-coin sequence, in the order shown above, with a space between each one.  There should be a total of 9 space separated decimal integers on each output line.</p>

<p>Example</p>

<p>Input: <br>
4 <br>
1 <br>
HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH <br>
2 <br>
TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT <br>
3 <br>
HHTTTHHTTTHTHHTHHTTHTTTHHHTHTTHTTHTTTHTH <br>
4 <br>
HTHTHHHTHHHTHTHHHHTTTHTTTTTHHTTTTHTHHHHT</p>

<p>Output: <br>
1 0 0 0 0 0 0 0 38 <br>
2 38 0 0 0 0 0 0 0 <br>
3 4 7 6 4 7 4 5 1 <br>
4 6 3 4 5 3 6 5 6</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int n;
        cin &gt;&gt; n;
        string s;
        cin &gt;&gt; s;
        vector&lt;int&gt; counter(8, 0);
        for (int i = 0; i &lt; s.size() - 2; ++i) {
            int index = 0;
            index += (s[i] == 'H' ? 4 : 0);
            index += (s[i + 1] == 'H' ? 2 : 0);
            index += (s[i + 2] == 'H' ? 1 : 0);
            ++counter[index];
        }
        cout &lt;&lt; n;
        for (int i = 0; i &lt; 8; ++i) {
            cout &lt;&lt; " " &lt;&lt; counter[i];
        }
        cout &lt;&lt; "\n";
    }   
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/26/ny10a/</link><guid isPermaLink="false">8ef0f847-ce46-4d07-8f04-a07ed3defad8</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 15:24:13 GMT</pubDate></item><item><title><![CDATA[PT07Z]]></title><description><![CDATA[<p>You are given an unweighted, undirected tree. Write a program to output the length of the longest path (from one node to another) in that tree. The length of a path in this case is number of edges we traverse from source to destination.</p>

<h6 id="input">Input</h6>

<p>The first line of the input file contains one integer N --- number of nodes in the tree (0 &lt; N &lt;= 10000). Next N-1 lines contain N-1 edges of that tree --- Each line contains a pair (u, v) means there is an edge between node u and node v (1 &lt;= u,v &lt;= N).</p>

<h6 id="output">Output</h6>

<p>Print the length of the longest path on one line.</p>

<p>Example</p>

<p>Input: <br>
3 <br>
1 2 <br>
2 3</p>

<p>Output: <br>
2</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

using namespace std;

pair&lt;int, int&gt; longestPath(vector&lt;vector&lt;int&gt; &gt; adj, int source) {  
    int nodes = adj.size();
    deque&lt;int&gt; q;
    vector&lt;bool&gt; visited(nodes, false);
    vector&lt;int&gt; sourceDist(nodes, 0);
    q.push_back(source);
    visited[source] = true;
    while (!q.empty()) {
        int current = q.front();
        q.pop_front();
        for (int i = 0; i &lt; adj[current].size(); ++i) {
            if (!visited[adj[current][i]]) {
                sourceDist[adj[current][i]] = 
                    sourceDist[current] + 1;
                q.push_back(adj[current][i]);
                visited[adj[current][i]] = true;
            }
        }
    }
    int maxIndex = max_element(sourceDist.begin(), 
                   sourceDist.end()) - sourceDist.begin();
    return make_pair(sourceDist[maxIndex], maxIndex);
}

int main() {  
    int nodes;
    cin &gt;&gt; nodes;
    vector&lt;vector&lt;int&gt; &gt; adj(nodes);
    for (int i = 0; i &lt; nodes - 1; ++i) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        --u, --v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    int farthestNode = longestPath(adj, 0).second;
    cout &lt;&lt; longestPath(adj, farthestNode).first &lt;&lt; "\n";
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/26/pt07z/</link><guid isPermaLink="false">c6880079-7f17-4a32-a815-26e12b3221bf</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 14:49:23 GMT</pubDate></item><item><title><![CDATA[LASTDIG2]]></title><description><![CDATA[<p>Pappu was doing the work of his math class about three days but he is tired of make operations a lot and he should deliver his task tomorrow. His math’s teacher gives two numbers a and b. The problem consist in find the last digit of the potency of base a and index b. Help Pappu with his problem. You are given two integer numbers: the base a (number of digits d, such that 1&lt;=d&lt;=1000) and the index b (0 &lt;= b &lt;= 922*10^15). You have to find the last digit of a^b.</p>

<h6 id="input">Input</h6>

<p>The first line of input contains an integer t, the number of test cases (t &lt;= 30). t test cases follow. For each test case will appear a and b separated by space.</p>

<h6 id="output">Output</h6>

<p>For each test case output an integer per line representing the result.</p>

<p>Example</p>

<p>Input: <br>
3 <br>
3 10 <br>
6 2 <br>
150 53</p>

<p>Output: <br>
9 <br>
6 <br>
0</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int lastDig(int n, unsigned long long b) {  
    if (b == 0) {
        return 1;
    } else if (n == 0 || n == 1 || n == 5 || n == 6) {
        return n;
    }
    vector&lt;int&gt; ld;
    ld.push_back(n);
    int count = 0;
    do {
        ++count;
        ld.push_back((n*ld.back()) % 10);
    } while (ld.back() != n);
    int c = b % count - 1;
    if (c &lt; 0) {
        c += count;
    }
    return ld[c];
}

int main() {  
    int t;
    cin &gt;&gt; t;
    for (;t--;) {
        string a;
        unsigned long long b;
        cin &gt;&gt; a &gt;&gt; b;
        int n = a[a.size() - 1] - '0';
        cout &lt;&lt; lastDig(n, b) &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/26/lastdig2/</link><guid isPermaLink="false">f1d858ed-de4c-40ce-92a8-89d52e328a35</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 05:30:49 GMT</pubDate></item><item><title><![CDATA[EDIST]]></title><description><![CDATA[<p>You are given two strings, A and B. Answer, what is the smallest number of operations you need to <br>
transform A to B?</p>

<p>Operations are:</p>

<ol>
<li>Delete one letter from one of strings</li>
<li>Insert one letter into one of strings</li>
<li>Replace one of letters from one of strings with another letter </li>
</ol>

<h6 id="input">Input</h6>

<p>T - number of test cases</p>

<p>For each test case:</p>

<p>String A</p>

<p>String B</p>

<p>Both strings will contain only uppercase characters and they won't <br>
be longer than 2000 characters. </p>

<p>There will be 10 test cases in data set.</p>

<h6 id="output">Output</h6>

<p>For each test case, one line, minimum number of operations.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
FOOD <br>
MONEY </p>

<p>Output: <br>
4</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int LevenshteinDistance(string s, string t) {  
    if (s == t) {
        return 0;
    } else if (s.size() == 0) {
        return t.size();
    } else if (t.size() == 0) {
        return s.size();
    }

    vector&lt;int&gt; v0 = vector&lt;int&gt; (t.size() + 1),
                v1 = vector&lt;int&gt; (t.size() + 1);

    for (int i = 0; i &lt; v0.size(); ++i) {
        v0[i] = i;
    }

    for (int i = 0; i &lt; s.size(); ++i) {
        v1[0] = i + 1;
        for (int j = 0; j &lt; t.size(); ++j) {
            int cost = (s[i] == t[j] ? 0 : 1);
            v1[j + 1] = min(min(v1[j] + 1, v0[j + 1] + 1), 
                        v0[j] + cost);
        }
        v0 = v1;
    }
    return v1[t.size()];
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        string a,b;
        cin &gt;&gt; a &gt;&gt; b;
        cout &lt;&lt; LevenshteinDistance(a, b) &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/26/edist/</link><guid isPermaLink="false">edcc9410-811a-4155-a85e-0b2331740f17</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 03:46:18 GMT</pubDate></item><item><title><![CDATA[MAXLN]]></title><description><![CDATA[<p>In this problem you will be given a half-circle. The half-circle’s radius is r. You can take any point A on the half-circle and draw 2 lines from the point to the two sides of the diameter(AB and AC). Let the sum of square of one line’s length and the other line’s length is s.</p>

<p><img src="http://code-jedi.chintanghate.me/content/images/2014/11/sE2qJlnf5DUTr7awOFtMOwA-1.png" alt="Illustration"></p>

<p>Like in the figure s=AB^2+AC. And BC=2r.</p>

<p>Now given r you have to find the maximum value of s. That is you have to find point A such that AB^2+AC is maximum.</p>

<h6 id="input">Input:</h6>

<p>First line of the test case will be the number of test case T(1&lt;=T&lt;=1000) . Then T lines follows. On each line you will find a integer number r(1&lt;=r&lt;=1000000); each representing the radius of the half-circle.</p>

<h6 id="output">Output:</h6>

<p>For each input line, print a line containing “Case I: ”, where I is the test case number and the maximum value of s. Print 2 digit after decimal(Errors should be less then .01).</p>

<p>Example</p>

<p>Input: <br>
1 <br>
1</p>

<p>Output: <br>
Case 1: 4.25</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (int t = 1; t &lt;= T; ++t) {
        double n;
        cin &gt;&gt; n;
        cout &lt;&lt; "Case " &lt;&lt; setprecision(2) &lt;&lt; fixed 
             &lt;&lt; t &lt;&lt; ": " &lt;&lt; 4*n*n+0.25 &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/25/maxln/</link><guid isPermaLink="false">888df35d-fbc6-429a-935b-81c2182ab01b</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Tue, 25 Nov 2014 18:10:20 GMT</pubDate></item><item><title><![CDATA[ARITH2]]></title><description><![CDATA[<p>While browsing aimlessly, Peter stumbled upon an old riddle he used to solve on his calculator when he was still young. It was the kind of a riddle where you punch in a bunch of numbers and operators into a simple pocket calculator and then turn it upside down to get the answer:</p>

<p>These come in many different sizes but they are always exactly one foot long. Answer: 103 * 103 * 5.</p>

<p>What are made of ice to keep people warm? Answer: 50 * 40 * 250 + 791.</p>

<p>After a few minutes he found a large amount of such riddles and full of excitement he went to solve them. He turned his computer screen upside down, only to find out that he does not have a reasonable calculator program installed on his computer.</p>

<h6 id="problem">Problem</h6>

<p>You are given multiple sequences of button presses of a simple pocket calculator that consist of digits and arithmetic operators. For each such sequence find the number it would produce on a pocket calculator's display.</p>

<p>Note that the pocket calculator evaluates the operators in the order in which they are given. (i.e., there is no operator precedence.) Assume that the display of the calculator is large enough to show the result, and that its memory is sufficient to store all intermediate results.</p>

<h6 id="input">Input</h6>

<p>The first line of the input file contains an integer T specifying the number of test cases. Each test case is preceded by a blank line.</p>

<p>Each test case represents one sequence of button presses for a pocket calculator. The sequence consists of non-negative integers and arithmetic operators and ends with an equal sign. It may also contain spaces to improve readability.</p>

<p>The operator / represents integer division, rounded down. You may assume that no test case contains division by zero and that in all test cases all intermediate results are non-negative.</p>

<p>Tip: long long int in C/C++, long in Java or int64 in Pascal is enough for this problem.</p>

<h6 id="output">Output</h6>

<p>For each sequence from the input file output the number that would be displayed on the calculator.</p>

<p>Example</p>

<p>Input: <br>
4</p>

<p>1 + 1 * 2 =</p>

<p>29 / 5 =</p>

<p>103 * 103 * 5 =</p>

<p>50 * 40 * 250 + 791 =</p>

<p>Output: <br>
4 <br>
5 <br>
53045 <br>
500791 <br>
Hint</p>

<p>The first test case shows that there is no operator precedence.</p>

<p>The second one shows that integer division always rounds down.</p>

<p>The last two outputs are the answers to the two riddles in the problem statement: "shoes" (53045 upside down), and "igloos"(500791 upside down).</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

using namespace std;

int main() {  
    int  T;
    cin &gt;&gt; T;

    cin.ignore();

    for (;T--;) {
        string S;
        cin.ignore();
        getline(cin, S);
        istringstream iss(S);
        long long n = 0, N = 0;
        char op = '+';
        while(iss &gt;&gt; n) {
            if (op == '+') {
                N += n;
            } else if (op == '-') {
                N -= n;
            } else if (op == '*') {
                N *= n;
            } else if (op == '/') {
                N /= n;
            }
            if ((iss &gt;&gt; op) &amp;&amp; (op == '=')) {
                cout &lt;&lt; N &lt;&lt; "\n";
            }
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/21/arith2/</link><guid isPermaLink="false">f8e3d594-52f1-45d7-9346-ab747ba24411</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 21 Nov 2014 16:14:14 GMT</pubDate></item></channel></rss>