<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[SPOJ - Code Jedi]]></title><description><![CDATA[Code, algorithms and design.]]></description><link>http://code-jedi.chintanghate.me/</link><generator>Ghost 0.5</generator><lastBuildDate>Sun, 30 Nov 2014 20:35:37 GMT</lastBuildDate><atom:link href="http://code-jedi.chintanghate.me/tag/spoj/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[PIGBANK]]></title><description><![CDATA[<p>Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid.</p>

<p>But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!</p>

<h6 id="input">Input</h6>

<p>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it's weight in grams.</p>

<h6 id="output">Output</h6>

<p>Print exactly one line of output for each test case. The line must contain the sentence "The minimum amount of money in the piggy-bank is X." where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line "This is impossible.".</p>

<p>Example</p>

<p>Input: <br>
3 <br>
10 110 <br>
2 <br>
1 1 <br>
30 50 <br>
10 110 <br>
2 <br>
1 1 <br>
50 30 <br>
1 6 <br>
2 <br>
10 3 <br>
20 4</p>

<p>Output: <br>
The minimum amount of money in the piggy-bank is 60. <br>
The minimum amount of money in the piggy-bank is 100. <br>
This is impossible.</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int E,F;
        cin &gt;&gt; E &gt;&gt; F;
        F -= E;
        vector&lt;int&gt; dp(F + 1, 100000000);
        int N;
        cin &gt;&gt; N;
        for (int i = 0; i &lt; N; ++i) {
            int p, w;
            cin &gt;&gt; p &gt;&gt; w;
            if (dp[w] &gt; p) {
                dp[w] = p;
                for (int j = 1; j &lt;= F - w; ++j) {
                    if(dp[j + w] &gt; dp[j] + dp[w]) {
                        dp[j + w] = dp[j] + dp[w];
                    }
                }
            }
        }
        if(dp[F] &lt; 100000000) {
            cout &lt;&lt; "The minimum amount of money in the piggy-bank is " &lt;&lt; dp[F] &lt;&lt; ".\n";
        } else {
            cout &lt;&lt; "This is impossible.\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/29/pigbank/</link><guid isPermaLink="false">44f5c2a6-ccfd-484d-b43f-343a3c927f1e</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 29 Nov 2014 13:08:54 GMT</pubDate></item><item><title><![CDATA[PARTY]]></title><description><![CDATA[<p>You just received another bill which you cannot pay because you lack the money. Unfortunately, this is not the first time to happen, and now you decide to investigate the cause of your constant monetary shortness. The reason is quite obvious: the lion's share of your money routinely disappears at the entrance of party localities. </p>

<p>You make up your mind to solve the problem where it arises, namely at the parties themselves. You introduce a limit for your party budget and try to have the most possible fun with regard to this limit. </p>

<p>You inquire beforehand about the entrance fee to each party and estimate how much fun you might have there. The list is readily compiled, but how do you actually pick the parties that give you the most fun and do not exceed your budget? </p>

<p>Write a program which finds this optimal set of parties that offer the most fun. Keep in mind that your budget need not necessarily be reached exactly. Achieve the highest possible fun level, and do not spend more money than is absolutely necessary.</p>

<h6 id="input">Input</h6>

<p>The first line of the input specifies your party budget and the number n of parties. </p>

<p>The following n lines contain two numbers each. The first number indicates the entrance fee of each party. Parties cost between 5 and 25 francs. The second number indicates the amount of fun of each party, given as an integer number ranging from 0 to 10. </p>

<p>The budget will not exceed 500 and there will be at most 100 parties. All numbers are separated by a single space. </p>

<p>There are many test cases. Input ends with 0 0.</p>

<h6 id="output">Output</h6>

<p>For each test case your program must output the sum of the entrance fees and the sum of all fun values of an optimal solution. Both numbers must be separated by a single space.</p>

<p>Example</p>

<p>Input: <br>
50 10 <br>
12 3 <br>
15 8 <br>
16 9 <br>
16 6 <br>
10 2 <br>
21 9 <br>
18 4 <br>
12 4 <br>
17 8 <br>
18 9 </p>

<p>50 10 <br>
13 8 <br>
19 10 <br>
16 8 <br>
12 9 <br>
10 2 <br>
12 8 <br>
13 5 <br>
15 5 <br>
11 7 <br>
16 2</p>

<p>0 0</p>

<p>Output: <br>
49 26 <br>
48 32</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

pair&lt;int, int&gt; knapSack(int b, vector&lt;int&gt; budget, vector&lt;int&gt; fun) {  
    int n = budget.size();
    vector&lt;vector&lt;int&gt; &gt; k(n + 1, vector&lt;int&gt; (b + 1));
    for (int i = 0; i &lt;= n; ++i) {
        for (int j = 0; j &lt;= b; ++j) {
            if (i == 0 || j == 0) {
                k[i][j] = 0;
            } else if ((budget[i - 1] &lt;= j) &amp;&amp; (fun[i - 1] + k[i - 1][j - budget[i - 1]]) &gt; k[i - 1][j]) {
                k[i][j] = fun[i - 1] + k[i - 1][j - budget[i - 1]];
            } else {
                k[i][j] = k[i - 1][j];
            }
        }
    }
    int ans = 0;
    for (int i = 0; i &lt;= b; ++i) {
        if (k[n][i] == k[n][b]) {
            ans = i;
            break;
        }
    }
    return make_pair(ans, k[n][b]);
}

int main() {  
    int b, p;
    while ((cin &gt;&gt; b &gt;&gt; p) &amp;&amp; !(b == 0 &amp;&amp; p == 0)) {
        vector&lt;int&gt; budget(p),
                    fun(p);
        for (int i = 0; i &lt; p; ++i) {
            cin &gt;&gt; budget[i] &gt;&gt; fun[i];
        }
        pair&lt;int, int&gt; ans = knapSack(b, budget, fun);
        cout &lt;&lt; ans.first &lt;&lt; " " &lt;&lt; ans.second &lt;&lt; "\n";
    } 
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/29/party/</link><guid isPermaLink="false">1efbd2f9-8f70-4162-bc1e-79717acbe02e</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 29 Nov 2014 11:37:15 GMT</pubDate></item><item><title><![CDATA[CRDS]]></title><description><![CDATA[<p>Maricruz have a lot of cards, she always uses her cards to build pyramids as shown in the following image:</p>

<p><img src="http://code-jedi.chintanghate.me/content/images/2014/11/francky-cards.png" alt="Cards"></p>

<p>A pyramid card of 3 levels. <br>
She always wonder how many cards does she need to make a pyramid card of N levels. Your task is to answer that question.</p>

<h6 id="input">Input</h6>

<p>The first line of the input contains an integer 1&lt;= T &lt;= 1,000. Each of the following T lines will have an integer 1&lt;= N &lt;= 1,000,000.</p>

<h6 id="output">Output</h6>

<p>For each case, output a single line consisting of the number of cards needed to build a pyramid card of level N modulo 1,000,007.</p>

<p>Example</p>

<p>Input: <br>
2 <br>
3 <br>
7</p>

<p>Output: <br>
15 <br>
77</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        unsigned long long levels;
        cin &gt;&gt; levels;
        unsigned long long cards = 
        (((levels * (levels + 1) / 2) * 3) - levels);
        cout &lt;&lt; cards % 1000007 &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/crds/</link><guid isPermaLink="false">80d9e6f9-0109-4490-a9b5-32d931259a55</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 17:25:46 GMT</pubDate></item><item><title><![CDATA[EGYPIZZA]]></title><description><![CDATA[<p>Abotrika is having a party because his team won the african cup so he is inviting his friends to eat some pizza. Unfortunately, Abotrika's friends can't eat an entire pizza but all of them know exactly how much pizza they can eat and insist on getting the exact amount of pizza but Abotrika eats one complete pizza and all of them wants his amount of pizza in one slice.</p>

<p>Their requests break down to three different pizza slices-either one quarter or a half or three quarters of pizza. write a program that will help Abotrika to find out what is the minimal number of pizzas he has to order so that everyone gets exact amount of pizza they want.</p>

<h6 id="input">Input</h6>

<p>First line contains an integer N, 0&lt;=N&lt;=10000, number of friends. In each of next N lines there is amount of pizza that each of Abotrika's friends wants to eat,that is the fraction 1/4, 1/2 or 3/4.</p>

<h6 id="output">Output</h6>

<p>In the first and only line you should write the minimal number of pizzas Abotrika has order don't forget to order one complete pizza for Abotrika</p>

<p>Example</p>

<p>Input: <br>
3 <br>
1/2 <br>
3/4 <br>
3/4</p>

<p>Output: <br>
4</p>

<p>Input: <br>
5 <br>
1/2 <br>
3/4 <br>
1/2 <br>
1/4 <br>
1/4</p>

<p>Output: <br>
4</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {  
    int N;
    cin &gt;&gt; N;
    long long a = 1,
              q = 0,
              h = 0,
              t = 0;
    for (;N--;) {
        string s;
        cin &gt;&gt; s;
        if (s == "1/2") {
            ++h;
        } else if (s == "3/4") {
            ++t;
        } else {
            ++q;
        }
    }
    a += h / 2;
    a += (h % 2);
    if (h % 2 == 1) {
        q -= 2;
    }
    if (t &gt;= q) {
        a += t;
    } else {
        a += t;
        q -= t;
        a += q/4;
        a += (q % 4 &gt; 0 ? 1 : 0);
    }
    cout &lt;&lt; a &lt;&lt; "\n";
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/egypizza/</link><guid isPermaLink="false">848e8203-7cb7-4208-8e48-e6956466548d</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 15:38:00 GMT</pubDate></item><item><title><![CDATA[OLOLOL]]></title><description><![CDATA[<p>Onotole has a lot of pyani. Each pyani has a number, writing on it. Pyanis with equal numbers are indistinguishable. Onotole knows everything, so, he knows that each pyani appeared twice, and only one pyani is unique. He wants to get вздръжни эффект, and he needs the unique pyani. Given the list of pyanis denote which one of them appeared once (it is guaranteed that other pyanis appeared twice).</p>

<h6 id="input">Input</h6>

<p>First line of input contains number of pyanis N&lt;=500 000. Next N lines contain a single positive integer 1 &lt;= Pi &lt;= 10^9.</p>

<h6 id="output">Output</h6>

<p>Output one positive integer on pyani, which appeared once.</p>

<p>Example</p>

<p>Input: <br>
3 <br>
1 <br>
8 <br>
1</p>

<p>Output: <br>
8</p>

<p>Onotole has found not optimal AC algorithms, so all solutions will be rejudged. He is watching you.</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;

using namespace std;

int main() {  
    int n;
    scanf("%d",&amp;n);
    long long x, res = 0;
    for (;n--;) {
        scanf("%lld",&amp;x);
        res ^= x;
    }
    cout &lt;&lt; res &lt;&lt; "\n";
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/ololol/</link><guid isPermaLink="false">d8be6bbf-e8dd-4d91-b1b3-1098c55c5425</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 13:18:27 GMT</pubDate></item><item><title><![CDATA[HYPNOS]]></title><description><![CDATA[<p>The process of “breaking” an integer is defined as summing the squares of its digits. For example, the result of breaking the integer 125 is (12 + 22 + 52) = 30. An integer N is happy if after “breaking” it repeatedly the result reaches 1. If the result never reaches 1 no matter how many times the “breaking” is repeated, then N is not a happy number.</p>

<h6 id="task">Task</h6>

<p>Write a program that given an integer N, determines whether it is a happy number or not.</p>

<h6 id="constraints">Constraints</h6>

<p>2 ≤ N ≤ 2,147,483,647</p>

<h6 id="input">Input</h6>

<p>A single line containing a single integer N.</p>

<h6 id="output">Output</h6>

<p>A single line containing a single integer T which is the number of times the process had to be done to determine that N is happy, or -1 if N is not happy.</p>

<p>Example</p>

<p>Input: <br>
19</p>

<p>Output: <br>
4</p>

<p>1) 19   : 12 + 92 = 82 <br>
2) 82   : 82 + 22 = 68 <br>
3) 68   : 62 + 82 = 100 <br>
4) 100 : 12 + 02 + 02 = 1</p>

<p>The solution is 4 because we discovered that the integer 19 is happy after we repeated the process 4 <br>
times.</p>

<p>Example</p>

<p>Input: <br>
204</p>

<p>Output: <br>
-1</p>

<p>204 –> 20 –> 4 –> 16 –> 37 –> 58 –> 89 –> 145 –> 42 –> 20 –> 4 –> 16 –> 37 –> 58 –> 89 –> 145 ……..</p>

<p>204 is not a happy number because after breaking it several times the results start repeating so we can deduce that if we continue breaking it, the result will never reach 1.</p>

<p>Number of test cases is 32.</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

typedef long long ll;

ll breakNumber(ll N) {  
    ll res = 0;
    while (N != 0) {
        int n = N % 10;
        res += (n * n);
        N /= 10;
    }
    return res;
}

int main() {  
    int N;
    cin &gt;&gt; N;
    set&lt;ll&gt; pows;
    pows.insert(N);
    ll count = 0;
    while (N != 1) {
        N = breakNumber(N);
        if (pows.find(N) != pows.end()) {
            count = -1;
            break;
        } else {
            pows.insert(N);
            ++count;
        }
    }
    cout &lt;&lt; count &lt;&lt; "\n";
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/hypnos/</link><guid isPermaLink="false">cb4b527e-e33c-4e14-b403-967f3a1b9757</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 13:09:53 GMT</pubDate></item><item><title><![CDATA[BITMAP]]></title><description><![CDATA[<p>There is given a rectangular bitmap of size n*m. Each pixel of the bitmap is either white or black, but at least one is white. The pixel in i-th line and j-th column is called the pixel (i,j). The distance between two pixels p1=(i1,j1) and p2=(i2,j2) is defined as:</p>

<p>d(p1,p2)=|i1-i2|+|j1-j2|.</p>

<h6 id="task">Task</h6>

<p>Write a program which:</p>

<ul>
<li>reads the description of the bitmap from the standard input,</li>
<li>for each pixel, computes the distance to the nearest white pixel,</li>
<li>writes the results to the standard output.</li>
</ul>

<h6 id="input">Input</h6>

<p>The number of test cases t is in the first line of input, then t test cases follow separated by an empty line. In the first line of each test case there is a pair of integer numbers n, m separated by a single space, 1&lt;=n &lt;=182, 1&lt;=m&lt;=182. In each of the following n lines of the test case exactly one zero-one word of length m, the description of one line of the bitmap, is written. On the j-th position in the line (i+1), 1 &lt;= i &lt;= n, 1 &lt;= j &lt;= m, is '1' if, and only if the pixel (i,j) is white.</p>

<h6 id="output">Output</h6>

<p>In the i-th line for each test case, 1&lt;=i&lt;=n, there should be written m integers f(i,1),...,f(i,m) separated by single spaces, where f(i,j) is the distance from the pixel (i,j) to the nearest white pixel.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
3 4 <br>
0001 <br>
0011 <br>
0110</p>

<p>Output: <br>
3 2 1 0 <br>
2 1 0 0 <br>
1 0 0 1</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

void bfs(vector&lt;vector&lt;int&gt; &gt; &amp;dist, int x, int y, int d) {  
    int n = dist.size(),
        m = dist[0].size();
    if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; dist[x][y] &gt; d) {
        dist[x][y] = d;
        bfs(dist, x + 1, y, d + 1);
        bfs(dist, x - 1, y, d + 1);
        bfs(dist, x, y + 1, d + 1);
        bfs(dist, x, y - 1, d + 1);
    }
    return;
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int n, m;
        cin &gt;&gt; n &gt;&gt; m;
        vector&lt;string&gt; grid(n);
        vector&lt;vector&lt;int&gt; &gt; dist(n, vector&lt;int&gt; (m, 400));
        for (int i = 0; i &lt; n; ++i) {
            cin &gt;&gt; grid[i];
        }
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; m; ++j) {
                if (grid[i][j] == '1') {
                    bfs(dist, i, j, 0);
                }
            }
        }
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; m; ++j) {
                cout &lt;&lt; dist[i][j] &lt;&lt; " ";
            }
            cout &lt;&lt; "\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/bitmap/</link><guid isPermaLink="false">09df0738-8c1b-4b87-8029-6ae6968f1869</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 04:07:25 GMT</pubDate></item><item><title><![CDATA[ACODE]]></title><description><![CDATA[<p>Alice and Bob need to send secret messages to each other and are discussing ways to encode their messages:  </p>

<pre><code>Alice: “Let’s just use a very simple code: We’ll assign ‘A’ the code word 1, ‘B’ will be 2, and so on down to ‘Z’ being assigned 26.”

Bob: “That’s a stupid code, Alice. Suppose I send you the word ‘BEAN’ encoded as 25114. You could decode that in many different ways!”

Alice: “Sure you could, but what words would you get? Other than ‘BEAN’, you’d get ‘BEAAD’, ‘YAAD’, ‘YAN’, ‘YKD’ and ‘BEKD’. I think you would be able to figure out the correct decoding. And why would you send me the word ‘BEAN’ anyway?”

Bob: “OK, maybe that’s a bad example, but I bet you that if you got a string of length 5000 there would be tons of different decodings and with that many you would find at least two different ones that would make sense.”

Alice: “How many different decodings?”

Bob: “Jillions!”  
</code></pre>

<p>For some reason, Alice is still unconvinced by Bob’s argument, so she requires a program that will determine how many decodings there can be for a given string using her code.</p>

<h6 id="input">Input</h6>

<p>Input will consist of multiple input sets. Each set will consist of a single line of at most 5000 digits representing a valid encryption (for example, no line will begin with a 0). There will be no spaces between the digits. An input line of ‘0’ will terminate the input and should not be processed.</p>

<h6 id="output">Output</h6>

<p>For each input set, output the number of possible decodings for the input string. All answers will be within the range of a 64 bit signed integer.</p>

<p>Example</p>

<p>Input: <br>
25114 <br>
1111111111 <br>
3333333333 <br>
0</p>

<p>Output: <br>
6 <br>
89 <br>
1</p>

<hr>

<h6 id="usingdynamicprogramming">Using Dynamic Programming:</h6>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int main() {  
    string s;
    while ((cin &gt;&gt; s) &amp;&amp; s != "0") {
        vector&lt;int&gt; ones(s.size(), 0),
                    tens(s.size(), 0),
                    ways(s.size(), 0);
        for (int i = 0; i &lt; s.size(); ++i) {
            ones[i] = s[i] - '0';
        }
        for (int i = 1; i &lt; s.size(); ++i) {
            tens[i] = 10 * ones[i - 1] + ones[i];
        }
        ways[0] = 1;
        if (s.size() &gt; 1) {
            ways[1] = (ones[1] != 0 ? 1 : 0);
            if (tens[1] &gt; 9 &amp;&amp; tens[1] &lt; 27) {
                ++ways[1];
            }
            for (int i = 2; i &lt; s.size(); ++i) {
                ways[i] = (ones[i] != 0 ? ways[i - 1] : 0);
                if (tens[i] &gt; 9 &amp;&amp; tens[i] &lt; 27) {
                    ways[i] += ways[i - 2];
                }
            }
        }
        cout &lt;&lt; ways.back() &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>

<hr>

<h6 id="using2variables">Using 2 variables:</h6>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {  
    string s;
    while ((cin &gt;&gt; s) &amp;&amp; s != "0") {
        int good = 1,
            bad = 0;
        for (int i = 1; i &lt; s.size(); ++i) {
            int n = (10 * (s[i - 1] - '0') + (s[i] - '0'));
            if (s[i] == '0') {
                if (n &gt;= 27) {
                    good = 0;
                    bad = 0;
                    break;
                }
                bad = good;
                good = 0; 
            } else if (n &lt; 27 &amp;&amp; n &gt; 9) {
                good += bad;
                bad = good - bad;
            } else {
                good += bad;
                bad = 0;
            }
        }
        cout &lt;&lt; good + bad &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/acode/</link><guid isPermaLink="false">66e0fc84-f274-4962-8e98-51a5c0ee2e29</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Thu, 27 Nov 2014 07:31:59 GMT</pubDate></item><item><title><![CDATA[MARBLES]]></title><description><![CDATA[<p>Hänschen dreams he is in a shop with an infinite amount of marbles. He is allowed to select n marbles. There are marbles of k different colors. From each color there are also infinitely many marbles. Hänschen wants to have at least one marble of each color, but still there are a lot of possibilities for his selection. In his effort to make a decision he wakes up. Now he asks you how many possibilites for his selection he would have had. Assume that marbles of equal color can't be distinguished, and the order of the marbles is irrelevant.</p>

<h6 id="input">Input</h6>

<p>The first line of input contains a number T &lt;= 100 that indicates the number of test cases to follow. Each test case consists of one line containing n and k, where n is the number of marbles Hänschen selects and k is the number of different colors of the marbles. You can assume that 1&lt;=k&lt;=n&lt;=1000000.</p>

<h6 id="output">Output</h6>

<p>For each test case print the number of possibilities that Hänschen would have had. You can assume that this number fits into a signed 64 bit integer.</p>

<p>Example</p>

<p>Input: <br>
2 <br>
10 10 <br>
30 7</p>

<p>Output: <br>
1 <br>
475020</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

unsigned long long gcd(unsigned long long a, unsigned long long b) {  
    return (b == 0 ? a : gcd(b, a % b));
}

unsigned long long NCR(unsigned long long N, unsigned long long K) {  
    if(K &gt; N) {
        return 0;
    }
    K = min(N - K, K);
    unsigned long long p = 1;
    for (unsigned long long i = 1; i &lt;= K ; ++i) {
        unsigned long long g = gcd(p, i);
        p /= g;
        p *= (N - i + 1) / (i / g);
    }
    return p;
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        unsigned long long N, K;
        cin &gt;&gt; N &gt;&gt; K;
        --N, --K;
        cout &lt;&lt; NCR(N, K) &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/marbles/</link><guid isPermaLink="false">bea21dd8-92e3-4b40-a042-f2f4e9f409fd</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Thu, 27 Nov 2014 04:19:00 GMT</pubDate></item><item><title><![CDATA[BYTESM2]]></title><description><![CDATA[<p>One of the secret chambers in Hogwarts is full of philosopher’s stones. The floor of the chamber is covered by h × w square tiles, where there are h rows of tiles from front (first row) to back (last row) and w columns of tiles from left to right. Each tile has 1 to 100 stones on it. Harry has to grab as many philosopher’s stones as possible, subject to the following restrictions:</p>

<ul>
<li>He starts by choosing any tile in the first row, and collects the philosopher’s stones on that tile. Then, he moves to a tile in the next row, collects the philosopher’s stones on the tile, and so on until he reaches the last row.</li>
<li>When he moves from one tile to a tile in the next row, he can only move to the tile just below it or diagonally to the left or right.</li>
</ul>

<p>Given the values of h and w, and the number of philosopher’s stones on each tile, write a program to compute the maximum possible number of philosopher’s stones Harry can grab in one single trip from the first row to the last row.</p>

<h6 id="input">Input</h6>

<p>The first line consists of a single integer T, the number of test cases. In each of the test cases, the first line has two integers. The first integer h (1&lt;=h&lt;=100) is the number of rows of tiles on the floor. The second integer w (1&lt;=w&lt;=100) is the number of columns of tiles on the floor. Next, there are h lines of inputs. The ith line of these, specifies the number of philosopher’s stones in each tile of the ith row from the front. Each line has w integers, where each integer m (0&lt;=m&lt;=100) is the number of philosopher’s stones on that tile. The integers are separated by a space character.</p>

<h6 id="output">Output</h6>

<p>The output should consist of T lines, (1&lt;=T&lt;=100), one for each test case. Each line consists of a single integer, which is the maximum possible number of philosopher’s stones Harry can grab, in one single trip from the first row to the last row for the corresponding test case.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
6 5 <br>
3 1 7 4 2 <br>
2 1 3 1 1 <br>
1 2 2 1 8 <br>
2 2 1 5 3 <br>
2 1 4 4 4 <br>
5 2 7 5 1</p>

<p>Output: <br>
32     </p>

<p>//7+1+8+5+4+7=32</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int h, w;
        cin &gt;&gt; h &gt;&gt; w;
        vector&lt;vector&lt;int&gt; &gt; grid(h, vector&lt;int&gt;(w));
        for (int i = 0; i &lt; h; ++i) {
            for (int j = 0; j &lt; w; ++j) {
                cin &gt;&gt; grid[i][j];
            }
        }
        for (int i = h - 2; i &gt;= 0; --i) {
            for (int j = 0; j &lt; w; ++j) {
                int maximum = 0;
                if (j - 1 &gt;= 0 &amp;&amp; grid[i + 1][j - 1] &gt; maximum) {
                    maximum = grid[i + 1][j - 1];
                }
                if (grid[i + 1][j] &gt; maximum) {
                    maximum = grid[i + 1][j];
                }
                if (j + 1 &lt; w &amp;&amp; grid[i + 1][j + 1] &gt; maximum) {
                    maximum = grid[i + 1][j + 1];
                }
                grid[i][j] += maximum;
            }
        }
        cout &lt;&lt; *max_element(grid[0].begin(), grid[0].end()) 
             &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/bytesm2/</link><guid isPermaLink="false">4ee19633-c9f6-4361-996d-71226822d994</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 20:01:46 GMT</pubDate></item><item><title><![CDATA[JAVAC]]></title><description><![CDATA[<p>Apologists of Java and C++ can argue for hours proving each other that their programming language is the best one. Java people will tell that their programs are clearer and less prone to errors, while C++ people will laugh at their inability to instantiate an array of generics or tell them that their programs are slow and have long source code.</p>

<p>Another issue that Java and C++ people could never agree on is identifier naming. In Java a multiword identifier is constructed in the following manner: the first word is written starting from the small letter, and the following ones are written starting from the capital letter, no separators are used. All other letters are small. Examples of a Java identifier are javaIdentifier, longAndMnemonicIdentifier, name, nEERC.</p>

<p>Unlike them, C++ people use only small letters in their identifiers. To separate words they use underscore character ‘<em>’. Examples of C++ identifiers are c</em>identifier, long<em>and</em>mnemonic<em>identifier, name (you see that when there is just one word Java and C++ people agree), n</em>e<em>e</em>r_c.</p>

<p>You are writing a translator that is intended to translate C++ programs to Java and vice versa. Of course, identifiers in the translated program must be formatted due to its language rules — otherwise people will never like your translator.</p>

<p>The first thing you would like to write is an identifier translation routine. Given an identifier, it would detect whether it is Java identifier or C++ identifier and translate it to another dialect. If it is neither, then your routine should report an error. Translation must preserve the order of words and must only change the case of letters and/or add/remove underscores.</p>

<h6 id="input">Input</h6>

<p>The input file consists of several lines that contains an identifier. It consists of letters of the English alphabet and underscores. Its length does not exceed 100.</p>

<h6 id="output">Output</h6>

<p>If the input identifier is Java identifier, output its C++ version. If it is C++ identifier, output its Java version. If it is none, output 'Error!' instead.</p>

<p>Example</p>

<p>Input: <br>
long_and_mnemonic_identifier <br>
anotherExample <br>
i <br>
bad_Style</p>

<p>Output: <br>
longAndMnemonicIdentifier <br>
another_example <br>
i <br>
Error!</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cctype&gt;

using namespace std;

bool isJavaIdentifier(string s) {  
    if (!islower(s[0])) {
        return false;
    }
    for (int i = 0; i &lt; s.size(); ++i) {
        if (!isalpha(s[i])) {
            return false;
        }
    }
    return true;
}

bool isCIdentifier(string s) {  
    if (!islower(s[0])) {
        return false;
    }
    for (int i = 0; i &lt; s.size(); ++i) {
        if (!islower(s[i]) &amp;&amp; s[i] != '_') {
            return false;
        }
        if (s[i] == '_' &amp;&amp; !islower(s[i+1])) {
            return false;
        }
    }
    return true;
}

int main() {  
    string s;
    while (cin &gt;&gt; s) {
        bool java = isJavaIdentifier(s),
             c = isCIdentifier(s);
        if (!java &amp;&amp; !c) {
            cout &lt;&lt; "Error!\n";
        } else if (java) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if (isupper(s[i])) {
                    o += '_';
                }
                o += tolower(s[i]);
            }
            cout &lt;&lt; o &lt;&lt; "\n";
        } else if (c) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] == '_') {
                    ++i;
                    o += toupper(s[i]);
                } else {
                    o += s[i];
                }
            }
            cout &lt;&lt; o &lt;&lt; "\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/javac/</link><guid isPermaLink="false">4077835d-1bca-4079-96f6-0e3e12e31991</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 18:49:32 GMT</pubDate></item><item><title><![CDATA[NY10A]]></title><description><![CDATA[<p>Penney’s game is a simple game typically played by two players.  One version of the game calls for each player to choose a unique three-coin sequence such as HEADS TAILS HEADS (HTH).  A fair coin is tossed sequentially some number of times until one of the two sequences appears.  The player who chose the first sequence to appear wins the game.</p>

<p>For this problem, you will write a program that implements a variation on the Penney Game.  You willread a sequence of 40 coin tosses and determine how many times each three-coin sequence appears.  Obviously there are eight such three-coin sequences: TTT, TTH, THT, THH, HTT, HTH, HHT and HHH. Sequences may overlap.  For example, if all 40 coin tosses are heads, then the sequence HHH appears 38 times.</p>

<h6 id="input">Input</h6>

<p>The first line of input contains a single integer P, (1 ≤ P ≤ 1000), which is the number of data sets that follow.  Each data set consists of 2 lines.  The first line contains the data set number N.  The second line contains the sequence of 40 coin tosses.  Each toss is represented as an upper case H or an upper case T, for heads or tails, respectively.  There will be no spaces on any input line.</p>

<h6 id="output">Output</h6>

<p>For each data set there is one line of output.  It contains the data set number followed by a single space, followed by the number of occurrences of each three-coin sequence, in the order shown above, with a space between each one.  There should be a total of 9 space separated decimal integers on each output line.</p>

<p>Example</p>

<p>Input: <br>
4 <br>
1 <br>
HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH <br>
2 <br>
TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT <br>
3 <br>
HHTTTHHTTTHTHHTHHTTHTTTHHHTHTTHTTHTTTHTH <br>
4 <br>
HTHTHHHTHHHTHTHHHHTTTHTTTTTHHTTTTHTHHHHT</p>

<p>Output: <br>
1 0 0 0 0 0 0 0 38 <br>
2 38 0 0 0 0 0 0 0 <br>
3 4 7 6 4 7 4 5 1 <br>
4 6 3 4 5 3 6 5 6</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int n;
        cin &gt;&gt; n;
        string s;
        cin &gt;&gt; s;
        vector&lt;int&gt; counter(8, 0);
        for (int i = 0; i &lt; s.size() - 2; ++i) {
            int index = 0;
            index += (s[i] == 'H' ? 4 : 0);
            index += (s[i + 1] == 'H' ? 2 : 0);
            index += (s[i + 2] == 'H' ? 1 : 0);
            ++counter[index];
        }
        cout &lt;&lt; n;
        for (int i = 0; i &lt; 8; ++i) {
            cout &lt;&lt; " " &lt;&lt; counter[i];
        }
        cout &lt;&lt; "\n";
    }   
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/26/ny10a/</link><guid isPermaLink="false">8ef0f847-ce46-4d07-8f04-a07ed3defad8</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 15:24:13 GMT</pubDate></item><item><title><![CDATA[PT07Z]]></title><description><![CDATA[<p>You are given an unweighted, undirected tree. Write a program to output the length of the longest path (from one node to another) in that tree. The length of a path in this case is number of edges we traverse from source to destination.</p>

<h6 id="input">Input</h6>

<p>The first line of the input file contains one integer N --- number of nodes in the tree (0 &lt; N &lt;= 10000). Next N-1 lines contain N-1 edges of that tree --- Each line contains a pair (u, v) means there is an edge between node u and node v (1 &lt;= u,v &lt;= N).</p>

<h6 id="output">Output</h6>

<p>Print the length of the longest path on one line.</p>

<p>Example</p>

<p>Input: <br>
3 <br>
1 2 <br>
2 3</p>

<p>Output: <br>
2</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

using namespace std;

pair&lt;int, int&gt; longestPath(vector&lt;vector&lt;int&gt; &gt; adj, int source) {  
    int nodes = adj.size();
    deque&lt;int&gt; q;
    vector&lt;bool&gt; visited(nodes, false);
    vector&lt;int&gt; sourceDist(nodes, 0);
    q.push_back(source);
    visited[source] = true;
    while (!q.empty()) {
        int current = q.front();
        q.pop_front();
        for (int i = 0; i &lt; adj[current].size(); ++i) {
            if (!visited[adj[current][i]]) {
                sourceDist[adj[current][i]] = 
                    sourceDist[current] + 1;
                q.push_back(adj[current][i]);
                visited[adj[current][i]] = true;
            }
        }
    }
    int maxIndex = max_element(sourceDist.begin(), 
                   sourceDist.end()) - sourceDist.begin();
    return make_pair(sourceDist[maxIndex], maxIndex);
}

int main() {  
    int nodes;
    cin &gt;&gt; nodes;
    vector&lt;vector&lt;int&gt; &gt; adj(nodes);
    for (int i = 0; i &lt; nodes - 1; ++i) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        --u, --v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    int farthestNode = longestPath(adj, 0).second;
    cout &lt;&lt; longestPath(adj, farthestNode).first &lt;&lt; "\n";
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/26/pt07z/</link><guid isPermaLink="false">c6880079-7f17-4a32-a815-26e12b3221bf</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 14:49:23 GMT</pubDate></item><item><title><![CDATA[LASTDIG2]]></title><description><![CDATA[<p>Pappu was doing the work of his math class about three days but he is tired of make operations a lot and he should deliver his task tomorrow. His math’s teacher gives two numbers a and b. The problem consist in find the last digit of the potency of base a and index b. Help Pappu with his problem. You are given two integer numbers: the base a (number of digits d, such that 1&lt;=d&lt;=1000) and the index b (0 &lt;= b &lt;= 922*10^15). You have to find the last digit of a^b.</p>

<h6 id="input">Input</h6>

<p>The first line of input contains an integer t, the number of test cases (t &lt;= 30). t test cases follow. For each test case will appear a and b separated by space.</p>

<h6 id="output">Output</h6>

<p>For each test case output an integer per line representing the result.</p>

<p>Example</p>

<p>Input: <br>
3 <br>
3 10 <br>
6 2 <br>
150 53</p>

<p>Output: <br>
9 <br>
6 <br>
0</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int lastDig(int n, unsigned long long b) {  
    if (b == 0) {
        return 1;
    } else if (n == 0 || n == 1 || n == 5 || n == 6) {
        return n;
    }
    vector&lt;int&gt; ld;
    ld.push_back(n);
    int count = 0;
    do {
        ++count;
        ld.push_back((n*ld.back()) % 10);
    } while (ld.back() != n);
    int c = b % count - 1;
    if (c &lt; 0) {
        c += count;
    }
    return ld[c];
}

int main() {  
    int t;
    cin &gt;&gt; t;
    for (;t--;) {
        string a;
        unsigned long long b;
        cin &gt;&gt; a &gt;&gt; b;
        int n = a[a.size() - 1] - '0';
        cout &lt;&lt; lastDig(n, b) &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/26/lastdig2/</link><guid isPermaLink="false">f1d858ed-de4c-40ce-92a8-89d52e328a35</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 05:30:49 GMT</pubDate></item><item><title><![CDATA[EDIST]]></title><description><![CDATA[<p>You are given two strings, A and B. Answer, what is the smallest number of operations you need to <br>
transform A to B?</p>

<p>Operations are:</p>

<ol>
<li>Delete one letter from one of strings</li>
<li>Insert one letter into one of strings</li>
<li>Replace one of letters from one of strings with another letter </li>
</ol>

<h6 id="input">Input</h6>

<p>T - number of test cases</p>

<p>For each test case:</p>

<p>String A</p>

<p>String B</p>

<p>Both strings will contain only uppercase characters and they won't <br>
be longer than 2000 characters. </p>

<p>There will be 10 test cases in data set.</p>

<h6 id="output">Output</h6>

<p>For each test case, one line, minimum number of operations.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
FOOD <br>
MONEY </p>

<p>Output: <br>
4</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int LevenshteinDistance(string s, string t) {  
    if (s == t) {
        return 0;
    } else if (s.size() == 0) {
        return t.size();
    } else if (t.size() == 0) {
        return s.size();
    }

    vector&lt;int&gt; v0 = vector&lt;int&gt; (t.size() + 1),
                v1 = vector&lt;int&gt; (t.size() + 1);

    for (int i = 0; i &lt; v0.size(); ++i) {
        v0[i] = i;
    }

    for (int i = 0; i &lt; s.size(); ++i) {
        v1[0] = i + 1;
        for (int j = 0; j &lt; t.size(); ++j) {
            int cost = (s[i] == t[j] ? 0 : 1);
            v1[j + 1] = min(min(v1[j] + 1, v0[j + 1] + 1), 
                        v0[j] + cost);
        }
        v0 = v1;
    }
    return v1[t.size()];
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        string a,b;
        cin &gt;&gt; a &gt;&gt; b;
        cout &lt;&lt; LevenshteinDistance(a, b) &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/26/edist/</link><guid isPermaLink="false">edcc9410-811a-4155-a85e-0b2331740f17</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 03:46:18 GMT</pubDate></item></channel></rss>