<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[SPOJ - Code Jedi]]></title><description><![CDATA[Code, algorithms and design.]]></description><link>http://code-jedi.chintanghate.me/</link><generator>Ghost 0.5</generator><lastBuildDate>Thu, 27 Nov 2014 19:49:20 GMT</lastBuildDate><atom:link href="http://code-jedi.chintanghate.me/tag/spoj/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[ACODE]]></title><description><![CDATA[<p>Alice and Bob need to send secret messages to each other and are discussing ways to encode their messages:  </p>

<pre><code>Alice: “Let’s just use a very simple code: We’ll assign ‘A’ the code word 1, ‘B’ will be 2, and so on down to ‘Z’ being assigned 26.”

Bob: “That’s a stupid code, Alice. Suppose I send you the word ‘BEAN’ encoded as 25114. You could decode that in many different ways!”

Alice: “Sure you could, but what words would you get? Other than ‘BEAN’, you’d get ‘BEAAD’, ‘YAAD’, ‘YAN’, ‘YKD’ and ‘BEKD’. I think you would be able to figure out the correct decoding. And why would you send me the word ‘BEAN’ anyway?”

Bob: “OK, maybe that’s a bad example, but I bet you that if you got a string of length 5000 there would be tons of different decodings and with that many you would find at least two different ones that would make sense.”

Alice: “How many different decodings?”

Bob: “Jillions!”  
</code></pre>

<p>For some reason, Alice is still unconvinced by Bob’s argument, so she requires a program that will determine how many decodings there can be for a given string using her code.</p>

<h6 id="input">Input</h6>

<p>Input will consist of multiple input sets. Each set will consist of a single line of at most 5000 digits representing a valid encryption (for example, no line will begin with a 0). There will be no spaces between the digits. An input line of ‘0’ will terminate the input and should not be processed.</p>

<h6 id="output">Output</h6>

<p>For each input set, output the number of possible decodings for the input string. All answers will be within the range of a 64 bit signed integer.</p>

<p>Example</p>

<p>Input: <br>
25114 <br>
1111111111 <br>
3333333333 <br>
0</p>

<p>Output: <br>
6 <br>
89 <br>
1</p>

<hr>

<h6 id="usingdynamicprogramming">Using Dynamic Programming:</h6>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int main() {  
    string s;
    while ((cin &gt;&gt; s) &amp;&amp; s != "0") {
        vector&lt;int&gt; ones(s.size(), 0),
                    tens(s.size(), 0),
                    ways(s.size(), 0);
        for (int i = 0; i &lt; s.size(); ++i) {
            ones[i] = s[i] - '0';
        }
        for (int i = 1; i &lt; s.size(); ++i) {
            tens[i] = 10 * ones[i - 1] + ones[i];
        }
        ways[0] = 1;
        if (s.size() &gt; 1) {
            ways[1] = (ones[1] != 0 ? 1 : 0);
            if (tens[1] &gt; 9 &amp;&amp; tens[1] &lt; 27) {
                ++ways[1];
            }
            for (int i = 2; i &lt; s.size(); ++i) {
                ways[i] = (ones[i] != 0 ? ways[i - 1] : 0);
                if (tens[i] &gt; 9 &amp;&amp; tens[i] &lt; 27) {
                    ways[i] += ways[i - 2];
                }
            }
        }
        cout &lt;&lt; ways.back() &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>

<h6 id="using2variables">Using 2 variables:</h6>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {  
    string s;
    while ((cin &gt;&gt; s) &amp;&amp; s != "0") {
        int good = 1,
            bad = 0;
        for (int i = 1; i &lt; s.size(); ++i) {
            int n = (10 * (s[i - 1] - '0') + (s[i] - '0'));
            if (s[i] == '0') {
                if (n &gt;= 27) {
                    good = 0;
                    bad = 0;
                    break;
                }
                bad = good;
                good = 0; 
            } else if (n &lt; 27 &amp;&amp; n &gt; 9) {
                good += bad;
                bad = good - bad;
            } else {
                good += bad;
                bad = 0;
            }
        }
        cout &lt;&lt; good + bad &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/acode/</link><guid isPermaLink="false">66e0fc84-f274-4962-8e98-51a5c0ee2e29</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Thu, 27 Nov 2014 07:31:59 GMT</pubDate></item><item><title><![CDATA[MARBLES]]></title><description><![CDATA[<p>Hänschen dreams he is in a shop with an infinite amount of marbles. He is allowed to select n marbles. There are marbles of k different colors. From each color there are also infinitely many marbles. Hänschen wants to have at least one marble of each color, but still there are a lot of possibilities for his selection. In his effort to make a decision he wakes up. Now he asks you how many possibilites for his selection he would have had. Assume that marbles of equal color can't be distinguished, and the order of the marbles is irrelevant.</p>

<h6 id="input">Input</h6>

<p>The first line of input contains a number T &lt;= 100 that indicates the number of test cases to follow. Each test case consists of one line containing n and k, where n is the number of marbles Hänschen selects and k is the number of different colors of the marbles. You can assume that 1&lt;=k&lt;=n&lt;=1000000.</p>

<h6 id="output">Output</h6>

<p>For each test case print the number of possibilities that Hänschen would have had. You can assume that this number fits into a signed 64 bit integer.</p>

<p>Example</p>

<p>Input: <br>
2 <br>
10 10 <br>
30 7</p>

<p>Output: <br>
1 <br>
475020</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

unsigned long long gcd(unsigned long long a, unsigned long long b) {  
    return (b == 0 ? a : gcd(b, a % b));
}

unsigned long long NCR(unsigned long long N, unsigned long long K) {  
    if(K &gt; N) {
        return 0;
    }
    K = min(N - K, K);
    unsigned long long p = 1;
    for (unsigned long long i = 1; i &lt;= K ; ++i) {
        unsigned long long g = gcd(p, i);
        p /= g;
        p *= (N - i + 1) / (i / g);
    }
    return p;
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        unsigned long long N, K;
        cin &gt;&gt; N &gt;&gt; K;
        --N, --K;
        cout &lt;&lt; NCR(N, K) &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/marbles/</link><guid isPermaLink="false">bea21dd8-92e3-4b40-a042-f2f4e9f409fd</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Thu, 27 Nov 2014 04:19:00 GMT</pubDate></item><item><title><![CDATA[BYTESM2]]></title><description><![CDATA[<p>One of the secret chambers in Hogwarts is full of philosopher’s stones. The floor of the chamber is covered by h × w square tiles, where there are h rows of tiles from front (first row) to back (last row) and w columns of tiles from left to right. Each tile has 1 to 100 stones on it. Harry has to grab as many philosopher’s stones as possible, subject to the following restrictions:</p>

<ul>
<li>He starts by choosing any tile in the first row, and collects the philosopher’s stones on that tile. Then, he moves to a tile in the next row, collects the philosopher’s stones on the tile, and so on until he reaches the last row.</li>
<li>When he moves from one tile to a tile in the next row, he can only move to the tile just below it or diagonally to the left or right.</li>
</ul>

<p>Given the values of h and w, and the number of philosopher’s stones on each tile, write a program to compute the maximum possible number of philosopher’s stones Harry can grab in one single trip from the first row to the last row.</p>

<h6 id="input">Input</h6>

<p>The first line consists of a single integer T, the number of test cases. In each of the test cases, the first line has two integers. The first integer h (1&lt;=h&lt;=100) is the number of rows of tiles on the floor. The second integer w (1&lt;=w&lt;=100) is the number of columns of tiles on the floor. Next, there are h lines of inputs. The ith line of these, specifies the number of philosopher’s stones in each tile of the ith row from the front. Each line has w integers, where each integer m (0&lt;=m&lt;=100) is the number of philosopher’s stones on that tile. The integers are separated by a space character.</p>

<h6 id="output">Output</h6>

<p>The output should consist of T lines, (1&lt;=T&lt;=100), one for each test case. Each line consists of a single integer, which is the maximum possible number of philosopher’s stones Harry can grab, in one single trip from the first row to the last row for the corresponding test case.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
6 5 <br>
3 1 7 4 2 <br>
2 1 3 1 1 <br>
1 2 2 1 8 <br>
2 2 1 5 3 <br>
2 1 4 4 4 <br>
5 2 7 5 1</p>

<p>Output: <br>
32     </p>

<p>//7+1+8+5+4+7=32</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int h, w;
        cin &gt;&gt; h &gt;&gt; w;
        vector&lt;vector&lt;int&gt; &gt; grid(h, vector&lt;int&gt;(w));
        for (int i = 0; i &lt; h; ++i) {
            for (int j = 0; j &lt; w; ++j) {
                cin &gt;&gt; grid[i][j];
            }
        }
        for (int i = h - 2; i &gt;= 0; --i) {
            for (int j = 0; j &lt; w; ++j) {
                int maximum = 0;
                if (j - 1 &gt;= 0 &amp;&amp; grid[i + 1][j - 1] &gt; maximum) {
                    maximum = grid[i + 1][j - 1];
                }
                if (grid[i + 1][j] &gt; maximum) {
                    maximum = grid[i + 1][j];
                }
                if (j + 1 &lt; w &amp;&amp; grid[i + 1][j + 1] &gt; maximum) {
                    maximum = grid[i + 1][j + 1];
                }
                grid[i][j] += maximum;
            }
        }
        cout &lt;&lt; *max_element(grid[0].begin(), grid[0].end()) 
             &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/bytesm2/</link><guid isPermaLink="false">4ee19633-c9f6-4361-996d-71226822d994</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 20:01:46 GMT</pubDate></item><item><title><![CDATA[JAVAC]]></title><description><![CDATA[<p>Apologists of Java and C++ can argue for hours proving each other that their programming language is the best one. Java people will tell that their programs are clearer and less prone to errors, while C++ people will laugh at their inability to instantiate an array of generics or tell them that their programs are slow and have long source code.</p>

<p>Another issue that Java and C++ people could never agree on is identifier naming. In Java a multiword identifier is constructed in the following manner: the first word is written starting from the small letter, and the following ones are written starting from the capital letter, no separators are used. All other letters are small. Examples of a Java identifier are javaIdentifier, longAndMnemonicIdentifier, name, nEERC.</p>

<p>Unlike them, C++ people use only small letters in their identifiers. To separate words they use underscore character ‘<em>’. Examples of C++ identifiers are c</em>identifier, long<em>and</em>mnemonic<em>identifier, name (you see that when there is just one word Java and C++ people agree), n</em>e<em>e</em>r_c.</p>

<p>You are writing a translator that is intended to translate C++ programs to Java and vice versa. Of course, identifiers in the translated program must be formatted due to its language rules — otherwise people will never like your translator.</p>

<p>The first thing you would like to write is an identifier translation routine. Given an identifier, it would detect whether it is Java identifier or C++ identifier and translate it to another dialect. If it is neither, then your routine should report an error. Translation must preserve the order of words and must only change the case of letters and/or add/remove underscores.</p>

<h6 id="input">Input</h6>

<p>The input file consists of several lines that contains an identifier. It consists of letters of the English alphabet and underscores. Its length does not exceed 100.</p>

<h6 id="output">Output</h6>

<p>If the input identifier is Java identifier, output its C++ version. If it is C++ identifier, output its Java version. If it is none, output 'Error!' instead.</p>

<p>Example</p>

<p>Input: <br>
long_and_mnemonic_identifier <br>
anotherExample <br>
i <br>
bad_Style</p>

<p>Output: <br>
longAndMnemonicIdentifier <br>
another_example <br>
i <br>
Error!</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cctype&gt;

using namespace std;

bool isJavaIdentifier(string s) {  
    if (!islower(s[0])) {
        return false;
    }
    for (int i = 0; i &lt; s.size(); ++i) {
        if (!isalpha(s[i])) {
            return false;
        }
    }
    return true;
}

bool isCIdentifier(string s) {  
    if (!islower(s[0])) {
        return false;
    }
    for (int i = 0; i &lt; s.size(); ++i) {
        if (!islower(s[i]) &amp;&amp; s[i] != '_') {
            return false;
        }
        if (s[i] == '_' &amp;&amp; !islower(s[i+1])) {
            return false;
        }
    }
    return true;
}

int main() {  
    string s;
    while (cin &gt;&gt; s) {
        bool java = isJavaIdentifier(s),
             c = isCIdentifier(s);
        if (!java &amp;&amp; !c) {
            cout &lt;&lt; "Error!\n";
        } else if (java) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if (isupper(s[i])) {
                    o += '_';
                }
                o += tolower(s[i]);
            }
            cout &lt;&lt; o &lt;&lt; "\n";
        } else if (c) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] == '_') {
                    ++i;
                    o += toupper(s[i]);
                } else {
                    o += s[i];
                }
            }
            cout &lt;&lt; o &lt;&lt; "\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/javac/</link><guid isPermaLink="false">4077835d-1bca-4079-96f6-0e3e12e31991</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 18:49:32 GMT</pubDate></item><item><title><![CDATA[NY10A]]></title><description><![CDATA[<p>Penney’s game is a simple game typically played by two players.  One version of the game calls for each player to choose a unique three-coin sequence such as HEADS TAILS HEADS (HTH).  A fair coin is tossed sequentially some number of times until one of the two sequences appears.  The player who chose the first sequence to appear wins the game.</p>

<p>For this problem, you will write a program that implements a variation on the Penney Game.  You willread a sequence of 40 coin tosses and determine how many times each three-coin sequence appears.  Obviously there are eight such three-coin sequences: TTT, TTH, THT, THH, HTT, HTH, HHT and HHH. Sequences may overlap.  For example, if all 40 coin tosses are heads, then the sequence HHH appears 38 times.</p>

<h6 id="input">Input</h6>

<p>The first line of input contains a single integer P, (1 ≤ P ≤ 1000), which is the number of data sets that follow.  Each data set consists of 2 lines.  The first line contains the data set number N.  The second line contains the sequence of 40 coin tosses.  Each toss is represented as an upper case H or an upper case T, for heads or tails, respectively.  There will be no spaces on any input line.</p>

<h6 id="output">Output</h6>

<p>For each data set there is one line of output.  It contains the data set number followed by a single space, followed by the number of occurrences of each three-coin sequence, in the order shown above, with a space between each one.  There should be a total of 9 space separated decimal integers on each output line.</p>

<p>Example</p>

<p>Input: <br>
4 <br>
1 <br>
HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH <br>
2 <br>
TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT <br>
3 <br>
HHTTTHHTTTHTHHTHHTTHTTTHHHTHTTHTTHTTTHTH <br>
4 <br>
HTHTHHHTHHHTHTHHHHTTTHTTTTTHHTTTTHTHHHHT</p>

<p>Output: <br>
1 0 0 0 0 0 0 0 38 <br>
2 38 0 0 0 0 0 0 0 <br>
3 4 7 6 4 7 4 5 1 <br>
4 6 3 4 5 3 6 5 6</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int n;
        cin &gt;&gt; n;
        string s;
        cin &gt;&gt; s;
        vector&lt;int&gt; counter(8, 0);
        for (int i = 0; i &lt; s.size() - 2; ++i) {
            int index = 0;
            index += (s[i] == 'H' ? 4 : 0);
            index += (s[i + 1] == 'H' ? 2 : 0);
            index += (s[i + 2] == 'H' ? 1 : 0);
            ++counter[index];
        }
        cout &lt;&lt; n;
        for (int i = 0; i &lt; 8; ++i) {
            cout &lt;&lt; " " &lt;&lt; counter[i];
        }
        cout &lt;&lt; "\n";
    }   
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/26/ny10a/</link><guid isPermaLink="false">8ef0f847-ce46-4d07-8f04-a07ed3defad8</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 15:24:13 GMT</pubDate></item><item><title><![CDATA[PT07Z]]></title><description><![CDATA[<p>You are given an unweighted, undirected tree. Write a program to output the length of the longest path (from one node to another) in that tree. The length of a path in this case is number of edges we traverse from source to destination.</p>

<h6 id="input">Input</h6>

<p>The first line of the input file contains one integer N --- number of nodes in the tree (0 &lt; N &lt;= 10000). Next N-1 lines contain N-1 edges of that tree --- Each line contains a pair (u, v) means there is an edge between node u and node v (1 &lt;= u,v &lt;= N).</p>

<h6 id="output">Output</h6>

<p>Print the length of the longest path on one line.</p>

<p>Example</p>

<p>Input: <br>
3 <br>
1 2 <br>
2 3</p>

<p>Output: <br>
2</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

using namespace std;

pair&lt;int, int&gt; longestPath(vector&lt;vector&lt;int&gt; &gt; adj, int source) {  
    int nodes = adj.size();
    deque&lt;int&gt; q;
    vector&lt;bool&gt; visited(nodes, false);
    vector&lt;int&gt; sourceDist(nodes, 0);
    q.push_back(source);
    visited[source] = true;
    while (!q.empty()) {
        int current = q.front();
        q.pop_front();
        for (int i = 0; i &lt; adj[current].size(); ++i) {
            if (!visited[adj[current][i]]) {
                sourceDist[adj[current][i]] = 
                    sourceDist[current] + 1;
                q.push_back(adj[current][i]);
                visited[adj[current][i]] = true;
            }
        }
    }
    int maxIndex = max_element(sourceDist.begin(), 
                   sourceDist.end()) - sourceDist.begin();
    return make_pair(sourceDist[maxIndex], maxIndex);
}

int main() {  
    int nodes;
    cin &gt;&gt; nodes;
    vector&lt;vector&lt;int&gt; &gt; adj(nodes);
    for (int i = 0; i &lt; nodes - 1; ++i) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        --u, --v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    int farthestNode = longestPath(adj, 0).second;
    cout &lt;&lt; longestPath(adj, farthestNode).first &lt;&lt; "\n";
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/26/pt07z/</link><guid isPermaLink="false">c6880079-7f17-4a32-a815-26e12b3221bf</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 14:49:23 GMT</pubDate></item><item><title><![CDATA[LASTDIG2]]></title><description><![CDATA[<p>Pappu was doing the work of his math class about three days but he is tired of make operations a lot and he should deliver his task tomorrow. His math’s teacher gives two numbers a and b. The problem consist in find the last digit of the potency of base a and index b. Help Pappu with his problem. You are given two integer numbers: the base a (number of digits d, such that 1&lt;=d&lt;=1000) and the index b (0 &lt;= b &lt;= 922*10^15). You have to find the last digit of a^b.</p>

<h6 id="input">Input</h6>

<p>The first line of input contains an integer t, the number of test cases (t &lt;= 30). t test cases follow. For each test case will appear a and b separated by space.</p>

<h6 id="output">Output</h6>

<p>For each test case output an integer per line representing the result.</p>

<p>Example</p>

<p>Input: <br>
3 <br>
3 10 <br>
6 2 <br>
150 53</p>

<p>Output: <br>
9 <br>
6 <br>
0</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int lastDig(int n, unsigned long long b) {  
    if (b == 0) {
        return 1;
    } else if (n == 0 || n == 1 || n == 5 || n == 6) {
        return n;
    }
    vector&lt;int&gt; ld;
    ld.push_back(n);
    int count = 0;
    do {
        ++count;
        ld.push_back((n*ld.back()) % 10);
    } while (ld.back() != n);
    int c = b % count - 1;
    if (c &lt; 0) {
        c += count;
    }
    return ld[c];
}

int main() {  
    int t;
    cin &gt;&gt; t;
    for (;t--;) {
        string a;
        unsigned long long b;
        cin &gt;&gt; a &gt;&gt; b;
        int n = a[a.size() - 1] - '0';
        cout &lt;&lt; lastDig(n, b) &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/26/lastdig2/</link><guid isPermaLink="false">f1d858ed-de4c-40ce-92a8-89d52e328a35</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 05:30:49 GMT</pubDate></item><item><title><![CDATA[EDIST]]></title><description><![CDATA[<p>You are given two strings, A and B. Answer, what is the smallest number of operations you need to <br>
transform A to B?</p>

<p>Operations are:</p>

<ol>
<li>Delete one letter from one of strings</li>
<li>Insert one letter into one of strings</li>
<li>Replace one of letters from one of strings with another letter </li>
</ol>

<h6 id="input">Input</h6>

<p>T - number of test cases</p>

<p>For each test case:</p>

<p>String A</p>

<p>String B</p>

<p>Both strings will contain only uppercase characters and they won't <br>
be longer than 2000 characters. </p>

<p>There will be 10 test cases in data set.</p>

<h6 id="output">Output</h6>

<p>For each test case, one line, minimum number of operations.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
FOOD <br>
MONEY </p>

<p>Output: <br>
4</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int LevenshteinDistance(string s, string t) {  
    if (s == t) {
        return 0;
    } else if (s.size() == 0) {
        return t.size();
    } else if (t.size() == 0) {
        return s.size();
    }

    vector&lt;int&gt; v0 = vector&lt;int&gt; (t.size() + 1),
                v1 = vector&lt;int&gt; (t.size() + 1);

    for (int i = 0; i &lt; v0.size(); ++i) {
        v0[i] = i;
    }

    for (int i = 0; i &lt; s.size(); ++i) {
        v1[0] = i + 1;
        for (int j = 0; j &lt; t.size(); ++j) {
            int cost = (s[i] == t[j] ? 0 : 1);
            v1[j + 1] = min(min(v1[j] + 1, v0[j + 1] + 1), 
                        v0[j] + cost);
        }
        v0 = v1;
    }
    return v1[t.size()];
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        string a,b;
        cin &gt;&gt; a &gt;&gt; b;
        cout &lt;&lt; LevenshteinDistance(a, b) &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/26/edist/</link><guid isPermaLink="false">edcc9410-811a-4155-a85e-0b2331740f17</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 03:46:18 GMT</pubDate></item><item><title><![CDATA[MAXLN]]></title><description><![CDATA[<p>In this problem you will be given a half-circle. The half-circle’s radius is r. You can take any point A on the half-circle and draw 2 lines from the point to the two sides of the diameter(AB and AC). Let the sum of square of one line’s length and the other line’s length is s.</p>

<p><img src="http://code-jedi.chintanghate.me/content/images/2014/11/sE2qJlnf5DUTr7awOFtMOwA-1.png" alt="Illustration"></p>

<p>Like in the figure s=AB^2+AC. And BC=2r.</p>

<p>Now given r you have to find the maximum value of s. That is you have to find point A such that AB^2+AC is maximum.</p>

<h6 id="input">Input:</h6>

<p>First line of the test case will be the number of test case T(1&lt;=T&lt;=1000) . Then T lines follows. On each line you will find a integer number r(1&lt;=r&lt;=1000000); each representing the radius of the half-circle.</p>

<h6 id="output">Output:</h6>

<p>For each input line, print a line containing “Case I: ”, where I is the test case number and the maximum value of s. Print 2 digit after decimal(Errors should be less then .01).</p>

<p>Example</p>

<p>Input: <br>
1 <br>
1</p>

<p>Output: <br>
Case 1: 4.25</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (int t = 1; t &lt;= T; ++t) {
        double n;
        cin &gt;&gt; n;
        cout &lt;&lt; "Case " &lt;&lt; setprecision(2) &lt;&lt; fixed 
             &lt;&lt; t &lt;&lt; ": " &lt;&lt; 4*n*n+0.25 &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/25/maxln/</link><guid isPermaLink="false">888df35d-fbc6-429a-935b-81c2182ab01b</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Tue, 25 Nov 2014 18:10:20 GMT</pubDate></item><item><title><![CDATA[ARITH2]]></title><description><![CDATA[<p>While browsing aimlessly, Peter stumbled upon an old riddle he used to solve on his calculator when he was still young. It was the kind of a riddle where you punch in a bunch of numbers and operators into a simple pocket calculator and then turn it upside down to get the answer:</p>

<p>These come in many different sizes but they are always exactly one foot long. Answer: 103 * 103 * 5.</p>

<p>What are made of ice to keep people warm? Answer: 50 * 40 * 250 + 791.</p>

<p>After a few minutes he found a large amount of such riddles and full of excitement he went to solve them. He turned his computer screen upside down, only to find out that he does not have a reasonable calculator program installed on his computer.</p>

<h6 id="problem">Problem</h6>

<p>You are given multiple sequences of button presses of a simple pocket calculator that consist of digits and arithmetic operators. For each such sequence find the number it would produce on a pocket calculator's display.</p>

<p>Note that the pocket calculator evaluates the operators in the order in which they are given. (i.e., there is no operator precedence.) Assume that the display of the calculator is large enough to show the result, and that its memory is sufficient to store all intermediate results.</p>

<h6 id="input">Input</h6>

<p>The first line of the input file contains an integer T specifying the number of test cases. Each test case is preceded by a blank line.</p>

<p>Each test case represents one sequence of button presses for a pocket calculator. The sequence consists of non-negative integers and arithmetic operators and ends with an equal sign. It may also contain spaces to improve readability.</p>

<p>The operator / represents integer division, rounded down. You may assume that no test case contains division by zero and that in all test cases all intermediate results are non-negative.</p>

<p>Tip: long long int in C/C++, long in Java or int64 in Pascal is enough for this problem.</p>

<h6 id="output">Output</h6>

<p>For each sequence from the input file output the number that would be displayed on the calculator.</p>

<p>Example</p>

<p>Input: <br>
4</p>

<p>1 + 1 * 2 =</p>

<p>29 / 5 =</p>

<p>103 * 103 * 5 =</p>

<p>50 * 40 * 250 + 791 =</p>

<p>Output: <br>
4 <br>
5 <br>
53045 <br>
500791 <br>
Hint</p>

<p>The first test case shows that there is no operator precedence.</p>

<p>The second one shows that integer division always rounds down.</p>

<p>The last two outputs are the answers to the two riddles in the problem statement: "shoes" (53045 upside down), and "igloos"(500791 upside down).</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

using namespace std;

int main() {  
    int  T;
    cin &gt;&gt; T;

    cin.ignore();

    for (;T--;) {
        string S;
        cin.ignore();
        getline(cin, S);
        istringstream iss(S);
        long long n = 0, N = 0;
        char op = '+';
        while(iss &gt;&gt; n) {
            if (op == '+') {
                N += n;
            } else if (op == '-') {
                N -= n;
            } else if (op == '*') {
                N *= n;
            } else if (op == '/') {
                N /= n;
            }
            if ((iss &gt;&gt; op) &amp;&amp; (op == '=')) {
                cout &lt;&lt; N &lt;&lt; "\n";
            }
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/21/arith2/</link><guid isPermaLink="false">f8e3d594-52f1-45d7-9346-ab747ba24411</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 21 Nov 2014 16:14:14 GMT</pubDate></item><item><title><![CDATA[HUBULLU]]></title><description><![CDATA[<p>After duelling in quake (a multiplayer game), Airborne and Pagfloyd decide do test themselves out in another game called Hubulullu. The rules of the game are as follows:</p>

<p>N wooden pieces (marked with numbers 1 to N) are placed in a transparent bottle. On his turn the first player takes out some piece (numbered x) and all the pieces numbered by divisors of x that are present in the transparent bottle. The second player picks another number and removes it and its divisors as well. Play continues in an alternating fashion until all pieces have been removed from the bottle. The player who removes the last piece from the bottle wins the game.</p>

<p>Both players play optimally. Given N (the number of wooden pieces in the transparent bottle initially) and the name of the player who starts the game, determine the winner.</p>

<h6 id="input">Input</h6>

<p>The first line of the input contains an integer t, the number of test cases. t test cases follow.</p>

<p>Each test case consists of a single line containing two integers separated by a single space. The first integer is N (1 &lt;= N &lt;= 2000000000), indicating the number of pieces, and the second integer indicates the player who starts - "0" means Airborne starts the game and "1" means Pagfloyd starts the game (quotes for clarity).</p>

<h6 id="output">Output</h6>

<p>For each test case output one line containing either "Airborne wins." or "Pagfloyd wins."</p>

<p>For each N, it's possible to determine a winner if both players play optimally.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
1 0</p>

<p>Output: <br>
Airborne wins.</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for(;T--;) {
        int N, P;
        cin &gt;&gt; N &gt;&gt; P;
        cout &lt;&lt; (P == 0 ? "Airborne wins." : 
                "Pagfloyd wins.") &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/16/hubullu/</link><guid isPermaLink="false">7b7856a4-6b55-4114-afe8-74756a8fce3e</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 16 Nov 2014 13:57:13 GMT</pubDate></item><item><title><![CDATA[EASYPROB]]></title><description><![CDATA[<h6 id="input">Input</h6>

<p>There's no input.</p>

<h6 id="output">Output</h6>

<p>Output some form of these numbers: 137, 1315, 73, 136, 255, 1384, 16385, one per line in the listed order.</p>

<p>Example</p>

<p>The first two lines of the CORRECT output file are:</p>

<p>137=2(2(2)+2+2(0))+2(2+2(0))+2(0) <br>
1315=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)</p>

<p>The correct output file should contain 7 lines.</p>

<hr>

<h6 id="code">Code</h6>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;

using namespace std;

string expressInPowersOfTwo(unsigned long long n) {  
    string final = "";
    if(n == 2 || n == 0) {
        return final + char('0' + n);
    }
    bitset&lt;64&gt; bitRep(n);
    for (int i = 63; i &gt;= 0; --i) {
        if (bitRep[i]) {
            string ans = (i == 1 ? "2" : 
                         "2(" + expressInPowersOfTwo(i) + ")");
            final += (final == "" ? ans : "+" + ans);
        }
    }
    return final;
}

int main() {  
    unsigned long long n;
    while((cin &gt;&gt; n) &amp;&amp; n != -1) {
        cout &lt;&lt; n &lt;&lt; "=" &lt;&lt; expressInPowersOfTwo(n) &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>

<h6 id="solution">Solution</h6>

<pre><code>137=2(2(2)+2+2(0))+2(2+2(0))+2(0)  
1315=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)  
73=2(2(2)+2)+2(2+2(0))+2(0)  
136=2(2(2)+2+2(0))+2(2+2(0))  
255=2(2(2)+2+2(0))+2(2(2)+2)+2(2(2)+2(0))+2(2(2))+2(2+2(0))+2(2)+2+2(0)  
1384=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2)+2(2(2)+2(0))+2(2+2(0))  
16385=2(2(2+2(0))+2(2)+2)+2(0)
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/16/easyprob/</link><guid isPermaLink="false">1a8dd66a-d626-4e46-ab34-f2226fda313e</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 16 Nov 2014 13:17:14 GMT</pubDate></item><item><title><![CDATA[BEENUMS]]></title><description><![CDATA[<p>A beehive is an enclosed structure in which some honey bee species live and raise their young. In this problem we consider a two-dimensional sketch of the beehives. Each beehive is composed of a certain number of cells, where each cell is a regular hexagon. Each cell may have some neighbors, which are other cells that share a side with that cell. A cell with exactly 6 neighbors is an internal cell, while a cell with fewer neighbors is an external one. Notice that an external cell can always be changed to internal by adding some neighbor cells.</p>

<p>We are interested in a particular class of beehives. This class of valid beehives is defined recursively as follows: a) a single cell is a valid beehive; and b) given a valid beehive B, if we add the minimum number of cells such that each external cell of B becomes an internal cell, the result is a valid beehive.</p>

<p>The number of cells in a valid beehive is called a beehive number. Given an integer N, you must decide whether it is a beehive number.</p>

<h6 id="input">Input</h6>

<p>Each test case is described using a single line. The line contains an integer N (1 ≤ N ≤ 10<sup>9</sup> ). The end of input is indicated with a line containing a single −1.</p>

<h6 id="output">Output</h6>

<p>For each test case, output a single line containing an uppercase “Y” if N is a beehive number, or an uppercase “N” otherwise.</p>

<p>Example</p>

<p>Input: <br>
43 <br>
1 <br>
7 <br>
19 <br>
15 <br>
-1</p>

<p>Output: <br>
N <br>
Y <br>
Y <br>
Y <br>
N</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {  
    int N;
    while ((cin &gt;&gt; N) &amp;&amp; N != -1) {
        --N;
        if (N % 6 != 0) {
            cout &lt;&lt; "N\n";
        } else {
            N /= 3;
            double x = (-1.0 + sqrt(1 + 4*N)) / 2.0;
            if(ceil(x) == floor(x)) {
                cout &lt;&lt; "Y\n";
            } else {
                cout &lt;&lt; "N\n";
            }
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/16/beenums/</link><guid isPermaLink="false">da0aee15-e541-4347-adea-57756f9a67b2</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 16 Nov 2014 11:42:19 GMT</pubDate></item><item><title><![CDATA[INVCNT]]></title><description><![CDATA[<p>Let A[0...n - 1] be an array of n distinct positive integers. If i &lt; j and A[i] > A[j] then the pair (i, j) is called an inversion of A. Given n and an array A your task is to find the number of inversions of A.</p>

<h6 id="input">Input</h6>

<p>The first line contains t, the number of testcases followed by a blank space. Each of the t tests start with a number n (n &lt;= 200000). Then n + 1 lines follow. In the ith line a number A[i - 1] is given (A[i - 1] &lt;= 10^7). The (n + 1)th line is a blank space.</p>

<h6 id="output">Output</h6>

<p>For every test output one line giving the number of inversions of A.</p>

<p>Example</p>

<p>Input: <br>
2</p>

<p>3 <br>
3 <br>
1 <br>
2</p>

<p>5 <br>
2 <br>
3 <br>
8 <br>
6 <br>
1</p>

<p>Output: <br>
2 <br>
5</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;

using namespace std;

unsigned long long counter;

void merge(vector&lt;int&gt; &amp;A, int p, int q, int r) {  
    int n1 = q - p + 1,
        n2 = r - q;
    vector&lt;int&gt; L(n1 + 1), R(n2 + 1);
    for (int i = 0; i &lt; n1; ++i) {
        L[i] = A[p + i];
    }
    for (int i = 0; i &lt; n2; ++i) {
        R[i] = A[q + i + 1];
    }
    L[n1] = R[n2] = INT_MAX;
    int i = 0,
        j = 0;
    for (int k = p; k &lt;= r; ++k) {
        if (L[i] &lt;= R[j] &amp;&amp; L[i] != INT_MAX) {
            A[k] = L[i++];
        } else {
            A[k] = R[j++];
            counter += n1 - i;
        }
    }
    return;
}

void mergeSort(vector&lt;int&gt; &amp;A, int p, int r) {  
    if (p &lt; r) {
        int q = (p + r) / 2;
        mergeSort(A, p, q);
        mergeSort(A, q + 1, r);
        merge(A, p, q, r);
    }
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int N;
        cin &gt;&gt; N;
        vector&lt;int&gt; A(N);
        for (int i = 0; i &lt; N; ++i) {
            cin &gt;&gt; A[i];
        }
        counter = 0;
        mergeSort(A, 0, N - 1);
        cout &lt;&lt; counter &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/16/invcnt/</link><guid isPermaLink="false">77cfe6b0-2afd-410a-a9ee-4290b2d7bc20</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 16 Nov 2014 10:45:16 GMT</pubDate></item><item><title><![CDATA[OFFSIDE]]></title><description><![CDATA[<p>Hemisphere Network is the largest television network in Tumbolia, a small country located east of South America (or south of East America). The most popular sport in Tumbolia, unsurprisingly, is soccer; many games are broadcast every week in Tumbolia.</p>

<p>Hemisphere Network receives many requests to replay dubious plays; usually, these happen when a player is deemed to be offside by the referee. An attacking player is offside if he is nearer to his opponents’ goal line than the second last opponent. A player is not offside if</p>

<ul>
<li>he is level with the second last opponent or</li>
<li>he is level with the last two opponents.</li>
</ul>

<p>Through the use of computer graphics technology, Hemisphere Network can take an image of the field and determine the distances of the players to the defending team’s goal line, but they still need a program that, given these distances, decides whether a player is offside.</p>

<h6 id="input">Input</h6>

<p>The input file contains several test cases. The first line of each test case contains two integers A and D separated by a single space indicating, respectively, the number of attacking and defending players involved in the play (2 &lt;= A,D &lt;= 11). The next line contains A integers Bi separated by single spaces, indicating the distances of the attacking players to the goal line (1 &lt;= Bi &lt;= 10<sup>4</sup>). The next line contains D integers Cj separated by single spaces, indicating the distances of the defending players to the goal line (1 &lt;= Cj &lt;= 10<sup>4</sup>). The end of input is indicated by A = D = 0.</p>

<h6 id="output">Output</h6>

<p>For each test case in the input print a line containing a single character: “Y” (uppercase) if there is an attacking player offside, and “N” (uppercase) otherwise.</p>

<p>Example</p>

<p>Input: <br>
2 3 <br>
500 700 <br>
700 500 500 <br>
2 2 <br>
200 400 <br>
200 1000 <br>
3 4 <br>
530 510 490 <br>
480 470 50 310 <br>
0 0</p>

<p>Output: <br>
N <br>
Y <br>
N</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {  
    int A, D;
    while ((cin &gt;&gt; A &gt;&gt; D) &amp;&amp; A != 0 &amp;&amp; D != 0) {
        vector&lt;int&gt; attackers(A),
                    defenders(D);
        for (int i = 0; i &lt; A; ++i) {
            cin &gt;&gt; attackers[i];
        }
        for (int i = 0; i &lt; D; ++i) {
            cin &gt;&gt; defenders[i];
        }
        sort(defenders.begin(), defenders.end());
        bool flag = false;
        for (int i = 0; i &lt; A; ++i) {
            if (attackers[i] &lt; defenders[1]) {
                flag = true;
                break;
            }
        }
        if (flag) {
            cout &lt;&lt; "Y\n";
        } else {
            cout &lt;&lt; "N\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/15/offside/</link><guid isPermaLink="false">bcad7e40-9e78-4b3e-8d5f-6ca8ec927d03</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 15 Nov 2014 14:13:43 GMT</pubDate></item></channel></rss>