<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[SPOJ - Code Jedi]]></title><description><![CDATA[Code, algorithms and design.]]></description><link>http://code-jedi.chintanghate.me/</link><generator>Ghost 0.5</generator><lastBuildDate>Sun, 16 Nov 2014 15:06:01 GMT</lastBuildDate><atom:link href="http://code-jedi.chintanghate.me/tag/spoj/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[HUBULLU]]></title><description><![CDATA[<p>After duelling in quake (a multiplayer game), Airborne and Pagfloyd decide do test themselves out in another game called Hubulullu. The rules of the game are as follows:</p>

<p>N wooden pieces (marked with numbers 1 to N) are placed in a transparent bottle. On his turn the first player takes out some piece (numbered x) and all the pieces numbered by divisors of x that are present in the transparent bottle. The second player picks another number and removes it and its divisors as well. Play continues in an alternating fashion until all pieces have been removed from the bottle. The player who removes the last piece from the bottle wins the game.</p>

<p>Both players play optimally. Given N (the number of wooden pieces in the transparent bottle initially) and the name of the player who starts the game, determine the winner.</p>

<h6 id="input">Input</h6>

<p>The first line of the input contains an integer t, the number of test cases. t test cases follow.</p>

<p>Each test case consists of a single line containing two integers separated by a single space. The first integer is N (1 &lt;= N &lt;= 2000000000), indicating the number of pieces, and the second integer indicates the player who starts - "0" means Airborne starts the game and "1" means Pagfloyd starts the game (quotes for clarity).</p>

<h6 id="output">Output</h6>

<p>For each test case output one line containing either "Airborne wins." or "Pagfloyd wins."</p>

<p>For each N, it's possible to determine a winner if both players play optimally.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
1 0</p>

<p>Output: <br>
Airborne wins.</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for(;T--;) {
        int N, P;
        cin &gt;&gt; N &gt;&gt; P;
        cout &lt;&lt; (P == 0 ? "Airborne wins." : 
                "Pagfloyd wins.") &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/16/hubullu/</link><guid isPermaLink="false">7b7856a4-6b55-4114-afe8-74756a8fce3e</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 16 Nov 2014 13:57:13 GMT</pubDate></item><item><title><![CDATA[EASYPROB]]></title><description><![CDATA[<h6 id="input">Input</h6>

<p>There's no input.</p>

<h6 id="output">Output</h6>

<p>Output some form of these numbers: 137, 1315, 73, 136, 255, 1384, 16385, one per line in the listed order.</p>

<p>Example</p>

<p>The first two lines of the CORRECT output file are:</p>

<p>137=2(2(2)+2+2(0))+2(2+2(0))+2(0) <br>
1315=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)</p>

<p>The correct output file should contain 7 lines.</p>

<hr>

<h6 id="code">Code</h6>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;bitset&gt;

using namespace std;

string expressInPowersOfTwo(unsigned long long n) {  
    string final = "";
    if(n == 2 || n == 0) {
        return final + char('0' + n);
    }
    bitset&lt;64&gt; bitRep(n);
    for (int i = 63; i &gt;= 0; --i) {
        if (bitRep[i]) {
            string ans = (i == 1 ? "2" : 
                         "2(" + expressInPowersOfTwo(i) + ")");
            final += (final == "" ? ans : "+" + ans);
        }
    }
    return final;
}

int main() {  
    unsigned long long n;
    while((cin &gt;&gt; n) &amp;&amp; n != -1) {
        cout &lt;&lt; n &lt;&lt; "=" &lt;&lt; expressInPowersOfTwo(n) &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>

<h6 id="solution">Solution</h6>

<pre><code>137=2(2(2)+2+2(0))+2(2+2(0))+2(0)  
1315=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)  
73=2(2(2)+2)+2(2+2(0))+2(0)  
136=2(2(2)+2+2(0))+2(2+2(0))  
255=2(2(2)+2+2(0))+2(2(2)+2)+2(2(2)+2(0))+2(2(2))+2(2+2(0))+2(2)+2+2(0)  
1384=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2)+2(2(2)+2(0))+2(2+2(0))  
16385=2(2(2+2(0))+2(2)+2)+2(0)
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/16/easyprob/</link><guid isPermaLink="false">1a8dd66a-d626-4e46-ab34-f2226fda313e</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 16 Nov 2014 13:17:14 GMT</pubDate></item><item><title><![CDATA[BEENUMS]]></title><description><![CDATA[<p>A beehive is an enclosed structure in which some honey bee species live and raise their young. In this problem we consider a two-dimensional sketch of the beehives. Each beehive is composed of a certain number of cells, where each cell is a regular hexagon. Each cell may have some neighbors, which are other cells that share a side with that cell. A cell with exactly 6 neighbors is an internal cell, while a cell with fewer neighbors is an external one. Notice that an external cell can always be changed to internal by adding some neighbor cells.</p>

<p>We are interested in a particular class of beehives. This class of valid beehives is defined recursively as follows: a) a single cell is a valid beehive; and b) given a valid beehive B, if we add the minimum number of cells such that each external cell of B becomes an internal cell, the result is a valid beehive.</p>

<p>The number of cells in a valid beehive is called a beehive number. Given an integer N, you must decide whether it is a beehive number.</p>

<h6 id="input">Input</h6>

<p>Each test case is described using a single line. The line contains an integer N (1 ≤ N ≤ 10<sup>9</sup> ). The end of input is indicated with a line containing a single −1.</p>

<h6 id="output">Output</h6>

<p>For each test case, output a single line containing an uppercase “Y” if N is a beehive number, or an uppercase “N” otherwise.</p>

<p>Example</p>

<p>Input: <br>
43 <br>
1 <br>
7 <br>
19 <br>
15 <br>
-1</p>

<p>Output: <br>
N <br>
Y <br>
Y <br>
Y <br>
N</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {  
    int N;
    while ((cin &gt;&gt; N) &amp;&amp; N != -1) {
        --N;
        if (N % 6 != 0) {
            cout &lt;&lt; "N\n";
        } else {
            N /= 3;
            double x = (-1.0 + sqrt(1 + 4*N)) / 2.0;
            if(ceil(x) == floor(x)) {
                cout &lt;&lt; "Y\n";
            } else {
                cout &lt;&lt; "N\n";
            }
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/16/beenums/</link><guid isPermaLink="false">da0aee15-e541-4347-adea-57756f9a67b2</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 16 Nov 2014 11:42:19 GMT</pubDate></item><item><title><![CDATA[INVCNT]]></title><description><![CDATA[<p>Let A[0...n - 1] be an array of n distinct positive integers. If i &lt; j and A[i] > A[j] then the pair (i, j) is called an inversion of A. Given n and an array A your task is to find the number of inversions of A.</p>

<h6 id="input">Input</h6>

<p>The first line contains t, the number of testcases followed by a blank space. Each of the t tests start with a number n (n &lt;= 200000). Then n + 1 lines follow. In the ith line a number A[i - 1] is given (A[i - 1] &lt;= 10^7). The (n + 1)th line is a blank space.</p>

<h6 id="output">Output</h6>

<p>For every test output one line giving the number of inversions of A.</p>

<p>Example</p>

<p>Input: <br>
2</p>

<p>3 <br>
3 <br>
1 <br>
2</p>

<p>5 <br>
2 <br>
3 <br>
8 <br>
6 <br>
1</p>

<p>Output: <br>
2 <br>
5</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;

using namespace std;

unsigned long long counter;

void merge(vector&lt;int&gt; &amp;A, int p, int q, int r) {  
    int n1 = q - p + 1,
        n2 = r - q;
    vector&lt;int&gt; L(n1 + 1), R(n2 + 1);
    for (int i = 0; i &lt; n1; ++i) {
        L[i] = A[p + i];
    }
    for (int i = 0; i &lt; n2; ++i) {
        R[i] = A[q + i + 1];
    }
    L[n1] = R[n2] = INT_MAX;
    int i = 0,
        j = 0;
    for (int k = p; k &lt;= r; ++k) {
        if (L[i] &lt;= R[j] &amp;&amp; L[i] != INT_MAX) {
            A[k] = L[i++];
        } else {
            A[k] = R[j++];
            counter += n1 - i;
        }
    }
    return;
}

void mergeSort(vector&lt;int&gt; &amp;A, int p, int r) {  
    if (p &lt; r) {
        int q = (p + r) / 2;
        mergeSort(A, p, q);
        mergeSort(A, q + 1, r);
        merge(A, p, q, r);
    }
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int N;
        cin &gt;&gt; N;
        vector&lt;int&gt; A(N);
        for (int i = 0; i &lt; N; ++i) {
            cin &gt;&gt; A[i];
        }
        counter = 0;
        mergeSort(A, 0, N - 1);
        cout &lt;&lt; counter &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/16/invcnt/</link><guid isPermaLink="false">77cfe6b0-2afd-410a-a9ee-4290b2d7bc20</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 16 Nov 2014 10:45:16 GMT</pubDate></item><item><title><![CDATA[OFFSIDE]]></title><description><![CDATA[<p>Hemisphere Network is the largest television network in Tumbolia, a small country located east of South America (or south of East America). The most popular sport in Tumbolia, unsurprisingly, is soccer; many games are broadcast every week in Tumbolia.</p>

<p>Hemisphere Network receives many requests to replay dubious plays; usually, these happen when a player is deemed to be offside by the referee. An attacking player is offside if he is nearer to his opponents’ goal line than the second last opponent. A player is not offside if</p>

<ul>
<li>he is level with the second last opponent or</li>
<li>he is level with the last two opponents.</li>
</ul>

<p>Through the use of computer graphics technology, Hemisphere Network can take an image of the field and determine the distances of the players to the defending team’s goal line, but they still need a program that, given these distances, decides whether a player is offside.</p>

<h6 id="input">Input</h6>

<p>The input file contains several test cases. The first line of each test case contains two integers A and D separated by a single space indicating, respectively, the number of attacking and defending players involved in the play (2 &lt;= A,D &lt;= 11). The next line contains A integers Bi separated by single spaces, indicating the distances of the attacking players to the goal line (1 &lt;= Bi &lt;= 10<sup>4</sup>). The next line contains D integers Cj separated by single spaces, indicating the distances of the defending players to the goal line (1 &lt;= Cj &lt;= 10<sup>4</sup>). The end of input is indicated by A = D = 0.</p>

<h6 id="output">Output</h6>

<p>For each test case in the input print a line containing a single character: “Y” (uppercase) if there is an attacking player offside, and “N” (uppercase) otherwise.</p>

<p>Example</p>

<p>Input: <br>
2 3 <br>
500 700 <br>
700 500 500 <br>
2 2 <br>
200 400 <br>
200 1000 <br>
3 4 <br>
530 510 490 <br>
480 470 50 310 <br>
0 0</p>

<p>Output: <br>
N <br>
Y <br>
N</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {  
    int A, D;
    while ((cin &gt;&gt; A &gt;&gt; D) &amp;&amp; A != 0 &amp;&amp; D != 0) {
        vector&lt;int&gt; attackers(A),
                    defenders(D);
        for (int i = 0; i &lt; A; ++i) {
            cin &gt;&gt; attackers[i];
        }
        for (int i = 0; i &lt; D; ++i) {
            cin &gt;&gt; defenders[i];
        }
        sort(defenders.begin(), defenders.end());
        bool flag = false;
        for (int i = 0; i &lt; A; ++i) {
            if (attackers[i] &lt; defenders[1]) {
                flag = true;
                break;
            }
        }
        if (flag) {
            cout &lt;&lt; "Y\n";
        } else {
            cout &lt;&lt; "N\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/15/offside/</link><guid isPermaLink="false">bcad7e40-9e78-4b3e-8d5f-6ca8ec927d03</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 15 Nov 2014 14:13:43 GMT</pubDate></item><item><title><![CDATA[BISHOPS]]></title><description><![CDATA[<p>Yesterday was Sam's birthday. The most interesting gift was definitely the chessboard. Sam quickly learned the rules of chess and defeated his father, all his friends, his little sister, and now no one wants to play with him any more. </p>

<p>So he decided to play with another birthday gift – a Book of Math Problems for Young Mathematicians. He opened the book somewhere in the middle and read the following problem: "How many knights can be placed on a chessboard without threatening each other?" After a while he realized that this was trivial and moved on to the next problem: "How many bishops can be placed on a chessboard without threatening each other?". Sam is in trouble here. He is not able to solve this problem and needs your help.</p>

<p>Sam's chessboard has size N x N. A bishop can move to any distance in any of the four diagonal directions. A bishop threatens another bishop if it can move to the other bishop's position. Your task is to compute the maximum number of bishops that can be placed on a chessboard in such a way that no two bishops threaten each other. </p>

<h6 id="input">Input</h6>

<p>The input file consists of several lines. The line number i contains a single number N representing the size of the i-th chessboard. [N &lt;= 10^100]</p>

<h6 id="output">Output</h6>

<p>The output file should contain the same number of lines as the input file. The i-th line should contain one number – the maximum number of bishops that can be placed on i-th chessboard without threatening each other.</p>

<p>Example</p>

<p>Input: <br>
2 <br>
3</p>

<p>Output: <br>
2 <br>
4</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int mod(int a, int b) {  
    return (a % b &lt; 0 ? a % b + b : a % b);
}

void vectorMultiplication(vector&lt;int&gt; &amp;N, int n) {  
    int carry = 0;
    for (int i = 0; i &lt; N.size(); ++i) {
        N[i] *= n;
        N[i] += carry;
        carry = N[i] / 10;
        N[i] %= 10;
    }
    return;
}

void vectorSubstraction(vector&lt;int&gt; &amp;N, int n) {  
    N[0] -= n;
    for (int i = 0; i &lt; N.size() - 1; ++i) {
        if (N[i] &lt; 0) {
            N[i] = mod(N[i], 10);
            --N[i + 1];
        }
    }
    return;
}

string bishops(string S) {  
    vector&lt;int&gt; N(102,0);
    for (int i = 0; i &lt; S.size(); ++i) {
        N[i] = S[S.size() - 1 - i] - '0';
    }
    vectorMultiplication(N, 2);
    vectorSubstraction(N, 2);
    string ans = "";
    bool flag = false;
    for (int i = 101; i &gt;= 0; --i) {
        if (!flag &amp;&amp; N[i] == 0){
            continue;
        } else {
            flag = true;
            ans += char(N[i] + '0');
        }
    }
    return ans;
}

int main() {  
    string S;
    while(cin &gt;&gt; S) {
        if (S == "0" || S == "1") {
            cout &lt;&lt; S &lt;&lt; "\n";
        } else {
            cout &lt;&lt; bishops(S) &lt;&lt; "\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/15/bishops/</link><guid isPermaLink="false">e0cb9f41-0068-48ae-92af-ebbc85b5f02c</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 15 Nov 2014 13:13:23 GMT</pubDate></item><item><title><![CDATA[NGM]]></title><description><![CDATA[<p>Nikifor and Trofim play the following game: they write some integer smaller then 2000000000 and take turns one after another. Nikifor is the first to make a move. The turn is made by the following rule: from the written integer any non-zero digit is subtracted, and the new integer replaces the old one on the desk. For example for integer 40534, the next move can be: 40530, 40531 or 40529. The winner is the player who writes zero on the desk.</p>

<p>Write a program to decide who will win if both players do their best.</p>

<h6 id="input">Input</h6>

<p>The input contains the integer from which the game is started.</p>

<h6 id="output">Output</h6>

<p>In the first line you must write 1 if Nikifor wins and 2 otherwise. If Nikifor wins then in the second line you must output the move in the first turn which guarantees victory for him. If there are many such moves then output any of them.</p>

<p>Example</p>

<p>Input: <br>
14</p>

<p>Output: <br>
1 <br>
4</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;

using namespace std;

int main() {  
    long long T;
    cin &gt;&gt; T;
    if (T % 10 == 0) {
        cout &lt;&lt; "2\n";
    } else {
        cout &lt;&lt; "1\n" &lt;&lt; T % 10 &lt;&lt; "\n";
    }
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/15/ngm/</link><guid isPermaLink="false">b6635f7b-a9b2-4298-9ac4-7404ac43be96</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 15 Nov 2014 12:29:56 GMT</pubDate></item><item><title><![CDATA[GIRLSNBS]]></title><description><![CDATA[<p>There are G girl students and B boy students in a class that is about to graduate. You <br>
need to arrange them in a single row for the graduation. To give a better impression of <br>
diversity, you want to avoid having too many girls or too many boys seating consecutively. <br>
You decided to arrange the students in order to minimize the gender regularity. The <br>
gender regularity of an arrangement is the maximum number of students of the same <br>
gender (all girls or all boys) that appear consecutively. <br>
Given G and B, calculate the minimum gender regularity among all possible arrange- <br>
ments.</p>

<h6 id="input">Input</h6>

<p>Each test case is described using a single line. The line contains two integers G and B <br>
representing the number of girls and boys in the class, respectively (0 ≤ G, B ≤ 1000). <br>
The end of input is indicated with a line containing the number −1 twice.</p>

<h6 id="output">Output</h6>

<p>For each test case, output a single line with a single integer representing the minimum <br>
gender regularity that an arrangement of G girls and B boys can have.</p>

<p>Example</p>

<p>Input: <br>
10 10 <br>
5 1 <br>
0 1000 <br>
-1 -1</p>

<p>Output: <br>
1 <br>
3 <br>
1000</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {  
    int G, B;
    while ((cin &gt;&gt; G &gt;&gt; B) &amp;&amp; G != -1 &amp;&amp; B != -1) {
        if (G == 0 &amp;&amp; B == 0) {
            cout &lt;&lt; "0\n";
        } else {
            double GinB = ceil(G / (B + 1.0)),
                   BinG = ceil(B / (G + 1.0));
            cout &lt;&lt; max(GinB, BinG) &lt;&lt; "\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/15/girlsnbs/</link><guid isPermaLink="false">63d53c0d-bd89-4771-a3f3-d7e532ef2179</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 15 Nov 2014 11:37:30 GMT</pubDate></item><item><title><![CDATA[AP2]]></title><description><![CDATA[<p>Arithmatic and geometric Progressions are 2 of the well known progressions in maths.</p>

<p>Arithmatic progression(AP) is a set in which the difference between 2 numbers in constant. for eg, 1,3,5,7,9 .... In this series the difference between 2 numbers is 2.</p>

<p>The task here is very simple indeed.</p>

<p>You will be given the 3rd term , 3rd last term and the sum of the series. You need print length of the series &amp; the series.</p>

<h6 id="input">Input</h6>

<p>First line will contain a number indicating the number of test cases.</p>

<p>Each of the following t lines will have 3 number '3term' ,'3Lastterm' and 'sum'</p>

<p>3term  - is the 3rd term in of the series and</p>

<p>3Lastterm  - is the 3rd term in of the series and</p>

<p>sum - is the sum of the series.</p>

<h6 id="output">Output</h6>

<p>For each input of the test case, you need to print 2 lines.</p>

<p>fist line should have 1 value- number of terms in the series.</p>

<p>2nd line of the output should print the series numbers separated by single space.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
3 8 55</p>

<p>Output: <br>
10 <br>
1 2 3 4 5 6 7 8 9 10</p>

<p>NOTE - In all the test cases all the series elements are positive integers. <br>
The series will have at least 7 elements. <br>
number of test cases &lt;=100. <br>
All the numbers will fit in 64 bits(long long in C)</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;

    for(;T--;) {
        long long a3, an_2, Sn;
        cin &gt;&gt; a3 &gt;&gt; an_2 &gt;&gt; Sn;

        long long n = (2 * Sn) / (a3 + an_2),
                  d = (an_2 - a3) / (n - 5),
                  a = an_2 + 3 * d - n * d;

        cout &lt;&lt; n &lt;&lt; "\n";
        for (int i = 0; i &lt; n; ++i) {
            cout &lt;&lt; a + i * d &lt;&lt; " ";
        }
        cout &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/15/ap2/</link><guid isPermaLink="false">33b28c2c-309d-4565-b80e-983dae151ffb</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 15 Nov 2014 11:17:04 GMT</pubDate></item><item><title><![CDATA[PT07Y]]></title><description><![CDATA[<p>You are given an unweighted, undirected graph. Write a program to check if it's a tree topology.</p>

<h6 id="input">Input</h6>

<p>The first line of the input file contains two integers N and M --- number of nodes and number of edges in the graph (0 &lt; N &lt;= 10000, 0 &lt;= M &lt;= 20000). Next M lines contain M edges of that graph --- Each line contains a pair (u, v) means there is an edge between node u and node v (1 &lt;= u,v &lt;= N).</p>

<h6 id="output">Output</h6>

<p>Print YES if the given graph is a tree, otherwise print NO.</p>

<p>Example</p>

<p>Input: <br>
3 2 <br>
1 2 <br>
2 3</p>

<p>Output: <br>
YES</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int root(int a, vector&lt;int&gt; &amp;id) {  
    while (a != id[a]) {
        id[a] = id[id[a]];
        a = id[a];
    }
    return a;
}

bool isConnected(int a, int b, vector&lt;int&gt; &amp;id) {  
    return (root(a, id) == root(b, id));
}

void Union(int a, int b, vector&lt;int&gt; &amp;id, vector&lt;int&gt; &amp;size) {  
    int roota = root(a,id);
    int rootb = root(b,id);
    if (size[roota] &lt; size[rootb]) {
        id[roota] = rootb;
        size[rootb] += size[roota];
    } else {
        id[rootb] = roota;
        size[roota] += size[rootb];
    }
    return;
}

bool isATree(int N, vector&lt;pair&lt;int, int&gt; &gt; edges) {  
    vector&lt;int&gt; id(N),
                sz(N,1);
    for (int i = 0; i &lt; N; ++i) {
        id[i] = i;
    }
    for (int i = 0; i &lt; edges.size(); ++i) {
        if (isConnected(edges[i].first, edges[i].second, id)) {
            return false;
        } else {
            Union(edges[i].first, edges[i].second, id, sz);
        }
    }
    return true;
}

int main() {  
    int N, M;
    cin &gt;&gt; N &gt;&gt; M;
    vector&lt;pair&lt;int, int&gt; &gt; edges(M);
    for (int i = 0; i &lt; M; ++i) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        --a, --b;
        edges[i] = make_pair(a,b);
    }

    if (isATree(N, edges)) {
        cout &lt;&lt; "YES\n";
    } else {
        cout &lt;&lt; "NO\n";
    }

    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/15/pt07y/</link><guid isPermaLink="false">9443e4d8-7ed7-4a59-b088-880dde6a4902</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 15 Nov 2014 10:31:16 GMT</pubDate></item><item><title><![CDATA[STPAR]]></title><description><![CDATA[<p>For sure, the love mobiles will roll again on this summer's street parade. Each year, the organisers decide on a fixed order for the decorated trucks. Experience taught them to keep free a side street to be able to bring the trucks into order. </p>

<p>The side street is so narrow that no two cars can pass each other. Thus, the love mobile that enters the side street last must necessarily leave the side street first. Because the trucks and the ravers move up closely, a truck cannot drive back and re-enter the side street or the approach street. </p>

<p>You are given the order in which the love mobiles arrive. Write a program that decides if the love mobiles can be brought into the order that the organisers want them to be.</p>

<h6 id="input">Input</h6>

<p>There are several test cases. The first line of each test case contains a single number n, the number of love mobiles. The second line contains the numbers 1 to n in an arbitrary order. All the numbers are separated by single spaces. These numbers indicate the order in which the trucks arrive in the approach street. No more than 1000 love mobiles participate in the street parade. Input ends with number 0.</p>

<h6 id="output">Output</h6>

<p>For each test case your program has to output a line containing a single word yes if the love mobiles can be re-ordered with the help of the side street, and a single word no in the opposite case.</p>

<p>Example</p>

<p>Input: <br>
5 <br>
5 1 2 4 3 <br>
0</p>

<p>Output: <br>
yes</p>

<h6 id="illustration">Illustration</h6>

<p>The sample input reflects the following situation: <br>
<img src="http://code-jedi.chintanghate.me/content/images/2014/11/pomyk-parade1.gif" alt="Illustration0">
The five trucks can be re-ordered in the following way: <br>
<img src="http://code-jedi.chintanghate.me/content/images/2014/11/pomyk-parade2.gif" alt="Illustration1">
<img src="http://code-jedi.chintanghate.me/content/images/2014/11/pomyk-parade3.gif" alt="Illustration2">
<img src="http://code-jedi.chintanghate.me/content/images/2014/11/pomyk-parade4.gif" alt="Illustration3">
<img src="http://code-jedi.chintanghate.me/content/images/2014/11/pomyk-parade5.gif" alt="Illustration4">
<img src="http://code-jedi.chintanghate.me/content/images/2014/11/pomyk-parade6.gif" alt="Illustration5"></p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;deque&gt;

using namespace std;

int main() {  
    int T;
    while ((cin &gt;&gt; T) &amp;&amp; T != 0) {
        deque&lt;int&gt; Q;
        for (int i = 0; i &lt; T; ++i) {
            int x;
            cin &gt;&gt; x;
            Q.push_back(x);
        }

        int vehicle = 1;
        stack&lt;int&gt; S;
        while (!Q.empty() || !S.empty()) {
            if (!S.empty() &amp;&amp; S.top() == vehicle) {
                S.pop();
                ++vehicle;
            } else if (!Q.empty() &amp;&amp; Q.front() == vehicle) {
                Q.pop_front();
                ++vehicle;
            } else if (!Q.empty()) {
                S.push(Q.front());
                Q.pop_front();
            } else if (!S.empty()) {
                S.pop();
            }
        }
        if (vehicle == T + 1) {
            cout &lt;&lt; "yes\n";
        } else {
            cout &lt;&lt; "no\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/13/stpar/</link><guid isPermaLink="false">f7029305-37d1-472a-a96d-21655dfd9245</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Thu, 13 Nov 2014 17:52:08 GMT</pubDate></item><item><title><![CDATA[FENCE1]]></title><description><![CDATA[<p>There is a wall in your backyard. It is so long that you can’t see its endpoints. You want to build a fence of length L such that the area enclosed between the wall and the fence is maximized. The fence can be of arbitrary shape, but only its two endpoints may touch the wall.</p>

<h6 id="input">Input</h6>

<p>The input consists of several test cases.</p>

<p>For every test case, there is only one integer L (1&lt;=L&lt;=100), indicating the length of the fence.</p>

<p>The input ends with L=0.</p>

<h6 id="output">Output</h6>

<p>For each test case, output one line containing the largest area. Your answer should be rounded to 2 digits after the decimal point.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
0</p>

<p>Output: <br>
0.16</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

int main() {  
    double PI = 3.14159265358979323846;
    double L;
    while((cin &gt;&gt; L) &amp;&amp; L != 0) {
        cout &lt;&lt; setprecision(2) &lt;&lt; fixed 
             &lt;&lt; L*L/2.0/PI &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/13/fence1/</link><guid isPermaLink="false">9af4f18a-8fef-4eb0-bb0b-a9b2e36f7b47</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Thu, 13 Nov 2014 17:42:29 GMT</pubDate></item><item><title><![CDATA[WILLITST]]></title><description><![CDATA[<p>When Bob was in library in University of Warsaw he saw on one of facades caption :"Will it ever stop?" and below some mysterious code:  </p>

<pre><code class="prettyprint">while n &gt; 1  
  if n mod 2 = 0 then
    n:=n/2
  else
    n:=3*n+3
</code></pre>

<p>Help him finding it out !</p>

<h6 id="input">Input</h6>

<p>In first line one number n&lt;=10^14.</p>

<h6 id="output">Output</h6>

<p>Print "TAK" if program will stop, otherwise print "NIE"</p>

<p>Example</p>

<p>Input: <br>
4</p>

<p>Output: <br>
TAK</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;

using namespace std;

int main() {  
    unsigned long long N;
    cin &gt;&gt; N;

    unsigned long long i = 1;
    while (i &lt; N) {
        i *= 2;
    }
    if (i == N) {
        cout &lt;&lt; "TAK\n";
    } else {
        cout &lt;&lt; "NIE\n";
    }

    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/07/willitst/</link><guid isPermaLink="false">8367d7e9-3ece-4651-bcae-8f74c68912d8</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 07 Nov 2014 17:55:15 GMT</pubDate></item><item><title><![CDATA[ARMY]]></title><description><![CDATA[<p>The next MechaGodzilla invasion is on its way to Earth. And once again, Earth will be the battleground for an epic war.</p>

<p>MechaGodzilla's army consists of many nasty alien monsters, such as Space Godzilla, King Gidorah, and MechaGodzilla herself.</p>

<p>To stop them and defend Earth, Godzilla and her friends are preparing for the battle.</p>

<h6 id="problem">Problem</h6>

<p>Each army consists of many different monsters. Each monster has a strength that can be described by a positive integer. (The larger the value, the stronger the monster.)</p>

<p>The war will consist of a series of battles. In each battle, the weakest of all the monsters that are still alive is killed.</p>

<p>If there are several weakest monsters, but all of them in the same army, one of them is killed at random. If both armies have at least one of the weakest monsters, a random weakest monster of MechaGodzilla's army is killed.</p>

<p>The war is over if in one of the armies all monsters are dead. The dead army lost, the other one won.</p>

<p>You are given the strengths of all the monsters. Find out who wins the war.</p>

<h6 id="input">Input</h6>

<p>The first line of the input file contains an integer T specifying the number of test cases. Each test case is preceded by a blank line.</p>

<p>Each test case starts with line containing two positive integers NG and NM – the number of monsters in Godzilla's and in MechaGodzilla's army. Two lines follow. The first one contains NG positive integers – the strengths of the monsters in Godzilla's army. Similarly, the second one contains NM positive integers – the strengths of the monsters in MechaGodzilla's army.</p>

<h6 id="output">Output</h6>

<p>For each test case, output a single line with a string that describes the outcome of the battle.</p>

<p>If it is sure that Godzilla's army wins, output the string "Godzilla".</p>

<p>If it is sure that MechaGodzilla's army wins, output the string "MechaGodzilla".</p>

<p>Otherwise, output the string "uncertain".</p>

<p>Example</p>

<p>Input: <br>
2</p>

<p>1 1 <br>
1 <br>
1</p>

<p>3 2 <br>
1 3 2 <br>
5 5</p>

<p>Output: <br>
Godzilla <br>
MechaGodzilla</p>

<h6 id="hint">Hint</h6>

<p>In the first test case, there are only two monsters, and they are equally strong. In this situation, MechaGodzilla's monster is killed and the war ends.</p>

<p>In the second test case, the war will consist of three battles, and in each of them one of Godzilla's monsters dies.</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;deque&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int NG, NM;
        cin &gt;&gt; NG &gt;&gt; NM;

        if (NG == 0 &amp;&amp; NM == 0) {
            cout &lt;&lt; "uncertain\n";
        } else {
            vector&lt;int&gt; NGA(NG), NMA(NM);
            for (int i = 0; i &lt; NG; ++i) {
                cin &gt;&gt; NGA[i];
            }
            sort(NGA.begin(), NGA.end());
            for (int i = 0; i &lt; NM; ++i) {
                cin &gt;&gt; NMA[i];
            }
            sort(NMA.begin(), NMA.end());

            deque&lt;int&gt; NGQ(NGA.begin(), NGA.end()), 
                       NMQ(NMA.begin(), NMA.end());
            while (!NGQ.empty() &amp;&amp; !NMQ.empty()) {
                if (NGQ.front() &gt;= NMQ.front()) {
                    NMQ.pop_front();
                } else {
                    NGQ.pop_front();
                }
            }
            if (NGQ.empty()) {
                cout &lt;&lt; "MechaGodzilla\n";
            } else {
                cout &lt;&lt; "Godzilla\n";
            }
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/07/army/</link><guid isPermaLink="false">32331cd3-7c18-4fc6-b3b6-23ce3e45394d</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 07 Nov 2014 17:41:53 GMT</pubDate></item><item><title><![CDATA[STAMPS]]></title><description><![CDATA[<p>Everybody hates Raymond. He’s the largest stamp collector on planet earth and because of that he always makes fun of all the others at the stamp collector parties. Fortunately everybody loves Lucy, and she has a plan. She secretly asks her friends whether they could lend her some stamps, so that she can embarrass Raymond by showing an even larger collection than his. Raymond is so sure about his superiority that he always tells how many stamps he’ll show.And since Lucy knows how many she owns, she knows how many more she needs. She also knows how many friends would lend her some stamps and how many each would lend. But she’s like to borrow from as few friends as possible and if she needs too many then she’d rather not do it at all. Can you tell her the minimum number of friends she needs to borrow from?</p>

<h6 id="input">Input</h6>

<p>The first line contains the number of scenarios. Each scenario describes one collectors party and its first line tells you how many stamps (from 1 to 1000000) Lucy needs to borrow and how many friends (from 1 to 1000) offer her some stamps. In a second line you’ll get the number of stamps (from 1 to 10000) each of her friends id offering.</p>

<h6 id="output">Output</h6>

<p>The output for every scenario begins with a line containing “Scenario #i:”, where i is the number of the scenario starting at 1. Then print a single line with the minimum number of friends Lucy needs to borrow stamps from. If it’s impossible even if she borrows everything from everybody, write impossible. Terminate the output for the scenario with a blank line.</p>

<p>Example</p>

<p>Input: <br>
3 <br>
100 6 <br>
13 17 42 9 23 57 <br>
99 6 <br>
13 17 42 9 23 57 <br>
1000 3 <br>
314 159 265</p>

<p>Output: <br>
Scenario #1: <br>
3</p>

<p>Scenario #2: <br>
2</p>

<p>Scenario #3: <br>
impossible</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool compare (int a, int b) {  
    return a &gt; b;
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (int t = 1; t &lt;= T; ++t) {
        int needed, friends;
        cin &gt;&gt; needed &gt;&gt; friends;
        vector&lt;int&gt; stamps(friends);
        for (int i = 0; i &lt; friends; ++i) {
            cin &gt;&gt; stamps[i];
        }
        sort(stamps.begin(), stamps.end(), compare);
        int count = 0, sum = 0;
        for (int i = 0; i &lt; friends; ++i) {
            sum += stamps[i];
            ++count;
            if (sum &gt;= needed) {
                break;
            }
        }
        cout &lt;&lt; "Scenario #" &lt;&lt; t &lt;&lt; ":\n";
        if(sum &gt;= needed) {
            cout &lt;&lt; count &lt;&lt; "\n\n";
        } else {
            cout &lt;&lt; "impossible\n\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/07/stamps/</link><guid isPermaLink="false">59bd02c8-92bc-49d8-a36d-b5c7867409ff</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 07 Nov 2014 13:12:08 GMT</pubDate></item></channel></rss>