<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[TopCoder - Code Jedi]]></title><description><![CDATA[Code, algorithms and design.]]></description><link>http://code-jedi.chintanghate.me/</link><generator>Ghost 0.5</generator><lastBuildDate>Sun, 30 Nov 2014 10:57:03 GMT</lastBuildDate><atom:link href="http://code-jedi.chintanghate.me/tag/topcoder/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Poetry]]></title><description><![CDATA[<p>Used In:    SRM 170 <br>
Used As:    Division II Level Three</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Given a poem, determine its rhyme scheme.</p>

<p>To simplify things, because English is such a fickle language, there are some constraints:</p>

<p>A legal word is a sequence of lower or uppercase letters, containing at least one vowel, where a vowel is 'a', 'e', 'i', 'o', or 'u'. Also, 'y' is considered a vowel if it is not at the start or end of a word. Words are delimited by spaces.</p>

<p>Two words are considered rhyming if they have the same ending pattern (defined below). This comparison is case-insensitive (see Example 1.)</p>

<p>An ending pattern is a substring of a word such that:</p>

<p>The word ends with that substring, <br>
The substring contains exactly one contiguous string of vowels, <br>
The first letter of the substring is a vowel, and <br>
The substring must either be the whole string, or the letter immediately preceding the start of the substring must be a nonvowel. <br>
For example, the ending pattern of "bought" is "ought", the ending pattern of "spying" would be "ying", and the ending pattern of "all" would be "all". (Note that "spy" has no vowels, and thus is not a legal word.)</p>

<p>Two lines rhyme if their corresponding last words rhyme, and a line is empty if it contains no words.</p>

<p>The procedure for determinining rhyme scheme is as follows: The first non-empty line in the poem should be labeled with the lowercase letter 'a'. Every line that rhymes with that line should also be labeled with that letter. The next unlabeled non-empty line should be labeled with the letter 'b', and any rhyming lines should also be labeled in this manner. When you run out of lowercase letters, continue by using the uppercase letters 'A' to 'Z'. Empty lines should be labeled with ' ' (the space character).</p>

<p>The 0th character of the returned String should be the rhyme scheme label of the 0th line, the 1st character should be the label of the 1st line, and so on. This means that the returned String will have the same number of characters as there are elements in poem. Thus, given a String[] poem, then your method should return a String detailing the rhyme scheme.</p>

<h6 id="definition">Definition</h6>

<p>Class:    Poetry <br>
Method:    rhymeScheme <br>
Parameters:    String[] <br>
Returns:    String <br>
Method signature:    String rhymeScheme(String[] poem) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>If there is a blank line in the poem, there must be a corresponding space in the output. A blank line is one with no words. (See Example 1.)</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>poem will have between 1 and 50 elements, inclusive.</li>
<li>each element of poem will contain between 0 and 50 characters, inclusive.</li>
<li>the only allowable characters in poem will be upper and lowercase characters ('a'-'z' and 'A'-'Z') and the space character (' ').</li>
<li>there will be only legal words in poem</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{"I hope this problem", <br>
"is a whole lot better than",
"this stupid haiku"}
Returns: "abc" <br>
Doesn't even conceivably rhyme.</p></li>
<li><p>{"     ", <br>
"Measure your height",
"AND WEIGHT      ",
"said the doctor",
"",
"And make sure to take your pills",
"   to   cure   your    ills",
"Every",
"DAY"}
Returns: " aab ccde" <br>
Even though "height" and "weight" don't actually rhyme in English, they do by the rules laid out above.</p></li>
<li><p>{"One bright day in the middle of the night", <br>
"Two dead boys got up to fight",
"Back to back they faced each other",
"Drew their swords and shot each other",
"",
"A deaf policeman heard the noise",
"And came to arrest the two dead boys",
"And if you dont believe this lie is true",
"Ask the blind man he saw it too"}
Returns: "aabb cdef"</p></li>
<li><p>{"", <br>
"",
"",
""}
Returns: "    " <br>
Four lines from the mind of a blank poet.</p></li>
<li><p>{"This poem has uppercase letters", <br>
"In its rhyme scheme",
"Alpha", "Blaster", "Cat", "Desert", "Elephant", "Frog", "Gulch", 
"Horse", "Ireland", "Jam", "Krispy Kreme", "Loofah", "Moo", "Narf",
"Old", "Pink", "Quash", "Rainbow", "Star", "Tour", "Uvula", "Very",
"Will", "Xmas", "Young", "Zed", "deception", "comic", "grout",
"oval", "cable", "rob", "steal", "steel", "weak"}
Returns: "abcdefghibjkblmnopqrstcuvwxyzABCbDEFG"</p></li>
<li><p>{" ", <br>
"     ",
"This poem",
"         ",
" ",
" ",
"",
"Has lots of blank lines",
" ",
"      ",
"                                            ",
"         ",
" ",
"              ",
"                                                  ",
"  in      it           "}
Returns: "  a    b       c"</p></li>
<li><p>{"too bad   your", <br>
"     solution went   sour"}
Returns: "aa"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

using namespace std;

class Poetry {  
    private:
        bool isVowel(string s, int i) {
            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {
                return true;
            } else if (s[i] == 'y' &amp;&amp; i != 0 &amp;&amp; i != s.size() - 1) {
                return true;
            }
            return false;
        }
        string endPattern(string s) {
            string ep = "";
            bool flag = true;
            for (int i = s.size() - 1; i &gt;= 0; --i) {
                bool v = isVowel(s, i); 
                if (v) {
                    flag = false;
                }
                if (v || flag) {
                    ep = s[i] + ep;
                } else {
                    break;
                }
            }
            return ep;
        }
        bool isEmptyString(string s) {
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] != ' ') {
                    return false;
                }
            }
            return true;
        }
        string lastWord(string s) {
            istringstream iss(s);
            string lw;
            while (iss &gt;&gt; lw);
            return lw;
        }
    public:
        string rhymeScheme(vector&lt;string&gt; poem) {
            vector&lt;char&gt; rhymingSeq;
            for (char i = 'a'; i &lt;= 'z'; ++i) {
                rhymingSeq.push_back(i);
            }
            for (char i = 'A'; i &lt;= 'Z'; ++i) {
                rhymingSeq.push_back(i);
            }
            map&lt;string, char&gt; pattern;
            string scheme = "";
            int seq = 0;
            for (int i = 0; i &lt; poem.size(); ++i) {
                transform(poem[i].begin(), poem[i].end(), poem[i].begin(), ::tolower);
                if (!isEmptyString(poem[i])) {
                    string ep = endPattern(lastWord(poem[i]));
                    if (pattern.find(ep) == pattern.end()) {
                        pattern[ep] = rhymingSeq[seq++];
                    }
                    scheme += pattern[ep];
                } else {
                    scheme += " ";
                }
            }
            return scheme;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/poetry/</link><guid isPermaLink="false">7b987ce1-2551-4210-9070-76a824bb2ab6</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 10:25:31 GMT</pubDate></item><item><title><![CDATA[MatchMaking]]></title><description><![CDATA[<p>Used In:    SRM 203 <br>
Used As:    Division I Level One , Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You are developing the matchmaking component of an online dating site. Prospective members must fill out a questionnaire consisting of binary questions such as Do you prefer to vacation (a) in the mountains or (b) at the seaside? and Would you rather travel (a) by plane or (b) by train?</p>

<p>You are to match up men with women by maximizing the number of answers each couple has in common. A man and a woman have an answer in common whenever they give the same answer to the same question. Conflicts can easily arise due to numerical ties, but you will be able to resolve all such conflicts using the following procedure. Note that there will be equal numbers of men and women, with names being unique in each sex.</p>

<p>Take the woman whose name comes earliest in lexicographic order, and consider the men with whom she has the greatest number of answers in common. Among these men, pick the one whose name comes earliest in lexicographic order. You have found the woman's best match. Remove this couple from the dating pool, and repeat the matching procedure until there are no more singles left.</p>

<p>You are given a String[], namesWomen, containing the names of single women, and another String[], answersWomen, containing their answers. The kth element of answersWomen lists the answers of the woman whose name is the kth element of namesWomen. If there are n questions in the questionnaire, then every element of answersWomen consists of n characters, each of which is either 'a' or 'b'. The answers are always given in the fixed questionnaire order. You are similarly given the String[]s namesMen and answersMen for the single men. Lastly, you are given a String, queryWoman, containing the name of a woman. Return the name of the man to whom she is matched after you have formed all couples according to the above rules.</p>

<h6 id="definition">Definition</h6>

<p>Class:    MatchMaking <br>
Method:    makeMatch <br>
Parameters:    String[], String[], String[], String[], String <br>
Returns:    String <br>
Method signature:    String makeMatch(String[] namesWomen, String[] answersWomen, String[] namesMen, String[] answersMen, String queryWoman) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>Lexicographic order is like dictionary order, with the difference that case matters. All uppercase letters take precedence over all lowercase letters. Thus, "boolean" comes before "boot"; "boo" comes before "boolean"; "Boot" comes before "boo"; "Zoo" comes before "boo".</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>namesWomen contains between 1 and 50 elements, inclusive</li>
<li>if namesWomen consists of n elements, then answersWomen, namesMen, and answersMen consist of n elements each</li>
<li>each element of namesWomen and each element of namesMen is between 1 and 50 characters long, inclusive</li>
<li>the only characters that may appear in namesMen and namesWomen are 'a' to 'z' and 'A' to 'Z'</li>
<li>no two elements of namesWomen are alike</li>
<li>no two elements of namesMen are alike</li>
<li>the first element of answersWomen is between 1 and 50 characters long, inclusive</li>
<li>if the first element of answersWomen consists of m characters, then each element of answersWomen and of answersMen is m characters long</li>
<li>the only characters that may appear in answersWomen and answersMen are 'a' and 'b'</li>
<li>queryWoman is one of the Strings in namesWomen</li>
</ul>

<p>Examples</p>

<ol>
<li><p>{"Constance", "Bertha", "Alice"} <br>
{"aaba", "baab", "aaaa"}
{"Chip", "Biff", "Abe"}
{"bbaa", "baaa", "aaab"}
"Bertha"
Returns: "Biff" <br>
Alice has two answers in common with Chip and three answers in common with both Abe and Biff; Abe gets lexicographic preference. Bertha also has two answers in common with Chip and three answers in common with both Abe and Biff. Since Abe has already been matched to Alice, Bertha lands Biff.</p></li>
<li><p>{"Constance", "Bertha", "Alice"} <br>
{"aaba", "baab", "aaaa"}
{"Chip", "Biff", "Abe"}
{"bbaa", "baaa", "aaab"}
"Constance"
Returns: "Chip" <br>
We are dealing with the same names and answers as before. Constance is the last to go. Although she has two answers in common with Abe and Biff, they are both taken. She ends up with Chip, with whom she has only one answer in common.</p></li>
<li><p>{"Constance", "Alice", "Bertha", "Delilah", "Emily"} <br>
{"baabaa", "ababab", "aaabbb", "bababa", "baabba"}
{"Ed", "Duff", "Chip", "Abe", "Biff"}
{"aabaab", "babbab", "bbbaaa", "abbbba", "abaaba"}
"Constance"
Returns: "Duff"</p></li>
<li><p>{"Constance", "Alice", "Bertha", "Delilah", "Emily"} <br>
{"baabaa", "ababab", "aaabbb", "bababa", "baabba"}
{"Ed", "Duff", "Chip", "Abe", "Biff"}
{"aabaab", "babbab", "bbbaaa", "abbbba", "abaaba"}
"Delilah"
Returns: "Chip"</p></li>
<li><p>{"Constance", "Alice", "Bertha", "Delilah", "Emily"} <br>
{"baabaa", "ababab", "aaabbb", "bababa", "baabba"}
{"Ed", "Duff", "Chip", "Abe", "Biff"}
{"aabaab", "babbab", "bbbaaa", "abbbba", "abaaba"}
"Emily"
Returns: "Ed"</p></li>
<li><p>{"anne", "Zoe"} <br>
{"a", "a"}
{"bob", "chuck"}
{"a", "a"}
"Zoe"
Returns: "bob"</p></li>
<li><p>{"F", "M", "S", "h", "q", "g", "r", "N", "U", "x", "H", "P", <br>
"o", "E", "R", "z", "L", "m", "e", "u", "K", "A", "w", "Q",
"O", "v", "j", "a", "t", "p", "C", "G", "k", "c", "V", "B",
"D", "s", "n", "i", "f", "T", "I", "l", "d", "J", "y", "b"}
{"abaabbbb", "bbaabbbb", "aaabaaab", "aabbaaaa", "baabbaab",
"aaababba", "bbabbbbb", "bbbabbba", "aaabbbba", "aabbbaaa",
"abbabaaa", "babbabbb", "aaaaabba", "aaaabbaa", "abbbabaa",
"babababa", "abbaaaaa", "bbababba", "baaaaaba", "baaaaabb",
"bbbbabba", "ababbaaa", "abbbabab", "baabbbaa", "bbbaabbb",
"aababbab", "ababbabb", "abbaabba", "baabbabb", "aaabaaab",
"aabbbaba", "aabaaabb", "abababba", "aabbaaaa", "aabbabaa",
"bababaaa", "aabaaaab", "bbbbaabb", "baaababb", "abaabbab",
"aabbbaaa", "baabbaba", "bbabbbaa", "aabbbbaa", "abbbaaab",
"abababbb", "ababaaba", "bababaaa"}
{"f", "C", "v", "g", "Q", "z", "n", "c", "B", "o", "M", "F",
"u", "x", "I", "T", "K", "L", "E", "U", "w", "A", "d", "t",
"e", "R", "D", "s", "p", "q", "m", "r", "H", "j", "J", "V",
"l", "a", "k", "h", "G", "y", "i", "P", "O", "N", "b", "S"}
{"bbbaabab", "bbabaabb", "ababbbbb", "bbbababb", "baababaa",
"bbaaabab", "abbabbaa", "bbbabbbb", "aabbabab", "abbababa",
"aababbbb", "bababaab", "aaababbb", "baabbaba", "abaaaaab",
"bbaababa", "babaabab", "abbabbba", "ababbbab", "baabbbab",
"babbaaab", "abbbbaba", "bbabbbba", "baaabaab", "ababbabb",
"abbbaabb", "bbbbaabb", "bbbaaabb", "baabbaba", "bbabaaab",
"aabbbaab", "abbbbabb", "bbaaaaba", "bbbababa", "abbaabba",
"bababbbb", "aabaaabb", "babbabab", "baaaabaa", "ababbaba",
"aaabaabb", "bbaaabaa", "baaaaabb", "bbaabaab", "bbababab",
"aabaaaab", "aaaaabab", "aabbaaba"}
"U"
Returns: "x"</p></li>
<li><p>{"q", "M", "w", "y", "p", "N", "s", "r", "a", "H", "o", "n", <br>
"F", "m", "l", "b", "D", "j", "C", "u", "f", "I", "g", "L",
"i", "x", "A", "G", "O", "k", "h", "d", "c", "E", "B", "v",
"J", "z", "K", "e", "t"}
{"aabbaaabb", "baabababb", "bbaababba", "bbbaaaaaa", "abaaaabaa",
"bababbbab", "abbaabbaa", "aabababbb", "bababaaaa", "abbababaa",
"aabbbbbba", "bbabbabab", "babaabbba", "babbabbbb", "baaabbbbb",
"baaabaaaa", "aaabbaaab", "abbaabbbb", "abbabbbab", "bbaaaabba",
"babbaaabb", "aabbabbab", "baaababba", "ababaabab", "bbbaabbab",
"aaaabbabb", "babaaaaaa", "abbbbaaab", "aabaaabba", "bbbaaaaba",
"bbbbbbaab", "aabbaaabb", "aabaabbab", "aababaaba", "bbabbbbab",
"abbabaaab", "babaaabbb", "bababbaaa", "aabbaabaa", "baaabbabb",
"bbbbbbbbb"}
{"m", "k", "n", "q", "L", "E", "M", "l", "w", "x", "g", "e",
"i", "z", "F", "r", "a", "h", "f", "D", "J", "K", "j", "v",
"A", "t", "N", "y", "s", "c", "o", "p", "d", "b", "B", "G",
"O", "I", "u", "C", "H"}
{"bbaaabbba", "bbaaaaaab", "abaaababb", "baaaabbbb", "abbbababa",
"baaaaaaaa", "aabbbbbab", "aaaaabbba", "baabababb", "babaaabab",
"baaababaa", "bbbbaabba", "bbaabbabb", "bbaaababb", "abbabbaba",
"aababaaab", "abbbbbbaa", "aabbaabaa", "bbbaabbba", "abbabbaba",
"aaabbbaaa", "bbaabaaaa", "aabababbb", "abbbbabab", "baaabbbba",
"bababbbba", "aababbaab", "bbaabbaab", "bbbaaabbb", "babbbbabb",
"ababababb", "babaaabab", "bbaaaaaba", "aaaaabaaa", "abbaaabbb",
"bbbbababb", "baabababb", "bbaabaaaa", "aaababbbb", "abbbbbbba",
"bbaabbaaa"}
"o"
Returns: "C"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;map&gt;

using namespace std;

class MatchMaking {  
    private:
        int mathches(string a, string b) {
            int match = 0;
            for (int i = 0; i &lt; a.size(); ++i) {
                if (a[i] == b[i]) {
                    ++match;
                }
            }
            return match;
        }

    public:
        string makeMatch(vector&lt;string&gt; namesWomen, vector&lt;string&gt; answerWomen, vector&lt;string&gt; namesMen, vector&lt;string&gt; answerMen, string queryWoman) {
            int n = namesMen.size();
            string theChosenOne = "";
            map&lt;string, string&gt; women, men;
            vector&lt;bool&gt; taken(n, false);
            for (int i = 0; i &lt; n; ++i) {
                women[namesWomen[i]] = answerWomen[i];
                men[namesMen[i]] = answerMen[i];
            }
            for (map&lt;string, string&gt; :: iterator i = women.begin(); 
                i != women.end(); ++i) {
                int compatibility = -1;
                int index = 0,
                    jn = 0;
                for (map&lt;string, string&gt; :: iterator j = 
                    men.begin(); j != men.end(); ++j, ++jn) {
                    if (!taken[jn]) {
                        int match = mathches(i-&gt;second, j-&gt;second);
                        if (match &gt; compatibility) {
                            compatibility = match;
                            index = jn;
                            theChosenOne = j-&gt;first;
                        }
                    }
                }
                taken[index] = true;
                if (i-&gt;first == queryWoman) {
                    break;
                }
            }
            return theChosenOne;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/matchmaking/</link><guid isPermaLink="false">42d8c9c0-ad89-4714-8b3f-6c6396e3864a</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 07:37:33 GMT</pubDate></item><item><title><![CDATA[BettingMoney]]></title><description><![CDATA[<p>Used In:    SRM 191 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You run a gambling business in which people place bets on the margin of victory in a football game. At the end of the day, the company would like to know what the day's net gain has been.</p>

<p>Just as in any other betting system, people place certain amounts as their bets and if they guess correctly, they get their money back plus a pre-specified percentage of their bet; otherwise they lose the money they bet. </p>

<p>You are given a int[], amounts, the ith element of which is the number of dollars people have placed on a victory margin of i (i = 0 refers to the first element). You are also given a int[], centsPerDollar, the ith element of which is the number of cents the company has to pay for every dollar the people bet on a victory margin of i, if the final outcome is a victory margin of i. Finally, you are given an int, finalResult, which is the final margin of victory. You have to determine what the net gain for the day was and return the amount in cents.</p>

<p>For example, if amounts were {10,20,30}, it would mean that people placed $10 on a draw outcome, $20 on a victory margin of 1 and $30 on a victory margin of 2, and if centsPerDollar were {20,30,40}, it would mean the people would win 20 cents per dollar bet if the match were a draw, 30 cents per dollar if the victory margin were 1 and 40 cents per dollar if the victory margin were 2. </p>

<p>Suppose the final result is a victory margin of 1 (i.e., finalResult = 1). Then the people who guessed the outcome as a margin of 0 or 2 were wrong and the company receives the amounts they bet, $10+$30. However, the people who guessed that the outcome would be a margin of 1 were correct, and they receive money from the company according to the amount they bet (20 dollars) and the pre-set payoff percentage (30 cents per dollar) . This amounts to 20*30 = 600 cents. Hence, the day's net gain is 40 dollars - 600 cents = 3400 cents. You should return 3400.</p>

<h6 id="definition">Definition</h6>

<p>Class:    BettingMoney <br>
Method:    moneyMade <br>
Parameters:    int[], int[], int <br>
Returns:    int <br>
Method signature:    int moneyMade(int[] amounts, int[] centsPerDollar, int finalResult) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>Keep in mind that it is not relevant which team wins. Only the margin of victory matters.</li>
<li>A victory margin of 0 and a draw are the same thing.</li>
<li>There are 100 cents in a dollar.</li>
<li>If the company has to pay more than it receives, the day's net gain will be negative.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>amounts will contain between 1 and 50 elements, inclusive.</li>
<li>centsPerDollar will contain the same number of elements as amounts.</li>
<li>finalResult will be between 0 and n-1, inclusive, where n is the number of elements in amounts.</li>
<li>Each element of amounts will be between 0 and 5000, inclusive.</li>
<li>Each element of centsPerDollar will be between 0 and 5000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{10,20,30} <br>
{20,30,40}
1 <br>
Returns: 3400 <br>
The case explained in the problem statement above.</p></li>
<li><p>{200,300,100} <br>
{10,10,10}
2 <br>
Returns: 49000 <br>
The company gains 200+300 = 500 dollars from the people who bet on margins of 0 and 1. The company loses 100*10 = 1000 cents to the people who bet on a victory margin of 2. Hence, the net gain is 49000 cents.</p></li>
<li><p>{100,100,100,100} <br>
{5,5,5,5}
0 <br>
Returns: 29500</p></li>
<li><p>{5000,5000} <br>
{100,2}
0 <br>
Returns: 0</p></li>
<li><p>{100} <br>
{10}
0 <br>
Returns: -1000 <br>
The company doesn't gain anything! It has to pay the people who bet on the only outcome possible. It pays 100*10 cents. Hence, the net gain is -1000. (Negative indicates loss.)</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class BettingMoney {  
    public:
        int moneyMade(vector&lt;int&gt; amounts, vector&lt;int&gt; centsPerDollar, int finalResult) {
            int profit = 0;
            for (int i = 0; i &lt; amounts.size(); ++i) {
                if (i == finalResult) {
                    profit -= (amounts[i] * centsPerDollar[i]);
                } else {
                    profit += (amounts[i] * 100);
                }
            }
            return profit;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/bettingname/</link><guid isPermaLink="false">99b30a41-e004-409d-a143-0e90ec6c8f90</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 05:18:42 GMT</pubDate></item><item><title><![CDATA[UserName]]></title><description><![CDATA[<p>Used In:    SRM 203 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You are implementing the member registration system of an online dating site. When a new member signs up, it is possible that she initially chooses the same username as an existing member. The system must then inform the new member of the conflict and suggest a variant of the chosen name with a number attached to the end.</p>

<p>If an existing member is named "FunkyMonkey", for example, and a new member wants the same username, the simplest suggestion the system can make is "FunkyMonkey1". If there is already a member by that name, the system must suggest "FunkyMonkey2", unless that variant is also taken. If all names from "FunkyMonkey1" through "FunkyMonkey9" are taken as well as the original "FunkyMonkey", the system moves on to consider "FunkyMonkey10", and so on. The goal is to use the smallest possible number in the variant. Note that each username consists of letters (the characters from 'a' to 'z' and from 'A' to 'Z') and numerals ('0' to '9').</p>

<p>You are given a String[], existingNames, containing all usernames that have already been registered in the system. You are also given a single String, newName, containing the username that a new member wants to use. In the event of a conflict, this member will accept the suggestion offered by your system in accordance with the principles above. Return a String containing the username finally assigned to the new member.</p>

<h6 id="definition">Definition</h6>

<p>Class:    UserName <br>
Method:    newMember <br>
Parameters:    String[], String <br>
Returns:    String <br>
Method signature:    String newMember(String[] existingNames, String newName) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>The constraints rule out names that end in a number with a leading zero, such as "grokster006" and "bart0".</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>existingNames contains between 1 and 50 elements, inclusive</li>
<li>each element of existingNames is between 1 and 50 characters long, inclusive</li>
<li>the only characters permitted in elements of existingNames are 'a' to 'z', 'A' to 'Z', and '0' to '9'</li>
<li>no element of existingNames ends in a number that has a leading zero</li>
<li>newName is between 1 and 50 characters long, inclusive</li>
<li>the only characters permitted in newName are 'a' to 'z' and 'A' to 'Z'</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{"MasterOfDisaster", "DingBat", "Orpheus", "WolfMan", "MrKnowItAll"} <br>
"TygerTyger"
Returns: "TygerTyger" <br>
"TygerTyger" is available.</p></li>
<li><p>{"MasterOfDisaster", "TygerTyger1", "DingBat", "Orpheus", <br>
"TygerTyger", "WolfMan", "MrKnowItAll"}
"TygerTyger"
Returns: "TygerTyger2" <br>
"TygerTyger" and "TygerTyger1" are taken.</p></li>
<li><p>{"TygerTyger2000", "TygerTyger1", "MasterDisaster", "DingBat", <br>
"Orpheus", "WolfMan", "MrKnowItAll"}
"TygerTyger"
Returns: "TygerTyger" <br>
There are higher-numbered variants of "TygerTyger", but the base name is available.</p></li>
<li><p>{"grokster2", "BrownEyedBoy", "Yoop", "BlueEyedGirl", <br>
"grokster", "Elemental", "NightShade", "Grokster1"}
"grokster"
Returns: "grokster1" <br>
Note that "Grokster1" is not the same as "grokster1".</p></li>
<li><p>{"Bart4", "Bart5", "Bart6", "Bart7", "Bart8", "Bart9", "Bart10", <br>
"Lisa", "Marge", "Homer", "Bart", "Bart1", "Bart2", "Bart3",
"Bart11", "Bart12"}
"Bart"
Returns: "Bart13"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;

using namespace std;

class UserName {  
    private:
        string intToString(int n) {
            ostringstream oss;
            oss &lt;&lt; n;
            return oss.str();
        }
    public:
        string newMember(vector&lt;string&gt; existingNames, string newName) {
            if (find(existingNames.begin(), existingNames.end(), 
               newName) == existingNames.end()) {
                return newName;
            }
            int i = 1;
            while (find(existingNames.begin(), existingNames.end(), 
            newName + intToString(i++)) != existingNames.end());
            return newName + intToString(--i);
        }   
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/username/</link><guid isPermaLink="false">be1ed185-8877-42a7-9d89-8f80236c99b0</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 04:18:37 GMT</pubDate></item></channel></rss>