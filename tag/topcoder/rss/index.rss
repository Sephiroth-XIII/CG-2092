<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[TopCoder - Code Jedi]]></title><description><![CDATA[Code, algorithms and design.]]></description><link>http://code-jedi.chintanghate.me/</link><generator>Ghost 0.5</generator><lastBuildDate>Sat, 06 Dec 2014 17:55:14 GMT</lastBuildDate><atom:link href="http://code-jedi.chintanghate.me/tag/topcoder/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[QuipuReader]]></title><description><![CDATA[<p>Used In:    SRM 155 <br>
Used As:    Division I Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>The Incas used a sophisticated system of record keeping consisting of bundles of knotted cords. Such a bundle of cords is called a quipu. Each individual cord represents a single number. Surprisingly, the Incas used a base-10 positional system, just like we do today. Each digit of a number is represented by a cluster of adjacent knots, with spaces between neighboring clusters. The digit is determined by the number of knots in the cluster. For example, the number 243 could be represented by a cord with knots tied in the following pattern</p>

<pre><code> -XX-XXXX-XXX-
</code></pre>

<p>where each uppercase 'X' represents a knot and each '-' represents an unknotted segment of cord (all quotes for clarity only). <br>
A sequence of numbers is represented by a sequence of cords. For example, the numbers 725, 234, and 558 could be represented by the cords</p>

<pre><code> -XXXXXXX--XX-----XXXXX---
 ---XX----XXX-----XXXX----
 -XXXXX---XXXXX--XXXXXXXX-
</code></pre>

<p>Notice how consecutive dashes are used to align clusters of knots on different cords. Clusters representing digits in the same position are required to overlap completely. Clusters representing digits in different positions never overlap. All quipus obey these rules. For example, the following configurations would all be illegal:</p>

<pre><code> -XXXXX---
 ----XXX--    [The 3 and 5 must overlap completely or not at all.]

 -XXXXXXXXX-
 --XX------- 
 -------XX--  [Both 2s overlap with the 9, but not each other.]

 -XXXXXXXX-
 --XX----X-   [The 2 and 1 cannot both overlap with the 8.]
</code></pre>

<p>Unlike many ancient civilizations, the Incas were aware of the concept of zero, and used it in their quipus. A zero is represented by a cluster containing no knots. For example, the numbers 105 and 340 could be represented by the cords</p>

<pre><code> --X--------XXXXX-
 -XXX--XXXX-------
</code></pre>

<p>Assume that the numbers being represented do not all contain zeros in the same position. For example, any input that you could conceivably interpret as representing the numbers 105 and 802, you should interpret as 15 and 82 instead. <br>
Write a method to translate a sequence of quipu cords (of type String[]) into a sequence of integers (of type int[]), where the integer in position i corresponds to the cord in position i.</p>

<h6 id="definition">Definition</h6>

<p>Class:    QuipuReader <br>
Method:    readKnots <br>
Parameters:    String[] <br>
Returns:    int[] <br>
Method signature:    int[] readKnots(String[] knots) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>knots contains between 1 and 10 elements, inclusive.</li>
<li>Each element of knots contains the same number of characters, between 1 and 50, inclusive.</li>
<li>Each element of knots contains only the characters 'X' and '-'. Note that 'X' is uppercase.</li>
<li>At least one element of knots contains at least one 'X'.</li>
<li>No element of knots contains 10 consecutive 'X's.</li>
<li>If two (non-empty) clusters of knots A and B overlap at all, then they must overlap completely. More formally, let A0 be the position of the first 'X' in cluster A, and let A1 be the position of the last 'X' in cluster A. Let B0 and B1 be defined similarly for cluster B. Assume, without loss of generality, that A0 &lt;= B0. Then either B1 &lt;= A1 (they overlap completely) or A1 &lt; B0 (they do not overlap at all).</li>
<li>All clusters of knots that overlap with some particular cluster also overlap with each other. More formally, if two (non-empty) clusters of knots A and B both overlap with a third (non-empty) cluster C, then A and B also overlap with other.</li>
<li>Each element of knots will represent a number between 0 and 1000000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<p>1)  </p>

<pre><code class="    ">{ "-XXXXXXX--XX-----XXXXX---",
  "---XX----XXX-----XXXX----",
  "-XXXXX---XXXXX--XXXXXXXX-" }
  Returns: { 725,  234,  558 }
</code></pre>

<p>One of the examples above. Notice that adjacent digit positions are usually separated by one or more columns of dashes. In this example, the first and second positions are separated by one column of dashes, and the second and third positions are separated by two columns of dashes.</p>

<p>2)  </p>

<pre><code>{ "XX---XXXX",
  "XXX-----X" }
Returns: { 24,  31 }  
</code></pre>

<p>Notice that leading and trailing dashes are not required.</p>

<p>3)  </p>

<pre><code>{ "-XXX---XX----X",
  "--X----X-XXXXX",
  "-XX--XXXX---XX" }
Returns: { 321,  115,  242 }  
</code></pre>

<p>Notice that adjacent digit positions are not always separated by columns of dashes. In this example, the first and second positions are separated by a column of dashes, but the second and third positions are not.</p>

<p>4)  </p>

<pre><code>{ "-------X--------",
  "--XXX----XXXX---",
  "--------------XX" }
Returns: { 100,  3040,  2 }  
</code></pre>

<p>Notice that leading zeros are permitted. For example, 100 is really 0100 and 2 is really 0002.</p>

<p>5)  </p>

<pre><code>{ "--XXX-XXXXXXXX----------XXXXXXXXX--XXXXXXXX-",
  "--XX----XXXX-----XXXXXX---XXX------XXXXXXXX-",
  "--------------------X----XXXXXXXX--XXXXXXXX-",
  "--XX-------X------XXXX----XXX-------XXXXXX--",
  "--XXX---XXXXX-------X------XX--------X------",
  "-XXXX--XXXXXXX-----------XXXXXXX----XXXXX---",
  "-----------X---XXXXXXXX----XX--------XXX----",
  "-----------X---XXXXXXXX----X----------------",
  "---X--XXXXXXXX--XXXXXXX---XXX---------------",
  "--XX---XXXXXXX--XXXXXXX----XX-------XXXXX---" }
Returns: { 38098,  24638,  188,  21436,  35121,  47075,  1823,  1810,  18730,  27725 }  
</code></pre>

<p>6)  </p>

<pre><code>{"X","-"}
Returns: { 1,  0 }  
</code></pre>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;

using namespace std;

class QuipuReader {  
    private:
        int stringToInt(string s) {
            istringstream iss(s);
            int n;
            iss &gt;&gt; n;
            return n;
        }

    public:
        vector&lt;int&gt; readKnots(vector&lt;string&gt; knots) {
            int m = knots.size();
            int n = knots[0].size();
            for (int i = 0; i &lt; m ; ++i) {
                for (int j = 0; j &lt; n; ++j) {
                    if (knots[i][j] != 'X') {
                        knots[i][j] = 0;
                    }
                }
            }
            vector&lt;bool&gt; f(60, false),
                         g(60, false);

            for (int i = 0; i &lt; m ; ++i) {
                for (int j = 0; j &lt; n; ++j) {
                    if (knots[i][j] &amp;&amp; knots[i][j - 1]) {
                        f[j] = true;
                    }
                    if (knots[i][j]) {
                        g[j] = true;
                    }
                }
            }

            for (int j = 0; j &lt; n; ++j) {
                if (!g[j]) {
                    f[j] = true;
                }
            }
            vector&lt;int&gt; r(m, 0);

            for (int i = 0; i &lt; m ; ++i) {
                for (int j = 0; j &lt; n; ++j) {
                    if (!f[j]) {
                        r[i] *= 10;
                    }
                    if (knots[i][j]) {
                        ++r[i];
                    }
                }
            }
            return r;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/06/quipureader/</link><guid isPermaLink="false">6406347d-a6a0-4376-9c58-fb76fa89cbd3</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 06 Dec 2014 14:36:07 GMT</pubDate></item><item><title><![CDATA[TickTick]]></title><description><![CDATA[<p>Used In:    SRM 177 <br>
Used As:    Division I Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Our computer clock is not continuous. It "ticks" every millisecond and keeps track of how many ticks have occurred since the beginning of the "epoch" (Jan 1, 1970). The clocktime does not change between ticks.</p>

<p>Time is continuous, and events (such as interrupts from hardware devices and the starting of a program) can happen anytime. We have a program that experiences a sequence of events. At each event in our program, our logic gets the current clocktime and compares it with the clocktime stored from the previous event. It outputs either 'D' or 'S' indicating whether the current clocktime is Different or the Same as the previous event's clocktime. (The first event after the program starts generates the first 'S' or 'D' based on comparison with the clocktime at the start of the program.)</p>

<p>Because the first tick during our program can occur anytime within one millisecond after the start of the program, the string of 'D's and 'S's output from our program cannot be predicted, even given the exact timing of the program. Create a class TickTick that contains a method count that is given event, a String[] of the times of events relative to the start of the program, and returns the number of different output sequences that might be generated. The event times are given in milliseconds elapsed since the start of the program, formatted to contain digits and exactly one decimal point.</p>

<p>Time is continuous, so exact coincidences do not occur (or occur with probability 0). You should not consider the possibility that a tick occurs at exactly the same time as an event or at the exact start of the program. The constraints on event guarantee that two different events can never be exactly an integral number of milliseconds apart.</p>

<h6 id="definition">Definition</h6>

<p>Class:    TickTick <br>
Method:    count <br>
Parameters:    String[] <br>
Returns:    int <br>
Method signature:    int count(String[] events) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>events has between 1 and 50 elements inclusive</li>
<li>each element of events has length between 2 and 8, and contains exactly one decimal point '.'. All the other characters are digits '0'-'9'</li>
<li>no element of events has a value equal to an integer</li>
<li>no two elements of events have values that differ by an integer</li>
<li>the elements of events have values that are strictly increasing</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{".222","00.223","1.221","4.220"} <br>
Returns: 4 <br>
If the clock's first tick occurs approximately .100 milliseconds after the start of the program, then the clocktime at time .222 will be Different from the clocktime at the start. The clocktime at .223 will be the same as at .222, the clocktime at 1.221 will be different from the clocktime at .223 since a tick occurs at 1.100. The clocktime at 4.220 will always be different from the clocktime at 1.221. So in this case, the program generates DSDD. Similarly, <br>
if the clock's first tick is at .2215, DSSD
if the clock's first tick is at .2225, SDSD
if the clock's first tick is at .2235, SSDD 
These are the only possible sequences that can be generated.</p></li>
<li><p>{"4.220112","4.221","4.222","4.223"} <br>
Returns: 4 <br>
DSSS, DSSD, DSDS, DDSS</p></li>
<li><p>{"123456.1","123456.7"} <br>
Returns: 2 <br>
If the first tick occurs at .05 after the program starts, the output would be DS while if it occurs .5 after the program starts, then the output would be DD. These are the only possible results.</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

using namespace std;

class TickTick {  
    public:
        int count(vector&lt;string&gt; events) {
            vector&lt;double&gt; eve(events.size() + 1);
            eve[0] = 0;
            for (int i = 1; i &lt; eve.size(); ++i) {
                istringstream iss(events[i - 1]);
                iss &gt;&gt; eve[i];
            }
            set&lt;string&gt; patterns;
            for (int i = 0; i &lt; eve.size(); ++i) {
                double tick = eve[i] + 5e-8,
                       prev = NAN;
                string s = "";
                for (int j = 0; j &lt; eve.size(); ++j) {
                    double tickIndex = floor(eve[j] - tick);
                    if (tickIndex == prev) {
                        s += 'S';
                    } else {
                        s += 'D';
                    }
                    prev = tickIndex;
                }
                patterns.insert(s);
            }
            return patterns.size();
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/04/ticktick/</link><guid isPermaLink="false">443c2f66-7c9f-47f5-8d3f-025e9825535b</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Thu, 04 Dec 2014 05:37:24 GMT</pubDate></item><item><title><![CDATA[Jumper]]></title><description><![CDATA[<p>Used In:    SRM 158 <br>
Used As:    Division I Level Three</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>In a certain video game, a jumping player must jump across an area which has floating hoverpads in it. The hoverpads are organized on the screen into evenly spaced rows that move left or right across the screen with a constant speed and direction. The jumper can only cross the area by jumping onto the pads. If the jumper lands on a space that is not a pad, he loses the game. If the jumper is standing on a pad that goes off the side of the screen, he loses the game. The jumper starts out on the bottom of the screen in a non-moving row of solid ground. He must use the pads to jump all the way to the top of the screen, where there is another non-moving row of solid ground. The score of the game depends on how fast the player jumps to the other side.</p>

<p>The screen is made up of 1x1 blocks and is 20 blocks wide. Each pad is comprised of 1 or more 1x1 blocks in a horizontal line. The jumper can only jump a distance of 1 block at a time, and can only jump from one row to another, or to another part of the pad he is currently on that is 1 block away. At the beginning of each second, the jumper either jumps or does not move, and then the pads move a certain distance for the remainder of the second. Jumping takes no time at all, but the jumper must wait for the next second to move again.</p>

<p>You will be given three arguments. patterns will be a String[], with each element having a 5-character pattern in it. In each pattern, a '#' represents hoverpad, and a '.' represents empty space. speeds will be a int[] which represents the speeds of each of the patterns in blocks per second. Positive speeds are to the right, negative speeds are to the left. rows is a String where each character specifies what pattern and speed each row has (Note that this does not include the non-moving solid ground on the bottom and top of the screen). Characters that appear earlier in rows represent rows that are closer to the player's starting row. For example, if rows starts with "01", it would mean that the first row (the row closest to the starting row) is using element 0 of patterns and speeds to define its hoverpads, and the next row is using element 1.</p>

<p>Each row starts out filled with repeated values of its given pattern. For example, the pattern "#..##" would start out as:</p>

<p>"#..###..###..###..##"</p>

<p>The speed determines how fast and in what direction the pads move. As the pads move off the screen, more pads move in on the opposite side of the screen to fill in the space. The pads which move in take on exactly the same pattern as the pads that moved out. For example, if the above pattern had a speed of 3, then ".##" would move off of the right side of the screen and ".##" would move in on the left side, to get:</p>

<p>".###..###..###..###."</p>

<p>Note that if the player were standing on either of the blocks which moved off the screen, he would lose the game.</p>

<p>The character starts on the bottom of the screen in the leftmost column on solid ground (which has no holes and does not move). He can wait any amount of time before jumping onto the first row of hoverpads, and may jump left or right on the solid ground. The player may also jump back to solid ground after jumping to a hoverpad. The player wins if he jumps off of the last row of pads to the solid ground at the top of the screen.</p>

<p>Your method should return the minimum time it takes to get from the bottom to the top of the screen, or -1 if it is not possible.</p>

<h6 id="definition">Definition</h6>

<p>Class:    Jumper <br>
Method:    minTime <br>
Parameters:    String[], int[], String <br>
Returns:    int <br>
Method signature:    int minTime(String[] patterns, int[] speeds, String rows) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>Since it takes no time to jump, the pads do not move while the actual jump is occurring. They move after the jumper lands.</li>
<li>A pad with the player on it also moves the player.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>patterns will have between 1 and 4 elements, inclusive</li>
<li>Each element of patterns will consist of exactly 5 characters, and will only contain the characters '#' and '.'.</li>
<li>speeds will have the same number of elements as patterns.</li>
<li>Each element of speeds will be between -10 and 10, inclusive except 0.</li>
<li>rows will have between 2 and 20 characters, inclusive.</li>
<li>Each character in rows will be a digit between 0 and the number of elements in patterns - 1, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li>{"###..", "..###"} <br>
{1,1}
"01"
Returns: 5  </li>
</ol>

<pre><code>The screen looks like this at the beginning:

..###..###..###..###
###..###..###..###..
P###################  
The player can jump up once, and then both rows of pads move to the right 1 space. The screen is now:

#..###..###..###..##
.P##..###..###..###.
####################
The player can now jump twice to the right. By this time, the pads have moved over twice:

###..###..###..###..
#..##P..###..###..##
####################
Now, the player jumps up to the second row of pads:

.###..P##..###..###.
##..###..###..###..#
####################
And finally, jumps up one more time to victory.  
</code></pre>

<ol>
<li>{"###..", "..###"} <br>
{5,5}
"01"
Returns: 5 <br>
The player cannot follow the same pattern as above, because he would lose when the pads go off the right side of the screen. Instead, he can jump to the right twice, and then he has a straight path up. In the following sequence, remember that the pads move to the right 5 spaces, even though they do not appear to move from frame to frame:  </li>
</ol>

<pre><code>..###..###..###..###
###..###..###..###..  Start
P###################

..###..###..###..###
###..###..###..###..  Right
#P##################

..###..###..###..###
###..###..###..###..  Right
##P#################

..###..###..###..###
###..##P..###..###..  Up (pad carries player right 5 spaces)
####################

..###..###..P##..###
###..###..###..###..  Up (pad carries player right 5 spaces)
####################

Final jump up.  
</code></pre>

<ol>
<li><p>{"....#", "....#"} <br>
{4,5}
"0111"
Returns: 9 <br>
In this example, the only way to make it up to the top is to wait for the first row of pads to line up with the left-most column. Then the player barely has time to jump up through all three other rows of pads before jumping to the very top. It takes 4 seconds for the pads to line up with the player, so he waits for 4 seconds, then he jumps up 5 times to get to the top.</p></li>
<li><p>{"#....", "#...."} <br>
{-4,-5}
"0111"
Returns: 24 <br>
This is the same as the last example, except everything is reversed. Since the only safe place to jump off the bottom is the right-most square, the player must first jump right 19 spaces before jumping up 5 times.</p></li>
<li><p>{"#####","#####"} <br>
{10,10}
"01"
Returns: -1 <br>
Although a straight path exists, the player cannot jump up twice without hitting the wall on the right.</p></li>
<li><p>{"#####","#####","....."} <br>
{1,-1,1}
"01010101010101010102"
Returns: -1 <br>
Be careful of timeouts.</p></li>
<li><p>{"#....", "#....", "#...."} <br>
{5,-5,6}
"2012"
Returns: 12 <br>
Here, in order to use 12 jumps, the player must jump back at least once. One possible ordering of jumps is: <br>
Right, Right, Right, Right, Up, Up, Up, Stand, Down, Up, Up, Up.</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;

#define X front().first.first
#define Y front().first.second
#define T front().second

using namespace std;

class Jumper {

    private:
        int mod(int a, int b) {
            return a % b &lt; 0 ? a % b + b : a % b;
        }

        bool isValidPos(vector&lt;pair&lt;string,int&gt; &gt; patternNSpeed, int x, int y, int t) {
            if(x &lt; 0 || x &gt;= patternNSpeed.size()) {
                return false;
            }
            int s = patternNSpeed[x].second;
            if (y &lt; 0 || y &gt; 19 || y + s &lt; 0 || y + s &gt; 19) {
                return false;
            }
            string p = patternNSpeed[x].first;
            if (p[mod(y - t * s, 20)] != '#') {
                return false;
            }
            return true;
        }

    public:
        int minTime(vector&lt;string&gt; patterns, vector&lt;int&gt; speeds, string rows) {
            int n = rows.size();
            vector&lt;pair&lt;string,int&gt; &gt; patternNSpeed(n + 2);
            patternNSpeed[0] = patternNSpeed[n + 1] = make_pair("####################", 0);
            for (int i = 1; i &lt;= n; ++i) {
                int j = rows[i - 1] - '0';
                string p = patterns[j];
                int s = speeds[j];
                patternNSpeed[i] = make_pair(p + p + p + p, s);
            }   

            int x = 0,
                y = 0,
                t = 0;
            queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt; &gt; bfsQ;
            set&lt;pair&lt;pair&lt;int, int&gt;, int&gt; &gt; uniquePos;
            int Time = -1;
            bfsQ.push(make_pair(make_pair(x, y), t));
            while (!bfsQ.empty()) {
                x = bfsQ.X, y = bfsQ.Y, t = bfsQ.T;
                bfsQ.pop();
                if (x == n + 1) {
                    Time = t;
                    break;
                }
                if (t == 200) {
                    t = -1;
                    break;
                }
                pair&lt;pair&lt;int, int&gt;, int&gt; temp = make_pair(make_pair(x, y), t % 5);
                if (uniquePos.find(temp) != uniquePos.end()) {
                    if (isValidPos(patternNSpeed, x, y - 1, t)) {
                        bfsQ.push(make_pair(make_pair(x, y - 1 + patternNSpeed[x].second), t + 1));
                    }
                    continue;
                }
                uniquePos.insert(make_pair(make_pair(x, y), t % 5));

                if (y + patternNSpeed[x].second &gt;= 0 &amp;&amp; y + patternNSpeed[x].second &lt;= 19) {
                    bfsQ.push(make_pair(make_pair(x, y + patternNSpeed[x].second), t + 1));
                }
                if (isValidPos(patternNSpeed, x + 1, y, t)) {
                    bfsQ.push(make_pair(make_pair(x + 1, y + patternNSpeed[x + 1].second), t + 1));
                }
                if (isValidPos(patternNSpeed, x - 1, y, t)) {
                    bfsQ.push(make_pair(make_pair(x - 1, y + patternNSpeed[x - 1].second), t + 1));
                }
                if (isValidPos(patternNSpeed, x, y + 1, t)) {
                    bfsQ.push(make_pair(make_pair(x, y + 1 + patternNSpeed[x].second), t + 1));
                }
                if (isValidPos(patternNSpeed, x, y - 1, t)) {
                    bfsQ.push(make_pair(make_pair(x, y - 1 + patternNSpeed[x].second), t + 1));
                }
            }
            return Time;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/03/jumper/</link><guid isPermaLink="false">78d6e088-7b26-477b-9fc3-74a1cb1b400a</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 03 Dec 2014 17:58:14 GMT</pubDate></item><item><title><![CDATA[Twain]]></title><description><![CDATA[<p>Used In:    SRM 169 <br>
Used As:    Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Spelling in the English language doesn't make sense. Congress has enacted a plan for orthographical reform (loosely based on Mark Twain's plan for the improvement of English spelling) which will change the spelling of words in the English language gradually over the next 7 years. The plan is as follows:</p>

<h6 id="year1">Year 1:</h6>

<ul>
<li>If a word starts with "x", replace the "x" with a "z".</li>
<li>Change all remaining "x"s to "ks"s.</li>
</ul>

<h6 id="year2">Year 2:</h6>

<ul>
<li>Change all "y"s to "i"s.</li>
</ul>

<h6 id="year3">Year 3:</h6>

<ul>
<li>If a "c" is directly followed by an "e" or "i", change the "c" to an "s".</li>
</ul>

<h6 id="year4">Year 4:</h6>

<ul>
<li>If a "c" is directly followed by a "k", remove the "c". Keep applying this rule as necessary (Example: "cck" becomes "k".)</li>
</ul>

<h6 id="year5">Year 5:</h6>

<ul>
<li>If a word starts with "sch", change the "sch" to a "sk".</li>
<li>If a "ch" is directly followed by an "r", change the "ch" to a "k".</li>
<li>After applying the above rules, change all "c"s that are not directly followed by an "h", to a "k". (This includes all "c"s that are the last letter of a word.)</li>
</ul>

<h6 id="year6">Year 6:</h6>

<ul>
<li>If a word starts with "kn" change the "kn" to an "n".</li>
</ul>

<h6 id="year7">Year 7:</h6>

<ul>
<li>Change all double consonants of the same letter to a single consonant. A consonant is any letter that is not one of "a, e, i, o, u." (Example: "apple" becomes "aple"). Keep applying this rule as necessary (Example: "zzz" becomes "z".)</li>
</ul>

<p>The plan requires that rules for each year are followed in the order they are presented, and changes for each year occur after all the changes from previous years.</p>

<p>Write a class Twain, which contains a method getNewSpelling. getNewSpelling takes as parameters an int year representing the number of years that have passed since the plan to improve the English language began, and a String phrase representing the English phrase to convert. For the purposes of the plan, a word is a sequence of lowercase letters ('a'-'z') bounded by spaces or the start/end of phrase. The method returns a String representing the converted phrase.</p>

<h6 id="definition">Definition</h6>

<p>Class:    Twain <br>
Method:    getNewSpelling <br>
Parameters:    int, String <br>
Returns:    String <br>
Method signature:    String getNewSpelling(int year, String phrase) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>year will be between 0 and 7, inclusive</li>
<li>phrase will be between 0 and 50 characters, inclusive</li>
<li>phrase will contain only lowercase letters ('a'-'z') and spaces (' ').</li>
<li>phrase will not contain three or more of the same consonant in a row</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>1 <br>
"i fixed the chrome xerox by the cyclical church"
Returns: "i fiksed the chrome zeroks by the cyclical church" <br>
In year 1, the first "x" in "xerox" is changed to a "z". Then, the "x"s in "fixed" and "zerox" are changed to "ks"s.</p></li>
<li><p>2 <br>
"i fixed the chrome xerox by the cyclical church"
Returns: "i fiksed the chrome zeroks bi the ciclical church" <br>
In year 2, the "y"s in "by" and "cyclical" are changed to "i"s.</p></li>
<li><p>0 <br>
"this is unchanged"
Returns: "this is unchanged" <br>
Since the year is 0, no changes occur.</p></li>
<li><p>7 <br>
"sch kn x xschrx cknnchc cyck xxceci"
Returns: "sk n z zskrks nchk sik zksesi" <br>
In year 1, the phrase becomes "sch kn z zschrks cknnchc cyck zksceci" due to rules concerning the letter "x". In year 2, all "y"s are changed to "i"s yielding "sch kn z zschrks cknnchc cick zksceci". In year 3, "ce" and "ci" are changed to "se" and "si" yielding "sch kn z zschrks cknnchc sick zkssesi". In year 4, "ck" is changed to "k" and the phrase becomes "sch kn z zschrks knnchc sik zkssesi". In year 5, words that begin with "sch" are made to begin with "sk", "chr" is changed to "kr", and all "c"s not followed by an "h" are changed to "k" yielding "sk kn z zskrks knnchk sik zkssesi". In year 6, words that start with "kn" now start with "n" and the phrase becomes "sk n z zskrks nnchk sik zkssesi". Finally, in year 7, double consonants are removed yielding the final result.</p></li>
<li><p>7 <br>
"  concoction   convalescence   cyclical   cello   "
Returns: "  konkoktion   konvalesense   siklikal   selo   " <br>
Beware of extra spaces.</p></li>
<li><p>7 <br>
""
Returns: "" <br>
Don't forget the empty case.</p></li>
<li><p>7 <br>
"cck xzz aaaaa"
Returns: "k z aaaaa"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Twain {  
    private:
        string year1(string s) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if ((i == 0 || s[i - 1] == ' ' ) &amp;&amp; s[i] == 'x') {
                    o += "z";
                } else if (s[i] == 'x') {
                    o += "ks";
                } else {
                    o += s[i];
                }
            }
            return o;
        }
        string year2(string s) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] == 'y') {
                    o += 'i';
                } else {
                    o += s[i];
                }
            }
            return o;
        }
        string year3(string s) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] == 'c' &amp;&amp; i != s.size() - 1 &amp;&amp; (s[i + 1] == 'e' || s[i + 1] == 'i')) {
                    o += 's';
                } else {
                    o += s[i];
                }
            }
            return o;
        }
        string year4(string s) {
            string o = "";
            for (int i = s.size() - 1; i &gt;= 0; --i) {
                if (o.size() &gt; 0 &amp;&amp; o[0] == 'k' &amp;&amp; s[i] == 'c') {
                    continue;
                } else {
                    o = s[i] + o;
                }
            }
            return o;
        }
        string year5(string s) {
            string o = "";

            for (int i = 0; i &lt; s.size(); ++i) {
                if ((i == 0 || s[i - 1] == ' ') &amp;&amp; i &lt;= s.size() - 3 &amp;&amp; s[i] == 's' &amp;&amp; s[i + 1] == 'c' &amp;&amp; s[i + 2] == 'h') {
                    o += "sk";
                    i += 2;
                } else {
                    o += s[i];
                }
            }

            string o1 = "";
            for (int i = 0; i &lt; o.size(); ++i) {
                if (i &lt;= o.size() - 3 &amp;&amp; o[i] == 'c' &amp;&amp; o[i + 1] == 'h' &amp;&amp; o[i + 2] == 'r') {
                    o1 += "kr";
                    i += 2;
                } else {
                    o1 += o[i];
                }
            }
            for (int i = 0; i &lt; o1.size(); ++i) {
                if ((i != o1.size() - 1 &amp;&amp; o1[i] == 'c' &amp;&amp; o1[i + 1] != 'h') || (i == o1.size() - 1 &amp;&amp; o1[i] == 'c')) {
                    o1[i] = 'k';
                }
            }
            return o1;
        }
        string year6(string s) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if ((i == 0 || s[i - 1] == ' ') &amp;&amp;  i &lt;= s.size() - 2 &amp;&amp; s[i] == 'k' &amp;&amp; s[i + 1] == 'n') {
                    o += "n";
                    i += 1;
                } else {
                    o += s[i];
                }
            }
            return o;
        }
        string year7(string s) {
            string o = "";
            o += s[0];
            for (int i = 1; i &lt; s.size(); ++i) {
                if (s[i] != 'a' &amp;&amp; s[i] != 'e' &amp;&amp; s[i] != 'i' &amp;&amp; s[i] != 'o' &amp;&amp; s[i] != 'u' &amp;&amp; s[i] != ' ' &amp;&amp; s[i] == s[i - 1]) {
                    continue;
                } else {
                    o += s[i];
                }
            }
            return o;
        }
    public:
        string getNewSpelling(int year, string phrase) {
            if (phrase == "") {
                return phrase;
            }
            if (year == 0) {
                return phrase;
            }
            if (year &gt;= 1) {
                phrase = year1(phrase);
            }
            if (year &gt;= 2) {
                phrase = year2(phrase);
            }
            if (year &gt;= 3) {
                phrase = year3(phrase);
            }
            if (year &gt;= 4) {
                phrase = year4(phrase);
            }
            if (year &gt;= 5) {
                phrase = year5(phrase);
            }
            if (year &gt;= 6) {
                phrase = year6(phrase);
            }
            if (year &gt;= 7) {
                phrase = year7(phrase);
            }
            return phrase;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/02/twain/</link><guid isPermaLink="false">d68a33ab-cfce-48eb-a690-a3a92f7f59be</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Mon, 01 Dec 2014 19:52:01 GMT</pubDate></item><item><title><![CDATA[RecurrenceRelation]]></title><description><![CDATA[<p>Used In:    SRM 170 <br>
Used As:    Division I Level One , Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Consider a sequence {x0, x1, x2, ...}. A relation that defines some term xn in terms of previous terms is called a recurrence relation. A linear recurrence relation is one where the recurrence is of the form xn = ck-1xn-1 + ck-2xn-2 + ... + c0xn-k, where all the ci are real-valued constants, k is the length of the recurrence relation, and n is an arbitrary positive integer which is greater than or equal to k.</p>

<p>You will be given a int[] coefficients, indicating, in order, c0, c1, ..., ck-1. You will also be given a int[] initial, giving the values of x0, x1, ..., xk-1, and an int N. Your method should return xN modulo 10.</p>

<p>Note that the value of X modulo 10 equals the last digit of X if X is non-negative. However, if X is negative, this is not true; instead, X modulo 10 equals ((10 - ((-X) modulo 10)) modulo 10). For example, (-16) modulo 10 = ((10 - (16 modulo 10)) modulo 10) = (10 - 6) modulo 10 = 4.</p>

<p>More specifically, if coefficients is of size k, then the recurrence relation will be</p>

<p>xn = coefficients[k - 1] * xn-1 + coefficients[k - 2] * xn-2 + ... + coefficients[0] * xn-k. <br>
For example, if coefficients = {2,1}, initial = {9,7}, and N = 6, then our recurrence relation is xn = xn-1 + 2 * xn-2 and we have x0 = 9 and x1 = 7. Then x2 = x1 + 2 * x0 = 7 + 2 * 9 = 25, and similarly, x3 = 39, x4 = 89, x5 = 167, and x6 = 345, so your method would return (345 modulo 10) = 5.</p>

<h6 id="definition">Definition</h6>

<p>Class:    RecurrenceRelation <br>
Method:    moduloTen <br>
Parameters:    int[], int[], int <br>
Returns:    int <br>
Method signature:    int moduloTen(int[] coefficients, int[] initial, int N) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>(a + b) modulo x = ( (a modulo x) + (b modulo x) ) modulo x for any values of a, b, and x.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>coefficients will have between 1 and 10 elements, inclusive.</li>
<li>initial will have the same number of elements as coefficients.</li>
<li>Each element of coefficients will be between -1000 and 1000, inclusive.</li>
<li>Each element of initial will be between -1000 and 1000, inclusive.</li>
<li>N will be between 0 and 100000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{2,1} <br>
{9,7}
6 <br>
Returns: 5 <br>
As described in the problem statement.</p></li>
<li><p>{1,1} <br>
{0,1}
9 <br>
Returns: 4 <br>
This is the famous Fibonacci sequence, which goes 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</p></li>
<li><p>{2} <br>
{1}
20 <br>
Returns: 6 <br>
This sequence is 1, 2, 4, 8, 16, ...</p></li>
<li><p>{2} <br>
{1}
64 <br>
Returns: 6 <br>
Watch out for overflow.</p></li>
<li><p>{25,143} <br>
{0,0}
100000 <br>
Returns: 0 <br>
This sequence will always be zero.</p></li>
<li><p>{9,8,7,6,5,4,3,2,1,0} <br>
{1,2,3,4,5,6,7,8,9,10}
654 <br>
Returns: 5</p></li>
<li><p>{901,492,100} <br>
{-6,-15,-39}
0 <br>
Returns: 4 <br>
Watch out for negative numbers.</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class RecurrenceRelation {  
    private:
        int mod(int a, int b) {
            return a % b &lt; 0 ? a % b + b : a % b;
        }
    public:
        int moduloTen(vector&lt;int&gt; coefficients, vector&lt;int&gt; initial, int N) {
            vector&lt;int&gt; ans(N + 1, 0);
            for (int i = 0; i &lt;= N; ++i) {
                if (i &lt; initial.size()) {
                    ans[i] = mod(initial[i], 10);
                } else {
                    for (int j = 0, k = coefficients.size(); j &lt; coefficients.size(); ++j, --k) {
                        ans[i] = mod(ans[i] + (ans[i - k] * coefficients[j]), 10);
                    }
                }
            }
            return ans[N];
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/01/recurrencerelation/</link><guid isPermaLink="false">9054eb6f-d90c-4b5b-a168-e7a7f09bf156</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Mon, 01 Dec 2014 06:08:07 GMT</pubDate></item><item><title><![CDATA[QuickSums]]></title><description><![CDATA[<p>Used In:    SRM 197 <br>
Used As:    Division II Level Three</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Given a string of digits, find the minimum number of additions required for the string to equal some target number. Each addition is the equivalent of inserting a plus sign somewhere into the string of digits. After all plus signs are inserted, evaluate the sum as usual. For example, consider the string "12" (quotes for clarity). With zero additions, we can achieve the number 12. If we insert one plus sign into the string, we get "1+2", which evaluates to 3. So, in that case, given "12", a minimum of 1 addition is required to get the number 3. As another example, consider "303" and a target sum of 6. The best strategy is not "3+0+3", but "3+03". You can do this because leading zeros do not change the result.</p>

<p>Write a class QuickSums that contains the method minSums, which takes a String numbers and an int sum. The method should calculate and return the minimum number of additions required to create an expression from numbers that evaluates to sum. If this is impossible, return -1.</p>

<h6 id="definition">Definition</h6>

<p>Class:    QuickSums <br>
Method:    minSums <br>
Parameters:    String, int <br>
Returns:    int <br>
Method signature:    int minSums(String numbers, int sum) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>numbers will contain between 1 and 10 characters, inclusive.</li>
<li>Each character in numbers will be a digit.</li>
<li>sum will be between 0 and 100, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"99999" <br>
45 <br>
Returns: 4 <br>
In this case, the only way to achieve 45 is to add 9+9+9+9+9. This requires 4 additions.</p></li>
<li><p>"1110" <br>
3 <br>
Returns: 3 <br>
Be careful with zeros. 1+1+1+0=3 and requires 3 additions.</p></li>
<li><p>"0123456789" <br>
45 <br>
Returns: 8</p></li>
<li><p>"99999" <br>
100 <br>
Returns: -1</p></li>
<li><p>"382834" <br>
100 <br>
Returns: 2 <br>
There are 3 ways to get 100. They are 38+28+34, 3+8+2+83+4 and 3+82+8+3+4. The minimum required is 2.</p></li>
<li><p>"9230560001" <br>
71 <br>
Returns: 4</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
#include &lt;cmath&gt;

using namespace std;

class QuickSums {  
    public:
        int minSums(string numbers, int sum) {
            int n = numbers.size() - 1;
            int limit = int(pow(2, n));
            int counter = 10;
            for (int i = 0; i &lt; limit; ++i) {
                bitset&lt;9&gt; plusPos(i);
                long long ans = 0;
                long long temp = numbers[0] - '0';
                for (int j = 1; j &lt; numbers.size(); ++j) {
                    if (plusPos[j - 1]) {
                        ans += temp;
                        temp = numbers[j] - '0';
                    } else {
                        temp *= 10;
                        temp += numbers[j] - '0';
                    }
                }
                ans += temp;
                if (ans == sum &amp;&amp; plusPos.count() &lt; counter) {
                    counter = plusPos.count();
                }
            }
            return (counter == 10 ? -1 : counter);
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/01/quicksums/</link><guid isPermaLink="false">a5e43d8b-2870-4bb1-b8e8-6501937eb179</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Mon, 01 Dec 2014 04:06:14 GMT</pubDate></item><item><title><![CDATA[PaperFold]]></title><description><![CDATA[<p>Used In:    SRM 162 <br>
Used As:    Division I Level One , Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You have a piece of paper that you need to fold to fit into a box with a given width and length. Each time you fold the paper, you can fold it in half across either its width or length, but you can only fold the paper 8 times (after 8 times, the paper is too dense to fold again).</p>

<p>You will be given a int[] paper, which contains the width and length of the paper in inches, and a int[] box, which contains the width and length of the box in inches. In both cases, the first element is the width and the second element is the length. Your method should return the fewest number of folds which would allow you to fit the paper into the box. You can rotate the paper 90 degrees if it will fit with fewer folds, but the paper must lie completely flat inside the box. If the paper cannot be fit into the box with 8 folds or fewer, return -1.</p>

<h6 id="definition">Definition</h6>

<p>Class:    PaperFold <br>
Method:    numFolds <br>
Parameters:    int[], int[] <br>
Returns:    int <br>
Method signature:    int numFolds(int[] paper, int[] box) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>After the paper is folded, it is possible that it has fractional dimensions.</li>
<li>The paper will fit into the box even if one or both of the dimensions are exactly the same as the corresponding box dimensions.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>paper will contain exactly two elements.</li>
<li>box will contain exactly two elements.</li>
<li>Each element of paper and box will be between 1 and 10000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{8, 11} <br>
{6, 10}
Returns: 1 <br>
By folding the paper so that the length is reduced from 11 to 5.5 inches, it will fit inside the box if you rotate it 90 degrees.</p></li>
<li><p>{11, 17} <br>
{6, 4}
Returns: 4 <br>
There are two ways to fold the paper so that it fits within the box.</p></li>
</ol>

<p>First, you could fold the width in half to get 5.5 inches, and then fold the length in half three times to get 2.125 inches.</p>

<p>Second, you could fold the width in half twice to get 2.25 inches, and then fold the length in half twice to get 4.25 inches. In this case, you must also rotate 90 degrees to fit the paper in.</p>

<ol>
<li><p>{11, 17} <br>
{5, 4}
Returns: 4 <br>
Now, you must use the second method to get it to fit: Fold the width and length each twice, and rotate 90 degrees. If you try fitting without rotating, it would take 5 folds.</p></li>
<li><p>{1000,1000} <br>
{62,63}
Returns: -1 <br>
Folding in each direction 4 times, you can get the paper down to 62.5 x 62.5. However, this will not fit into the box because neither dimension fits in 62.</p></li>
<li><p>{100,30} <br>
{60,110}
Returns: 0</p></li>
<li><p>{1895, 6416} <br>
{401, 1000}
Returns: 5</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

class PaperFold {

    private:
        bool fits(double pl, double pw, double bl, double bw) {
            if (pl &lt;= bl &amp;&amp; pw &lt;= bw) {
                return true;
            } else if (pl &lt;= bw &amp;&amp; pw &lt;= bl) {
                return true;
            } 
            return false;
        }

    public:
        int numFolds(vector&lt;int&gt; paper, vector&lt;int&gt; box) {
            vector&lt;pair&lt;double, double&gt; &gt; pos(512);
            pos[0] = make_pair(0, 0);
            pos[1] = make_pair(paper[0]*1.0, paper[1]*1.0);
            for (int i = 1; i &lt;= 255; ++i) {
                pos[i * 2] = make_pair(pos[i].first / 2.0, 
                             pos[i].second);
                pos[i * 2 + 1] = make_pair(pos[i].first, 
                                 pos[i].second / 2.0);
            }
            int ans = -1;
            for (int i = 1; i &lt;= 511; ++i) {
                if (fits(pos[i].first, pos[i].second, 
                    box[0]*1.0, box[1]*1.0)) {
                    ans = floor(log(i)/ log(2));
                    break;
                }
            }
            return ans;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/01/paperfold/</link><guid isPermaLink="false">f52e3fcd-2fd8-4b9d-956c-f288879bf1f8</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 20:30:05 GMT</pubDate></item><item><title><![CDATA[WordForm]]></title><description><![CDATA[<p>Used In:    SRM 173 <br>
Used As:    Division I Level One , Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>In English, the letters A, E, I, O and U are the vowels. Y is also considered to be a vowel if it's not preceded by another vowel and is not the first letter in a word (the fact that a vowel is defined to some extent in terms of itself does not make it ambiguous). If a letter is not a vowel then it is a consonant. So in "TOY" the consonants are T and Y, and in "SYZYGY" they are S, Z and G.</p>

<p>A sequence of vowels will be denoted by uppercase letter 'V' and a sequence of consonants will be denoted by uppercase letter 'C'. A word can then be described as an alternating sequence of 'C' and 'V'. For instance, the word "WHEREABOUTS" has the sequence CVCVCVC, and the words "YORK" and "TOY" both have the sequence CVC. It's not permissible to have two or more consecutive 'V' or 'C' in the sequence.</p>

<p>Create a class WordForm containing the method getSequence which takes a String word and returns a String containing the word's sequence as described above. The word may contain both uppercase and lowercase letters, but your method should be case insensitive (see example 2).</p>

<h6 id="definition">Definition</h6>

<p>Class:    WordForm <br>
Method:    getSequence <br>
Parameters:    String <br>
Returns:    String <br>
Method signature:    String getSequence(String word) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>word may not be an English word, or a word in any language at all, but you should still use the rules defined above. See example 3.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>word will contain between 1 and 50 characters, inclusive.</li>
<li>word will only contain the characters 'A'-'Z' and 'a'-'z', both inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"WHEREABOUTS" <br>
Returns: "CVCVCVC" <br>
Here we have consonant-consonant-vowel-consonant-vowel-vowel-consonant-vowel-vowel-consonant-consonant. Putting together consecutive consonants and vowels gives us CVCVCVC.</p></li>
<li><p>"yoghurt" <br>
Returns: "CVCVC"</p></li>
<li><p>"YipPy" <br>
Returns: "CVCV" <br>
Mixing lowercase and uppercase does not affect the result.</p></li>
<li><p>"AyYyEYye" <br>
Returns: "VCVCVCV" <br>
Even though this isn't an English word, we use the rules defined in the statement to find the consonant-vowel pattern.</p></li>
<li><p>"yC" <br>
Returns: "C"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

class WordForm {  
    private:
        bool isVowel(string s, int i, bool lastCharWasVowel) {
            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {
                return true;
            } else if (s[i] == 'y' &amp;&amp; i != 0 &amp;&amp; !lastCharWasVowel) {
                return true;
            }
            return false;
        }
    public:
        string getSequence(string word) {
            transform(word.begin(), word.end(), word.begin(), ::tolower);
            string seq = "";
            bool lastCharWasVowel = false;
            for (int i = 0; i &lt; word.size(); ++i) {
                if (isVowel(word, i , lastCharWasVowel)) {
                    seq += 'V';
                    lastCharWasVowel = true;
                } else {
                    seq += 'C';
                    lastCharWasVowel = false;
                }
            }
            string finalSeq = "";
            for (int i = 0; i &lt; seq.size(); ++i) {
                if (i == 0 || seq[i] != seq[i - 1]) {
                    finalSeq += seq[i];
                }
            }
            return finalSeq;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/wordform/</link><guid isPermaLink="false">456b88d7-a6dd-4ef9-b518-1651953291c5</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 18:10:25 GMT</pubDate></item><item><title><![CDATA[TallPeople]]></title><description><![CDATA[<p>Used In:    SRM 208 <br>
Used As:    Division I Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>A group of people stand before you arranged in rows and columns. Looking from above, they form an R by C rectangle of people. You will be given a String[] people containing the height of each person. Elements of people correspond to rows in the rectangle. Each element contains a space-delimited list of integers representing the heights of the people in that row. Your job is to return 2 specific heights in a int[]. The first is computed by finding the shortest person in each row, and then finding the tallest person among them (the "tallest-of-the-shortest"). The second is computed by finding the tallest person in each column, and then finding the shortest person among them (the "shortest-of-the-tallest").</p>

<h6 id="definition">Definition</h6>

<p>Class:    TallPeople <br>
Method:    getPeople <br>
Parameters:    String[] <br>
Returns:    int[] <br>
Method signature:    int[] getPeople(String[] people) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>people will contain between 2 and 50 elements inclusive.</li>
<li>Each element of people will contain between 3 and 50 characters inclusive.</li>
<li>Each element of people will be a single space-delimited list of positive integers such that: </li>
<li>Each positive integer is between 1 and 1000 inclusive with no extra leading zeros.</li>
<li>Each element contains the same number of integers.</li>
<li>Each element contains at least 2 positive integers.</li>
<li>Each element does not contain leading or trailing whitespace.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{"9 2 3", <br>
"4 8 7"}
Returns: { 4,  7 } <br>
The heights 2 and 4 are the shortest from the rows, so 4 is the taller of the two. The heights 9, 8, and 7 are the tallest from the columns, so 7 is the shortest of the 3.</p></li>
<li><p>{"1 2", <br>
"4 5",
"3 6"}
Returns: { 4,  4 }</p></li>
<li><p>{"1 1", <br>
"1 1"}
Returns: { 1,  1 }</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;

using namespace std;

class TallPeople {  
    public:
        vector&lt;int&gt; getPeople(vector&lt;string&gt; people) {
            vector&lt;vector&lt;int&gt; &gt; grid(people.size());
            for (int i = 0; i &lt; people.size(); ++i) {
                istringstream iss(people[i]);
                int n;
                while (iss &gt;&gt; n) {
                    grid[i].push_back(n);
                }
            }
            int tos = 0;
            for (int i = 0; i &lt; grid.size(); ++i) {
                int shortInRow = grid[i][0];
                for (int j = 1; j &lt; grid[i].size(); ++j) {
                    if (grid[i][j] &lt; shortInRow) {
                        shortInRow = grid[i][j];
                    }
                }
                if (shortInRow &gt; tos) {
                    tos = shortInRow;
                }
            }
            int sot = 10000;
            for (int i = 0; i &lt; grid[0].size(); ++i) {
                int tallestInColumn = grid[0][i];
                for (int j = 1; j &lt; grid.size(); ++j) {
                    if (grid[j][i] &gt; tallestInColumn) {
                        tallestInColumn = grid[j][i];
                    }
                }
                if (tallestInColumn &lt; sot) {
                    sot = tallestInColumn;
                }
            }
            vector&lt;int&gt; ans(2);
            ans[0] = tos, ans[1] = sot;
            return ans;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/tallpeople/</link><guid isPermaLink="false">e0b8eb11-f510-4350-ac79-bf6a0f38b70c</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 17:26:21 GMT</pubDate></item><item><title><![CDATA[CCipher]]></title><description><![CDATA[<p>Used In:    SRM 147 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Julius Caesar used a system of cryptography, now known as Caesar Cipher, which shifted each letter 2 places further through the alphabet (e.g. 'A' shifts to 'C', 'R' shifts to 'T', etc.). At the end of the alphabet we wrap around, that is 'Y' shifts to 'A'.</p>

<p>We can, of course, try shifting by any number. Given an encoded text and a number of places to shift, decode it.</p>

<p>For example, "TOPCODER" shifted by 2 places will be encoded as "VQREQFGT". In other words, if given (quotes for clarity) "VQREQFGT" and 2 as input, you will return "TOPCODER". See example 0 below.</p>

<h6 id="definition">Definition</h6>

<p>Class:    CCipher <br>
Method:    decode <br>
Parameters:    String, int <br>
Returns:    String <br>
Method signature:    String decode(String cipherText, int shift) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>cipherText has between 0 to 50 characters inclusive</li>
<li>each character of cipherText is an uppercase letter 'A'-'Z'</li>
<li>shift is between 0 and 25 inclusive</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"VQREQFGT" <br>
2 <br>
Returns: "TOPCODER"</p></li>
<li><p>"ABCDEFGHIJKLMNOPQRSTUVWXYZ" <br>
10 <br>
Returns: "QRSTUVWXYZABCDEFGHIJKLMNOP"</p></li>
<li><p>"TOPCODER" <br>
0 <br>
Returns: "TOPCODER"</p></li>
<li><p>"ZWBGLZ" <br>
25 <br>
Returns: "AXCHMA"</p></li>
<li><p>"DBNPCBQ" <br>
1 <br>
Returns: "CAMOBAP"</p></li>
<li><p>"LIPPSASVPH" <br>
4 <br>
Returns: "HELLOWORLD"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class CCipher {  
    private:
        int mod(int n, int m) {
            return n % m &lt; 0 ? n % m + m : n % m;
        }
    public:
        string  decode(string cipherText, int shift) {
            string original = "";
            for (int i = 0; i &lt; cipherText.size(); ++i) {
                original += 'A' + mod(cipherText[i] - 'A' - shift, 26);
            }
            return original;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/ccipher/</link><guid isPermaLink="false">8e0f378a-be43-4ab5-b543-a8ee2bebda7a</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 15:33:19 GMT</pubDate></item><item><title><![CDATA[Quipu]]></title><description><![CDATA[<p>Used In:    SRM 155 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>The Incas used a sophisticated system of record keeping consisting of bundles of knotted cords. Such a bundle of cords is called a quipu. Each individual cord represents a single number. Surprisingly, the Incas used a base-10 positional system, just like we do today. Each digit of a number is represented by a cluster of adjacent knots, with spaces between neighboring clusters. The digit is determined by the number of knots in the cluster. For example, the number 243 would be represented by a cord with knots tied in the following pattern</p>

<pre><code> -XX-XXXX-XXX-
</code></pre>

<p>where each uppercase 'X' represents a knot and each '-' represents an unknotted segment of cord (all quotes for clarity only).</p>

<p>Unlike many ancient civilizations, the Incas were aware of the concept of zero, and used it in their quipus. A zero is represented by a cluster containing no knots. For example, the number 204003 would be represented by a cord with knots tied in the following pattern</p>

<pre><code> -XX--XXXX---XXX-
    ^^    ^^^
    ^^    ^^^
    ^^    two zeros between these three segments
    ^^
    one zero between these two segments
</code></pre>

<p>Notice how adjacent dashes signal the presence of a zero. <br>
Your task is to translate a single quipu cord into an integer. The cord will be given as a String knots containing only the characters 'X' and '-'. There will be a single '-' between each cluster of 'X's, as well as a leading '-' and a trailing '-'. The first cluster will not be empty.</p>

<h6 id="definition">Definition</h6>

<p>Class:    Quipu <br>
Method:    readKnots <br>
Parameters:    String <br>
Returns:    int <br>
Method signature:    int readKnots(String knots) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>knots contains between 3 and 50 characters, inclusive.</li>
<li>knots contains only the characters 'X' and '-'. Note that 'X' is uppercase.</li>
<li>The first and last characters of knots are '-'s. The second character is 'X'.</li>
<li>knots does not contain 10 consecutive 'X's.</li>
<li>knots will represent a number between 1 and 1000000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"-XX-XXXX-XXX-" <br>
Returns: 243 <br>
The first example above.</p></li>
<li><p>"-XX--XXXX---XXX-" <br>
Returns: 204003 <br>
The second example above.</p></li>
<li><p>"-X-" <br>
Returns: 1</p></li>
<li><p>"-X-------" <br>
Returns: 1000000</p></li>
<li><p>"-XXXXXXXXX--XXXXXXXXX-XXXXXXXXX-XXXXXXX-XXXXXXXXX-" <br>
Returns: 909979</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Quipu {  
    public:
        int readKnots(string knots) {
            int countX = 0,
                num = 0;
            for (int i = 0; i &lt; knots.size(); ++i) {
                if (knots[i] == 'X') {
                    ++countX;
                } else {
                    num *= 10;
                    num += countX;
                    countX = 0;
                }
            }
            return num;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/quipu/</link><guid isPermaLink="false">d7e628c2-a900-435b-93fb-56a47ef9a54b</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 15:08:32 GMT</pubDate></item><item><title><![CDATA[PassingGrade]]></title><description><![CDATA[<p>Used In:    SRM 185 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You are studying for the final exam in a tough course, and want to know how many points you need to score on the final to pass the course. You know how many points you earned on each assignment (pointsEarned), how many points were possible on each assignment (pointsPossible), and how many points are possible on the final exam (finalExam). You need to earn a minimum of 65% of the total possible points to pass the course. Assume your score on the final exam will be an integral number of points between 0 and finalExam, inclusive. Return the number of points you need to score on the final to pass the course, or -1 if it is impossible for you to pass the course.</p>

<h6 id="definition">Definition</h6>

<p>Class:    PassingGrade <br>
Method:    pointsNeeded <br>
Parameters:    int[], int[], int <br>
Returns:    int <br>
Method signature:    int pointsNeeded(int[] pointsEarned, int[] pointsPossible, int finalExam) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>pointsEarned contains between 1 and 20 elements, inclusive.</li>
<li>pointsPossible contains the same number of elements as pointsEarned.</li>
<li>Each element of pointsPossible is between 1 and 1000, inclusive.</li>
<li>Element i of pointsEarned is between 0 and element i of pointsPossible, inclusive.</li>
<li>finalExam is between 1 and 3000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{55,77,82,60} <br>
{100,100,100,100}
300 <br>
Returns: 181 <br>
If you score 181 points on the final, then you will finish the course with exactly 65% of the possible points.</p></li>
<li><p>{ 1, 2, 3, 4 } <br>
{ 2, 3, 4, 5 }
7 <br>
Returns: 4 <br>
If you score 4 points on the final, then you pass with 66.7% of the total possible points, but if you score 3 points on the final, then you fail with 61.9% of the possible points.</p></li>
<li><p>{ 1, 2, 2, 1 } <br>
{ 9, 9, 9, 9 }
9 <br>
Returns: -1 <br>
Even if you score 9 points on the final, you still fail with 33.3% of the possible points.</p></li>
<li><p>{ 7, 8, 7, 6 } <br>
{ 8, 8, 8, 8 }
9 <br>
Returns: 0 <br>
You will pass even if you score 0 points on the final.</p></li>
<li><p>{ 17, 23, 50, 200, 19, 56, 83, 91, 77, 9, 0 } <br>
{ 20, 30, 50, 250, 20, 70, 100, 100, 100, 10, 10 }
400 <br>
Returns: 129</p></li>
<li><p>{600,600,600,600,600,600,600,600,600,600, <br>
600,600,600,600,600,600,600,600,600,600}
{1000,1000,1000,1000,1000,1000,1000,1000,
1000,1000,1000,1000,1000,1000,1000,1000,
1000,1000,1000,901}
3000 <br>
Returns: 2886</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

using namespace std;

class PassingGrade {  
    public:
        int pointsNeeded (vector&lt;int&gt; pointsEarned, vector&lt;int&gt; pointsPossible, int finalExam) {
            int totalEarned = accumulate(pointsEarned.begin(), 
                              pointsEarned.end(), 0);
            int totalPossible = accumulate(pointsPossible.begin(), 
                                pointsPossible.end(), finalExam);
            int required = ceil(totalPossible * 0.65);
            if (required - totalEarned &gt; finalExam) {
                return -1;
            } 
            return max(0, required - totalEarned);
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/passinggrade/</link><guid isPermaLink="false">ccc63d54-9c8e-4f89-9b6b-6ffc0c500bf9</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 14:35:38 GMT</pubDate></item><item><title><![CDATA[NoOrderOfOperations]]></title><description><![CDATA[<p>Used In:    SRM 200 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>When evaluating a mathematical expression, there is the possibility of ambiguity. If you wanted to know the result of "3 + 5 * 7", you might first evaluate the (3+5) and get 56, or first evaluate the (5*7) and get 38. This ambiguity can be resolved by using the order of operations: first do multiplication and division (from left to right), and then after all those are done, do addition and subtraction (again from left to right). Here, the correct result would be the 38.</p>

<p>While this is unambiguous, it certainly is somewhat annoying. You think it would be easier if people did all math from left to right, all the time, and want to make a simple expression evaluator to do so.</p>

<p>The expression will be given to you as a String expr. It will consist of one digit numbers (0 through 9) alternating with operators (+, -, or *), with no spaces between them. Thus, expr would follow the format Digit Operator Digit Operator .... Digit. For example, the expression given above would be given as "3+5*7".</p>

<p>Your method should return an int representing the value of the expression when evaluated from left to right.</p>

<h6 id="definition">Definition</h6>

<p>Class:    NoOrderOfOperations <br>
Method:    evaluate <br>
Parameters:    String <br>
Returns:    int <br>
Method signature:    int evaluate(String expr) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>expr will be between 1 and 17 characters in length, inclusive.</li>
<li>expr will contain an odd number of characters.</li>
<li>expr will follow the format Digit Operator Digit Operator ... Digit, where each Digit is a single character from '0' to '9', and each Operator is either +, -, or *.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"3+5*7" <br>
Returns: 56 <br>
First we add 3 + 5 to get 8. Then, we multiply 8 by 7 to get 56.</p></li>
<li><p>"4-8*9*1" <br>
Returns: -36 <br>
Results can be negative.</p></li>
<li><p>"0" <br>
Returns: 0</p></li>
<li><p>"1*2*3*4*5*6*7*8*9" <br>
Returns: 362880</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class NoOrderOfOperations {  
    public:
        int evaluate(string expr) {
            char op = '+';
            int ans = 0;
            for (int i = 0; i &lt; expr.size(); ++i) {
                if (expr[i] &gt;= '0' &amp;&amp; expr[i] &lt;= '9') {
                    if (op == '+') {
                        ans += (expr[i] - '0');
                    } else if (op == '-') {
                        ans -= (expr[i] - '0');
                    } else if (op == '*') {
                        ans *= (expr[i] - '0');
                    } else if (op == '/') {
                        ans /= (expr[i] - '0');
                    }
                } else {
                    op = expr[i];
                }
            }
            return ans;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/noorderofoperations/</link><guid isPermaLink="false">f24d48f1-a658-4d19-b7ee-0754106d783e</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 11:38:04 GMT</pubDate></item><item><title><![CDATA[Yahtzee]]></title><description><![CDATA[<p>Used In:    SRM 146 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>This task is about the scoring in the first phase of the die-game Yahtzee, where five dice are used. The score is determined by the values on the upward die faces after a roll. The player gets to choose a value, and all dice that show the chosen value are considered active. The score is simply the sum of values on active dice.</p>

<p>Say, for instance, that a player ends up with the die faces showing 2, 2, 3, 5 and 4. Choosing the value two makes the dice showing 2 active and yields a score of 2 + 2 = 4, while choosing 5 makes the one die showing 5 active, yielding a score of 5.</p>

<p>Your method will take as input an int[] toss, where each element represents the upward face of a die, and return the maximum possible score with these values.</p>

<h6 id="definition">Definition</h6>

<p>Class:    YahtzeeScore <br>
Method:    maxPoints <br>
Parameters:    int[] <br>
Returns:    int <br>
Method signature:    int maxPoints(int[] toss) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>toss will contain exactly 5 elements.</li>
<li>Each element of toss will be between 1 and 6, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{ 2, 2, 3, 5, 4 } <br>
Returns: 5 <br>
The example from the text.</p></li>
<li><p>{ 6, 4, 1, 1, 3 } <br>
Returns: 6 <br>
Selecting 1 as active yields 1 + 1 = 2, selecting 3 yields 3, selecting 4 yields 4 and selecting 6 yields 6, which is the maximum number of points.</p></li>
<li><p>{ 5, 3, 5, 3, 3 } <br>
Returns: 10</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

class YahtzeeScore {  
    public:
        int maxPoints(vector&lt;int&gt; toss) {
            vector&lt;int&gt; sum(7, 0);
            for (int i = 0; i &lt; 5; ++i) {
                sum[toss[i]] += toss[i];
            }
            return *max_element(sum.begin(), sum.end());
        }   
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/yahtzee/</link><guid isPermaLink="false">8d1b1abb-1fbf-4698-a399-c75134b67896</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 11:15:17 GMT</pubDate></item><item><title><![CDATA[Poetry]]></title><description><![CDATA[<p>Used In:    SRM 170 <br>
Used As:    Division II Level Three</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Given a poem, determine its rhyme scheme.</p>

<p>To simplify things, because English is such a fickle language, there are some constraints:</p>

<p>A legal word is a sequence of lower or uppercase letters, containing at least one vowel, where a vowel is 'a', 'e', 'i', 'o', or 'u'. Also, 'y' is considered a vowel if it is not at the start or end of a word. Words are delimited by spaces.</p>

<p>Two words are considered rhyming if they have the same ending pattern (defined below). This comparison is case-insensitive (see Example 1.)</p>

<p>An ending pattern is a substring of a word such that:</p>

<p>The word ends with that substring, <br>
The substring contains exactly one contiguous string of vowels, <br>
The first letter of the substring is a vowel, and <br>
The substring must either be the whole string, or the letter immediately preceding the start of the substring must be a nonvowel. <br>
For example, the ending pattern of "bought" is "ought", the ending pattern of "spying" would be "ying", and the ending pattern of "all" would be "all". (Note that "spy" has no vowels, and thus is not a legal word.)</p>

<p>Two lines rhyme if their corresponding last words rhyme, and a line is empty if it contains no words.</p>

<p>The procedure for determinining rhyme scheme is as follows: The first non-empty line in the poem should be labeled with the lowercase letter 'a'. Every line that rhymes with that line should also be labeled with that letter. The next unlabeled non-empty line should be labeled with the letter 'b', and any rhyming lines should also be labeled in this manner. When you run out of lowercase letters, continue by using the uppercase letters 'A' to 'Z'. Empty lines should be labeled with ' ' (the space character).</p>

<p>The 0th character of the returned String should be the rhyme scheme label of the 0th line, the 1st character should be the label of the 1st line, and so on. This means that the returned String will have the same number of characters as there are elements in poem. Thus, given a String[] poem, then your method should return a String detailing the rhyme scheme.</p>

<h6 id="definition">Definition</h6>

<p>Class:    Poetry <br>
Method:    rhymeScheme <br>
Parameters:    String[] <br>
Returns:    String <br>
Method signature:    String rhymeScheme(String[] poem) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>If there is a blank line in the poem, there must be a corresponding space in the output. A blank line is one with no words. (See Example 1.)</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>poem will have between 1 and 50 elements, inclusive.</li>
<li>each element of poem will contain between 0 and 50 characters, inclusive.</li>
<li>the only allowable characters in poem will be upper and lowercase characters ('a'-'z' and 'A'-'Z') and the space character (' ').</li>
<li>there will be only legal words in poem</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{"I hope this problem", <br>
"is a whole lot better than",
"this stupid haiku"}
Returns: "abc" <br>
Doesn't even conceivably rhyme.</p></li>
<li><p>{"     ", <br>
"Measure your height",
"AND WEIGHT      ",
"said the doctor",
"",
"And make sure to take your pills",
"   to   cure   your    ills",
"Every",
"DAY"}
Returns: " aab ccde" <br>
Even though "height" and "weight" don't actually rhyme in English, they do by the rules laid out above.</p></li>
<li><p>{"One bright day in the middle of the night", <br>
"Two dead boys got up to fight",
"Back to back they faced each other",
"Drew their swords and shot each other",
"",
"A deaf policeman heard the noise",
"And came to arrest the two dead boys",
"And if you dont believe this lie is true",
"Ask the blind man he saw it too"}
Returns: "aabb cdef"</p></li>
<li><p>{"", <br>
"",
"",
""}
Returns: "    " <br>
Four lines from the mind of a blank poet.</p></li>
<li><p>{"This poem has uppercase letters", <br>
"In its rhyme scheme",
"Alpha", "Blaster", "Cat", "Desert", "Elephant", "Frog", "Gulch", 
"Horse", "Ireland", "Jam", "Krispy Kreme", "Loofah", "Moo", "Narf",
"Old", "Pink", "Quash", "Rainbow", "Star", "Tour", "Uvula", "Very",
"Will", "Xmas", "Young", "Zed", "deception", "comic", "grout",
"oval", "cable", "rob", "steal", "steel", "weak"}
Returns: "abcdefghibjkblmnopqrstcuvwxyzABCbDEFG"</p></li>
<li><p>{" ", <br>
"     ",
"This poem",
"         ",
" ",
" ",
"",
"Has lots of blank lines",
" ",
"      ",
"                                            ",
"         ",
" ",
"              ",
"                                                  ",
"  in      it           "}
Returns: "  a    b       c"</p></li>
<li><p>{"too bad   your", <br>
"     solution went   sour"}
Returns: "aa"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

using namespace std;

class Poetry {  
    private:
        bool isVowel(string s, int i) {
            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {
                return true;
            } else if (s[i] == 'y' &amp;&amp; i != 0 &amp;&amp; i != s.size() - 1) {
                return true;
            }
            return false;
        }
        string endPattern(string s) {
            string ep = "";
            bool flag = true;
            for (int i = s.size() - 1; i &gt;= 0; --i) {
                bool v = isVowel(s, i); 
                if (v) {
                    flag = false;
                }
                if (v || flag) {
                    ep = s[i] + ep;
                } else {
                    break;
                }
            }
            return ep;
        }
        bool isEmptyString(string s) {
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] != ' ') {
                    return false;
                }
            }
            return true;
        }
        string lastWord(string s) {
            istringstream iss(s);
            string lw;
            while (iss &gt;&gt; lw);
            return lw;
        }
    public:
        string rhymeScheme(vector&lt;string&gt; poem) {
            vector&lt;char&gt; rhymingSeq;
            for (char i = 'a'; i &lt;= 'z'; ++i) {
                rhymingSeq.push_back(i);
            }
            for (char i = 'A'; i &lt;= 'Z'; ++i) {
                rhymingSeq.push_back(i);
            }
            map&lt;string, char&gt; pattern;
            string scheme = "";
            int seq = 0;
            for (int i = 0; i &lt; poem.size(); ++i) {
                transform(poem[i].begin(), poem[i].end(), poem[i].begin(), ::tolower);
                if (!isEmptyString(poem[i])) {
                    string ep = endPattern(lastWord(poem[i]));
                    if (pattern.find(ep) == pattern.end()) {
                        pattern[ep] = rhymingSeq[seq++];
                    }
                    scheme += pattern[ep];
                } else {
                    scheme += " ";
                }
            }
            return scheme;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/poetry/</link><guid isPermaLink="false">7b987ce1-2551-4210-9070-76a824bb2ab6</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 10:25:31 GMT</pubDate></item></channel></rss>