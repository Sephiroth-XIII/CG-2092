<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Chintan Ghate - Code Jedi]]></title><description><![CDATA[Code, algorithms and design.]]></description><link>http://code-jedi.chintanghate.me/</link><generator>Ghost 0.5</generator><lastBuildDate>Sun, 30 Nov 2014 20:35:37 GMT</lastBuildDate><atom:link href="http://code-jedi.chintanghate.me/author/chintan/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[PaperFold]]></title><description><![CDATA[<p>Used In:    SRM 162 <br>
Used As:    Division I Level One , Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You have a piece of paper that you need to fold to fit into a box with a given width and length. Each time you fold the paper, you can fold it in half across either its width or length, but you can only fold the paper 8 times (after 8 times, the paper is too dense to fold again).</p>

<p>You will be given a int[] paper, which contains the width and length of the paper in inches, and a int[] box, which contains the width and length of the box in inches. In both cases, the first element is the width and the second element is the length. Your method should return the fewest number of folds which would allow you to fit the paper into the box. You can rotate the paper 90 degrees if it will fit with fewer folds, but the paper must lie completely flat inside the box. If the paper cannot be fit into the box with 8 folds or fewer, return -1.</p>

<h6 id="definition">Definition</h6>

<p>Class:    PaperFold <br>
Method:    numFolds <br>
Parameters:    int[], int[] <br>
Returns:    int <br>
Method signature:    int numFolds(int[] paper, int[] box) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>After the paper is folded, it is possible that it has fractional dimensions.</li>
<li>The paper will fit into the box even if one or both of the dimensions are exactly the same as the corresponding box dimensions.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>paper will contain exactly two elements.</li>
<li>box will contain exactly two elements.</li>
<li>Each element of paper and box will be between 1 and 10000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{8, 11} <br>
{6, 10}
Returns: 1 <br>
By folding the paper so that the length is reduced from 11 to 5.5 inches, it will fit inside the box if you rotate it 90 degrees.</p></li>
<li><p>{11, 17} <br>
{6, 4}
Returns: 4 <br>
There are two ways to fold the paper so that it fits within the box.</p></li>
</ol>

<p>First, you could fold the width in half to get 5.5 inches, and then fold the length in half three times to get 2.125 inches.</p>

<p>Second, you could fold the width in half twice to get 2.25 inches, and then fold the length in half twice to get 4.25 inches. In this case, you must also rotate 90 degrees to fit the paper in.</p>

<ol>
<li><p>{11, 17} <br>
{5, 4}
Returns: 4 <br>
Now, you must use the second method to get it to fit: Fold the width and length each twice, and rotate 90 degrees. If you try fitting without rotating, it would take 5 folds.</p></li>
<li><p>{1000,1000} <br>
{62,63}
Returns: -1 <br>
Folding in each direction 4 times, you can get the paper down to 62.5 x 62.5. However, this will not fit into the box because neither dimension fits in 62.</p></li>
<li><p>{100,30} <br>
{60,110}
Returns: 0</p></li>
<li><p>{1895, 6416} <br>
{401, 1000}
Returns: 5</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

class PaperFold {

    private:
        bool fits(double pl, double pw, double bl, double bw) {
            if (pl &lt;= bl &amp;&amp; pw &lt;= bw) {
                return true;
            } else if (pl &lt;= bw &amp;&amp; pw &lt;= bl) {
                return true;
            } 
            return false;
        }

    public:
        int numFolds(vector&lt;int&gt; paper, vector&lt;int&gt; box) {
            vector&lt;pair&lt;double, double&gt; &gt; pos(512);
            pos[0] = make_pair(0, 0);
            pos[1] = make_pair(paper[0]*1.0, paper[1]*1.0);
            for (int i = 1; i &lt;= 255; ++i) {
                pos[i * 2] = make_pair(pos[i].first / 2.0, 
                             pos[i].second);
                pos[i * 2 + 1] = make_pair(pos[i].first, 
                                 pos[i].second / 2.0);
            }
            int ans = -1;
            for (int i = 1; i &lt;= 511; ++i) {
                if (fits(pos[i].first, pos[i].second, 
                    box[0]*1.0, box[1]*1.0)) {
                    ans = floor(log(i)/ log(2));
                    break;
                }
            }
            return ans;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/01/paperfold/</link><guid isPermaLink="false">f52e3fcd-2fd8-4b9d-956c-f288879bf1f8</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 20:30:05 GMT</pubDate></item><item><title><![CDATA[WordForm]]></title><description><![CDATA[<p>Used In:    SRM 173 <br>
Used As:    Division I Level One , Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>In English, the letters A, E, I, O and U are the vowels. Y is also considered to be a vowel if it's not preceded by another vowel and is not the first letter in a word (the fact that a vowel is defined to some extent in terms of itself does not make it ambiguous). If a letter is not a vowel then it is a consonant. So in "TOY" the consonants are T and Y, and in "SYZYGY" they are S, Z and G.</p>

<p>A sequence of vowels will be denoted by uppercase letter 'V' and a sequence of consonants will be denoted by uppercase letter 'C'. A word can then be described as an alternating sequence of 'C' and 'V'. For instance, the word "WHEREABOUTS" has the sequence CVCVCVC, and the words "YORK" and "TOY" both have the sequence CVC. It's not permissible to have two or more consecutive 'V' or 'C' in the sequence.</p>

<p>Create a class WordForm containing the method getSequence which takes a String word and returns a String containing the word's sequence as described above. The word may contain both uppercase and lowercase letters, but your method should be case insensitive (see example 2).</p>

<h6 id="definition">Definition</h6>

<p>Class:    WordForm <br>
Method:    getSequence <br>
Parameters:    String <br>
Returns:    String <br>
Method signature:    String getSequence(String word) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>word may not be an English word, or a word in any language at all, but you should still use the rules defined above. See example 3.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>word will contain between 1 and 50 characters, inclusive.</li>
<li>word will only contain the characters 'A'-'Z' and 'a'-'z', both inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"WHEREABOUTS" <br>
Returns: "CVCVCVC" <br>
Here we have consonant-consonant-vowel-consonant-vowel-vowel-consonant-vowel-vowel-consonant-consonant. Putting together consecutive consonants and vowels gives us CVCVCVC.</p></li>
<li><p>"yoghurt" <br>
Returns: "CVCVC"</p></li>
<li><p>"YipPy" <br>
Returns: "CVCV" <br>
Mixing lowercase and uppercase does not affect the result.</p></li>
<li><p>"AyYyEYye" <br>
Returns: "VCVCVCV" <br>
Even though this isn't an English word, we use the rules defined in the statement to find the consonant-vowel pattern.</p></li>
<li><p>"yC" <br>
Returns: "C"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

class WordForm {  
    private:
        bool isVowel(string s, int i, bool lastCharWasVowel) {
            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {
                return true;
            } else if (s[i] == 'y' &amp;&amp; i != 0 &amp;&amp; !lastCharWasVowel) {
                return true;
            }
            return false;
        }
    public:
        string getSequence(string word) {
            transform(word.begin(), word.end(), word.begin(), ::tolower);
            string seq = "";
            bool lastCharWasVowel = false;
            for (int i = 0; i &lt; word.size(); ++i) {
                if (isVowel(word, i , lastCharWasVowel)) {
                    seq += 'V';
                    lastCharWasVowel = true;
                } else {
                    seq += 'C';
                    lastCharWasVowel = false;
                }
            }
            string finalSeq = "";
            for (int i = 0; i &lt; seq.size(); ++i) {
                if (i == 0 || seq[i] != seq[i - 1]) {
                    finalSeq += seq[i];
                }
            }
            return finalSeq;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/wordform/</link><guid isPermaLink="false">456b88d7-a6dd-4ef9-b518-1651953291c5</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 18:10:25 GMT</pubDate></item><item><title><![CDATA[TallPeople]]></title><description><![CDATA[<p>Used In:    SRM 208 <br>
Used As:    Division I Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>A group of people stand before you arranged in rows and columns. Looking from above, they form an R by C rectangle of people. You will be given a String[] people containing the height of each person. Elements of people correspond to rows in the rectangle. Each element contains a space-delimited list of integers representing the heights of the people in that row. Your job is to return 2 specific heights in a int[]. The first is computed by finding the shortest person in each row, and then finding the tallest person among them (the "tallest-of-the-shortest"). The second is computed by finding the tallest person in each column, and then finding the shortest person among them (the "shortest-of-the-tallest").</p>

<h6 id="definition">Definition</h6>

<p>Class:    TallPeople <br>
Method:    getPeople <br>
Parameters:    String[] <br>
Returns:    int[] <br>
Method signature:    int[] getPeople(String[] people) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>people will contain between 2 and 50 elements inclusive.</li>
<li>Each element of people will contain between 3 and 50 characters inclusive.</li>
<li>Each element of people will be a single space-delimited list of positive integers such that: </li>
<li>Each positive integer is between 1 and 1000 inclusive with no extra leading zeros.</li>
<li>Each element contains the same number of integers.</li>
<li>Each element contains at least 2 positive integers.</li>
<li>Each element does not contain leading or trailing whitespace.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{"9 2 3", <br>
"4 8 7"}
Returns: { 4,  7 } <br>
The heights 2 and 4 are the shortest from the rows, so 4 is the taller of the two. The heights 9, 8, and 7 are the tallest from the columns, so 7 is the shortest of the 3.</p></li>
<li><p>{"1 2", <br>
"4 5",
"3 6"}
Returns: { 4,  4 }</p></li>
<li><p>{"1 1", <br>
"1 1"}
Returns: { 1,  1 }</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;

using namespace std;

class TallPeople {  
    public:
        vector&lt;int&gt; getPeople(vector&lt;string&gt; people) {
            vector&lt;vector&lt;int&gt; &gt; grid(people.size());
            for (int i = 0; i &lt; people.size(); ++i) {
                istringstream iss(people[i]);
                int n;
                while (iss &gt;&gt; n) {
                    grid[i].push_back(n);
                }
            }
            int tos = 0;
            for (int i = 0; i &lt; grid.size(); ++i) {
                int shortInRow = grid[i][0];
                for (int j = 1; j &lt; grid[i].size(); ++j) {
                    if (grid[i][j] &lt; shortInRow) {
                        shortInRow = grid[i][j];
                    }
                }
                if (shortInRow &gt; tos) {
                    tos = shortInRow;
                }
            }
            int sot = 10000;
            for (int i = 0; i &lt; grid[0].size(); ++i) {
                int tallestInColumn = grid[0][i];
                for (int j = 1; j &lt; grid.size(); ++j) {
                    if (grid[j][i] &gt; tallestInColumn) {
                        tallestInColumn = grid[j][i];
                    }
                }
                if (tallestInColumn &lt; sot) {
                    sot = tallestInColumn;
                }
            }
            vector&lt;int&gt; ans(2);
            ans[0] = tos, ans[1] = sot;
            return ans;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/tallpeople/</link><guid isPermaLink="false">e0b8eb11-f510-4350-ac79-bf6a0f38b70c</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 17:26:21 GMT</pubDate></item><item><title><![CDATA[CCipher]]></title><description><![CDATA[<p>Used In:    SRM 147 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Julius Caesar used a system of cryptography, now known as Caesar Cipher, which shifted each letter 2 places further through the alphabet (e.g. 'A' shifts to 'C', 'R' shifts to 'T', etc.). At the end of the alphabet we wrap around, that is 'Y' shifts to 'A'.</p>

<p>We can, of course, try shifting by any number. Given an encoded text and a number of places to shift, decode it.</p>

<p>For example, "TOPCODER" shifted by 2 places will be encoded as "VQREQFGT". In other words, if given (quotes for clarity) "VQREQFGT" and 2 as input, you will return "TOPCODER". See example 0 below.</p>

<h6 id="definition">Definition</h6>

<p>Class:    CCipher <br>
Method:    decode <br>
Parameters:    String, int <br>
Returns:    String <br>
Method signature:    String decode(String cipherText, int shift) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>cipherText has between 0 to 50 characters inclusive</li>
<li>each character of cipherText is an uppercase letter 'A'-'Z'</li>
<li>shift is between 0 and 25 inclusive</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"VQREQFGT" <br>
2 <br>
Returns: "TOPCODER"</p></li>
<li><p>"ABCDEFGHIJKLMNOPQRSTUVWXYZ" <br>
10 <br>
Returns: "QRSTUVWXYZABCDEFGHIJKLMNOP"</p></li>
<li><p>"TOPCODER" <br>
0 <br>
Returns: "TOPCODER"</p></li>
<li><p>"ZWBGLZ" <br>
25 <br>
Returns: "AXCHMA"</p></li>
<li><p>"DBNPCBQ" <br>
1 <br>
Returns: "CAMOBAP"</p></li>
<li><p>"LIPPSASVPH" <br>
4 <br>
Returns: "HELLOWORLD"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class CCipher {  
    private:
        int mod(int n, int m) {
            return n % m &lt; 0 ? n % m + m : n % m;
        }
    public:
        string  decode(string cipherText, int shift) {
            string original = "";
            for (int i = 0; i &lt; cipherText.size(); ++i) {
                original += 'A' + mod(cipherText[i] - 'A' - shift, 26);
            }
            return original;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/ccipher/</link><guid isPermaLink="false">8e0f378a-be43-4ab5-b543-a8ee2bebda7a</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 15:33:19 GMT</pubDate></item><item><title><![CDATA[Quipu]]></title><description><![CDATA[<p>Used In:    SRM 155 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>The Incas used a sophisticated system of record keeping consisting of bundles of knotted cords. Such a bundle of cords is called a quipu. Each individual cord represents a single number. Surprisingly, the Incas used a base-10 positional system, just like we do today. Each digit of a number is represented by a cluster of adjacent knots, with spaces between neighboring clusters. The digit is determined by the number of knots in the cluster. For example, the number 243 would be represented by a cord with knots tied in the following pattern</p>

<pre><code> -XX-XXXX-XXX-
</code></pre>

<p>where each uppercase 'X' represents a knot and each '-' represents an unknotted segment of cord (all quotes for clarity only).</p>

<p>Unlike many ancient civilizations, the Incas were aware of the concept of zero, and used it in their quipus. A zero is represented by a cluster containing no knots. For example, the number 204003 would be represented by a cord with knots tied in the following pattern</p>

<pre><code> -XX--XXXX---XXX-
    ^^    ^^^
    ^^    ^^^
    ^^    two zeros between these three segments
    ^^
    one zero between these two segments
</code></pre>

<p>Notice how adjacent dashes signal the presence of a zero. <br>
Your task is to translate a single quipu cord into an integer. The cord will be given as a String knots containing only the characters 'X' and '-'. There will be a single '-' between each cluster of 'X's, as well as a leading '-' and a trailing '-'. The first cluster will not be empty.</p>

<h6 id="definition">Definition</h6>

<p>Class:    Quipu <br>
Method:    readKnots <br>
Parameters:    String <br>
Returns:    int <br>
Method signature:    int readKnots(String knots) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>knots contains between 3 and 50 characters, inclusive.</li>
<li>knots contains only the characters 'X' and '-'. Note that 'X' is uppercase.</li>
<li>The first and last characters of knots are '-'s. The second character is 'X'.</li>
<li>knots does not contain 10 consecutive 'X's.</li>
<li>knots will represent a number between 1 and 1000000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"-XX-XXXX-XXX-" <br>
Returns: 243 <br>
The first example above.</p></li>
<li><p>"-XX--XXXX---XXX-" <br>
Returns: 204003 <br>
The second example above.</p></li>
<li><p>"-X-" <br>
Returns: 1</p></li>
<li><p>"-X-------" <br>
Returns: 1000000</p></li>
<li><p>"-XXXXXXXXX--XXXXXXXXX-XXXXXXXXX-XXXXXXX-XXXXXXXXX-" <br>
Returns: 909979</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Quipu {  
    public:
        int readKnots(string knots) {
            int countX = 0,
                num = 0;
            for (int i = 0; i &lt; knots.size(); ++i) {
                if (knots[i] == 'X') {
                    ++countX;
                } else {
                    num *= 10;
                    num += countX;
                    countX = 0;
                }
            }
            return num;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/quipu/</link><guid isPermaLink="false">d7e628c2-a900-435b-93fb-56a47ef9a54b</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 15:08:32 GMT</pubDate></item><item><title><![CDATA[PassingGrade]]></title><description><![CDATA[<p>Used In:    SRM 185 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You are studying for the final exam in a tough course, and want to know how many points you need to score on the final to pass the course. You know how many points you earned on each assignment (pointsEarned), how many points were possible on each assignment (pointsPossible), and how many points are possible on the final exam (finalExam). You need to earn a minimum of 65% of the total possible points to pass the course. Assume your score on the final exam will be an integral number of points between 0 and finalExam, inclusive. Return the number of points you need to score on the final to pass the course, or -1 if it is impossible for you to pass the course.</p>

<h6 id="definition">Definition</h6>

<p>Class:    PassingGrade <br>
Method:    pointsNeeded <br>
Parameters:    int[], int[], int <br>
Returns:    int <br>
Method signature:    int pointsNeeded(int[] pointsEarned, int[] pointsPossible, int finalExam) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>pointsEarned contains between 1 and 20 elements, inclusive.</li>
<li>pointsPossible contains the same number of elements as pointsEarned.</li>
<li>Each element of pointsPossible is between 1 and 1000, inclusive.</li>
<li>Element i of pointsEarned is between 0 and element i of pointsPossible, inclusive.</li>
<li>finalExam is between 1 and 3000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{55,77,82,60} <br>
{100,100,100,100}
300 <br>
Returns: 181 <br>
If you score 181 points on the final, then you will finish the course with exactly 65% of the possible points.</p></li>
<li><p>{ 1, 2, 3, 4 } <br>
{ 2, 3, 4, 5 }
7 <br>
Returns: 4 <br>
If you score 4 points on the final, then you pass with 66.7% of the total possible points, but if you score 3 points on the final, then you fail with 61.9% of the possible points.</p></li>
<li><p>{ 1, 2, 2, 1 } <br>
{ 9, 9, 9, 9 }
9 <br>
Returns: -1 <br>
Even if you score 9 points on the final, you still fail with 33.3% of the possible points.</p></li>
<li><p>{ 7, 8, 7, 6 } <br>
{ 8, 8, 8, 8 }
9 <br>
Returns: 0 <br>
You will pass even if you score 0 points on the final.</p></li>
<li><p>{ 17, 23, 50, 200, 19, 56, 83, 91, 77, 9, 0 } <br>
{ 20, 30, 50, 250, 20, 70, 100, 100, 100, 10, 10 }
400 <br>
Returns: 129</p></li>
<li><p>{600,600,600,600,600,600,600,600,600,600, <br>
600,600,600,600,600,600,600,600,600,600}
{1000,1000,1000,1000,1000,1000,1000,1000,
1000,1000,1000,1000,1000,1000,1000,1000,
1000,1000,1000,901}
3000 <br>
Returns: 2886</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

using namespace std;

class PassingGrade {  
    public:
        int pointsNeeded (vector&lt;int&gt; pointsEarned, vector&lt;int&gt; pointsPossible, int finalExam) {
            int totalEarned = accumulate(pointsEarned.begin(), 
                              pointsEarned.end(), 0);
            int totalPossible = accumulate(pointsPossible.begin(), 
                                pointsPossible.end(), finalExam);
            int required = ceil(totalPossible * 0.65);
            if (required - totalEarned &gt; finalExam) {
                return -1;
            } 
            return max(0, required - totalEarned);
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/passinggrade/</link><guid isPermaLink="false">ccc63d54-9c8e-4f89-9b6b-6ffc0c500bf9</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 14:35:38 GMT</pubDate></item><item><title><![CDATA[NoOrderOfOperations]]></title><description><![CDATA[<p>Used In:    SRM 200 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>When evaluating a mathematical expression, there is the possibility of ambiguity. If you wanted to know the result of "3 + 5 * 7", you might first evaluate the (3+5) and get 56, or first evaluate the (5*7) and get 38. This ambiguity can be resolved by using the order of operations: first do multiplication and division (from left to right), and then after all those are done, do addition and subtraction (again from left to right). Here, the correct result would be the 38.</p>

<p>While this is unambiguous, it certainly is somewhat annoying. You think it would be easier if people did all math from left to right, all the time, and want to make a simple expression evaluator to do so.</p>

<p>The expression will be given to you as a String expr. It will consist of one digit numbers (0 through 9) alternating with operators (+, -, or *), with no spaces between them. Thus, expr would follow the format Digit Operator Digit Operator .... Digit. For example, the expression given above would be given as "3+5*7".</p>

<p>Your method should return an int representing the value of the expression when evaluated from left to right.</p>

<h6 id="definition">Definition</h6>

<p>Class:    NoOrderOfOperations <br>
Method:    evaluate <br>
Parameters:    String <br>
Returns:    int <br>
Method signature:    int evaluate(String expr) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>expr will be between 1 and 17 characters in length, inclusive.</li>
<li>expr will contain an odd number of characters.</li>
<li>expr will follow the format Digit Operator Digit Operator ... Digit, where each Digit is a single character from '0' to '9', and each Operator is either +, -, or *.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"3+5*7" <br>
Returns: 56 <br>
First we add 3 + 5 to get 8. Then, we multiply 8 by 7 to get 56.</p></li>
<li><p>"4-8*9*1" <br>
Returns: -36 <br>
Results can be negative.</p></li>
<li><p>"0" <br>
Returns: 0</p></li>
<li><p>"1*2*3*4*5*6*7*8*9" <br>
Returns: 362880</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class NoOrderOfOperations {  
    public:
        int evaluate(string expr) {
            char op = '+';
            int ans = 0;
            for (int i = 0; i &lt; expr.size(); ++i) {
                if (expr[i] &gt;= '0' &amp;&amp; expr[i] &lt;= '9') {
                    if (op == '+') {
                        ans += (expr[i] - '0');
                    } else if (op == '-') {
                        ans -= (expr[i] - '0');
                    } else if (op == '*') {
                        ans *= (expr[i] - '0');
                    } else if (op == '/') {
                        ans /= (expr[i] - '0');
                    }
                } else {
                    op = expr[i];
                }
            }
            return ans;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/noorderofoperations/</link><guid isPermaLink="false">f24d48f1-a658-4d19-b7ee-0754106d783e</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 11:38:04 GMT</pubDate></item><item><title><![CDATA[Yahtzee]]></title><description><![CDATA[<p>Used In:    SRM 146 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>This task is about the scoring in the first phase of the die-game Yahtzee, where five dice are used. The score is determined by the values on the upward die faces after a roll. The player gets to choose a value, and all dice that show the chosen value are considered active. The score is simply the sum of values on active dice.</p>

<p>Say, for instance, that a player ends up with the die faces showing 2, 2, 3, 5 and 4. Choosing the value two makes the dice showing 2 active and yields a score of 2 + 2 = 4, while choosing 5 makes the one die showing 5 active, yielding a score of 5.</p>

<p>Your method will take as input an int[] toss, where each element represents the upward face of a die, and return the maximum possible score with these values.</p>

<h6 id="definition">Definition</h6>

<p>Class:    YahtzeeScore <br>
Method:    maxPoints <br>
Parameters:    int[] <br>
Returns:    int <br>
Method signature:    int maxPoints(int[] toss) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>toss will contain exactly 5 elements.</li>
<li>Each element of toss will be between 1 and 6, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{ 2, 2, 3, 5, 4 } <br>
Returns: 5 <br>
The example from the text.</p></li>
<li><p>{ 6, 4, 1, 1, 3 } <br>
Returns: 6 <br>
Selecting 1 as active yields 1 + 1 = 2, selecting 3 yields 3, selecting 4 yields 4 and selecting 6 yields 6, which is the maximum number of points.</p></li>
<li><p>{ 5, 3, 5, 3, 3 } <br>
Returns: 10</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

class YahtzeeScore {  
    public:
        int maxPoints(vector&lt;int&gt; toss) {
            vector&lt;int&gt; sum(7, 0);
            for (int i = 0; i &lt; 5; ++i) {
                sum[toss[i]] += toss[i];
            }
            return *max_element(sum.begin(), sum.end());
        }   
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/yahtzee/</link><guid isPermaLink="false">8d1b1abb-1fbf-4698-a399-c75134b67896</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 11:15:17 GMT</pubDate></item><item><title><![CDATA[Poetry]]></title><description><![CDATA[<p>Used In:    SRM 170 <br>
Used As:    Division II Level Three</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Given a poem, determine its rhyme scheme.</p>

<p>To simplify things, because English is such a fickle language, there are some constraints:</p>

<p>A legal word is a sequence of lower or uppercase letters, containing at least one vowel, where a vowel is 'a', 'e', 'i', 'o', or 'u'. Also, 'y' is considered a vowel if it is not at the start or end of a word. Words are delimited by spaces.</p>

<p>Two words are considered rhyming if they have the same ending pattern (defined below). This comparison is case-insensitive (see Example 1.)</p>

<p>An ending pattern is a substring of a word such that:</p>

<p>The word ends with that substring, <br>
The substring contains exactly one contiguous string of vowels, <br>
The first letter of the substring is a vowel, and <br>
The substring must either be the whole string, or the letter immediately preceding the start of the substring must be a nonvowel. <br>
For example, the ending pattern of "bought" is "ought", the ending pattern of "spying" would be "ying", and the ending pattern of "all" would be "all". (Note that "spy" has no vowels, and thus is not a legal word.)</p>

<p>Two lines rhyme if their corresponding last words rhyme, and a line is empty if it contains no words.</p>

<p>The procedure for determinining rhyme scheme is as follows: The first non-empty line in the poem should be labeled with the lowercase letter 'a'. Every line that rhymes with that line should also be labeled with that letter. The next unlabeled non-empty line should be labeled with the letter 'b', and any rhyming lines should also be labeled in this manner. When you run out of lowercase letters, continue by using the uppercase letters 'A' to 'Z'. Empty lines should be labeled with ' ' (the space character).</p>

<p>The 0th character of the returned String should be the rhyme scheme label of the 0th line, the 1st character should be the label of the 1st line, and so on. This means that the returned String will have the same number of characters as there are elements in poem. Thus, given a String[] poem, then your method should return a String detailing the rhyme scheme.</p>

<h6 id="definition">Definition</h6>

<p>Class:    Poetry <br>
Method:    rhymeScheme <br>
Parameters:    String[] <br>
Returns:    String <br>
Method signature:    String rhymeScheme(String[] poem) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>If there is a blank line in the poem, there must be a corresponding space in the output. A blank line is one with no words. (See Example 1.)</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>poem will have between 1 and 50 elements, inclusive.</li>
<li>each element of poem will contain between 0 and 50 characters, inclusive.</li>
<li>the only allowable characters in poem will be upper and lowercase characters ('a'-'z' and 'A'-'Z') and the space character (' ').</li>
<li>there will be only legal words in poem</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{"I hope this problem", <br>
"is a whole lot better than",
"this stupid haiku"}
Returns: "abc" <br>
Doesn't even conceivably rhyme.</p></li>
<li><p>{"     ", <br>
"Measure your height",
"AND WEIGHT      ",
"said the doctor",
"",
"And make sure to take your pills",
"   to   cure   your    ills",
"Every",
"DAY"}
Returns: " aab ccde" <br>
Even though "height" and "weight" don't actually rhyme in English, they do by the rules laid out above.</p></li>
<li><p>{"One bright day in the middle of the night", <br>
"Two dead boys got up to fight",
"Back to back they faced each other",
"Drew their swords and shot each other",
"",
"A deaf policeman heard the noise",
"And came to arrest the two dead boys",
"And if you dont believe this lie is true",
"Ask the blind man he saw it too"}
Returns: "aabb cdef"</p></li>
<li><p>{"", <br>
"",
"",
""}
Returns: "    " <br>
Four lines from the mind of a blank poet.</p></li>
<li><p>{"This poem has uppercase letters", <br>
"In its rhyme scheme",
"Alpha", "Blaster", "Cat", "Desert", "Elephant", "Frog", "Gulch", 
"Horse", "Ireland", "Jam", "Krispy Kreme", "Loofah", "Moo", "Narf",
"Old", "Pink", "Quash", "Rainbow", "Star", "Tour", "Uvula", "Very",
"Will", "Xmas", "Young", "Zed", "deception", "comic", "grout",
"oval", "cable", "rob", "steal", "steel", "weak"}
Returns: "abcdefghibjkblmnopqrstcuvwxyzABCbDEFG"</p></li>
<li><p>{" ", <br>
"     ",
"This poem",
"         ",
" ",
" ",
"",
"Has lots of blank lines",
" ",
"      ",
"                                            ",
"         ",
" ",
"              ",
"                                                  ",
"  in      it           "}
Returns: "  a    b       c"</p></li>
<li><p>{"too bad   your", <br>
"     solution went   sour"}
Returns: "aa"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

using namespace std;

class Poetry {  
    private:
        bool isVowel(string s, int i) {
            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {
                return true;
            } else if (s[i] == 'y' &amp;&amp; i != 0 &amp;&amp; i != s.size() - 1) {
                return true;
            }
            return false;
        }
        string endPattern(string s) {
            string ep = "";
            bool flag = true;
            for (int i = s.size() - 1; i &gt;= 0; --i) {
                bool v = isVowel(s, i); 
                if (v) {
                    flag = false;
                }
                if (v || flag) {
                    ep = s[i] + ep;
                } else {
                    break;
                }
            }
            return ep;
        }
        bool isEmptyString(string s) {
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] != ' ') {
                    return false;
                }
            }
            return true;
        }
        string lastWord(string s) {
            istringstream iss(s);
            string lw;
            while (iss &gt;&gt; lw);
            return lw;
        }
    public:
        string rhymeScheme(vector&lt;string&gt; poem) {
            vector&lt;char&gt; rhymingSeq;
            for (char i = 'a'; i &lt;= 'z'; ++i) {
                rhymingSeq.push_back(i);
            }
            for (char i = 'A'; i &lt;= 'Z'; ++i) {
                rhymingSeq.push_back(i);
            }
            map&lt;string, char&gt; pattern;
            string scheme = "";
            int seq = 0;
            for (int i = 0; i &lt; poem.size(); ++i) {
                transform(poem[i].begin(), poem[i].end(), poem[i].begin(), ::tolower);
                if (!isEmptyString(poem[i])) {
                    string ep = endPattern(lastWord(poem[i]));
                    if (pattern.find(ep) == pattern.end()) {
                        pattern[ep] = rhymingSeq[seq++];
                    }
                    scheme += pattern[ep];
                } else {
                    scheme += " ";
                }
            }
            return scheme;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/poetry/</link><guid isPermaLink="false">7b987ce1-2551-4210-9070-76a824bb2ab6</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 10:25:31 GMT</pubDate></item><item><title><![CDATA[MatchMaking]]></title><description><![CDATA[<p>Used In:    SRM 203 <br>
Used As:    Division I Level One , Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You are developing the matchmaking component of an online dating site. Prospective members must fill out a questionnaire consisting of binary questions such as Do you prefer to vacation (a) in the mountains or (b) at the seaside? and Would you rather travel (a) by plane or (b) by train?</p>

<p>You are to match up men with women by maximizing the number of answers each couple has in common. A man and a woman have an answer in common whenever they give the same answer to the same question. Conflicts can easily arise due to numerical ties, but you will be able to resolve all such conflicts using the following procedure. Note that there will be equal numbers of men and women, with names being unique in each sex.</p>

<p>Take the woman whose name comes earliest in lexicographic order, and consider the men with whom she has the greatest number of answers in common. Among these men, pick the one whose name comes earliest in lexicographic order. You have found the woman's best match. Remove this couple from the dating pool, and repeat the matching procedure until there are no more singles left.</p>

<p>You are given a String[], namesWomen, containing the names of single women, and another String[], answersWomen, containing their answers. The kth element of answersWomen lists the answers of the woman whose name is the kth element of namesWomen. If there are n questions in the questionnaire, then every element of answersWomen consists of n characters, each of which is either 'a' or 'b'. The answers are always given in the fixed questionnaire order. You are similarly given the String[]s namesMen and answersMen for the single men. Lastly, you are given a String, queryWoman, containing the name of a woman. Return the name of the man to whom she is matched after you have formed all couples according to the above rules.</p>

<h6 id="definition">Definition</h6>

<p>Class:    MatchMaking <br>
Method:    makeMatch <br>
Parameters:    String[], String[], String[], String[], String <br>
Returns:    String <br>
Method signature:    String makeMatch(String[] namesWomen, String[] answersWomen, String[] namesMen, String[] answersMen, String queryWoman) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>Lexicographic order is like dictionary order, with the difference that case matters. All uppercase letters take precedence over all lowercase letters. Thus, "boolean" comes before "boot"; "boo" comes before "boolean"; "Boot" comes before "boo"; "Zoo" comes before "boo".</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>namesWomen contains between 1 and 50 elements, inclusive</li>
<li>if namesWomen consists of n elements, then answersWomen, namesMen, and answersMen consist of n elements each</li>
<li>each element of namesWomen and each element of namesMen is between 1 and 50 characters long, inclusive</li>
<li>the only characters that may appear in namesMen and namesWomen are 'a' to 'z' and 'A' to 'Z'</li>
<li>no two elements of namesWomen are alike</li>
<li>no two elements of namesMen are alike</li>
<li>the first element of answersWomen is between 1 and 50 characters long, inclusive</li>
<li>if the first element of answersWomen consists of m characters, then each element of answersWomen and of answersMen is m characters long</li>
<li>the only characters that may appear in answersWomen and answersMen are 'a' and 'b'</li>
<li>queryWoman is one of the Strings in namesWomen</li>
</ul>

<p>Examples</p>

<ol>
<li><p>{"Constance", "Bertha", "Alice"} <br>
{"aaba", "baab", "aaaa"}
{"Chip", "Biff", "Abe"}
{"bbaa", "baaa", "aaab"}
"Bertha"
Returns: "Biff" <br>
Alice has two answers in common with Chip and three answers in common with both Abe and Biff; Abe gets lexicographic preference. Bertha also has two answers in common with Chip and three answers in common with both Abe and Biff. Since Abe has already been matched to Alice, Bertha lands Biff.</p></li>
<li><p>{"Constance", "Bertha", "Alice"} <br>
{"aaba", "baab", "aaaa"}
{"Chip", "Biff", "Abe"}
{"bbaa", "baaa", "aaab"}
"Constance"
Returns: "Chip" <br>
We are dealing with the same names and answers as before. Constance is the last to go. Although she has two answers in common with Abe and Biff, they are both taken. She ends up with Chip, with whom she has only one answer in common.</p></li>
<li><p>{"Constance", "Alice", "Bertha", "Delilah", "Emily"} <br>
{"baabaa", "ababab", "aaabbb", "bababa", "baabba"}
{"Ed", "Duff", "Chip", "Abe", "Biff"}
{"aabaab", "babbab", "bbbaaa", "abbbba", "abaaba"}
"Constance"
Returns: "Duff"</p></li>
<li><p>{"Constance", "Alice", "Bertha", "Delilah", "Emily"} <br>
{"baabaa", "ababab", "aaabbb", "bababa", "baabba"}
{"Ed", "Duff", "Chip", "Abe", "Biff"}
{"aabaab", "babbab", "bbbaaa", "abbbba", "abaaba"}
"Delilah"
Returns: "Chip"</p></li>
<li><p>{"Constance", "Alice", "Bertha", "Delilah", "Emily"} <br>
{"baabaa", "ababab", "aaabbb", "bababa", "baabba"}
{"Ed", "Duff", "Chip", "Abe", "Biff"}
{"aabaab", "babbab", "bbbaaa", "abbbba", "abaaba"}
"Emily"
Returns: "Ed"</p></li>
<li><p>{"anne", "Zoe"} <br>
{"a", "a"}
{"bob", "chuck"}
{"a", "a"}
"Zoe"
Returns: "bob"</p></li>
<li><p>{"F", "M", "S", "h", "q", "g", "r", "N", "U", "x", "H", "P", <br>
"o", "E", "R", "z", "L", "m", "e", "u", "K", "A", "w", "Q",
"O", "v", "j", "a", "t", "p", "C", "G", "k", "c", "V", "B",
"D", "s", "n", "i", "f", "T", "I", "l", "d", "J", "y", "b"}
{"abaabbbb", "bbaabbbb", "aaabaaab", "aabbaaaa", "baabbaab",
"aaababba", "bbabbbbb", "bbbabbba", "aaabbbba", "aabbbaaa",
"abbabaaa", "babbabbb", "aaaaabba", "aaaabbaa", "abbbabaa",
"babababa", "abbaaaaa", "bbababba", "baaaaaba", "baaaaabb",
"bbbbabba", "ababbaaa", "abbbabab", "baabbbaa", "bbbaabbb",
"aababbab", "ababbabb", "abbaabba", "baabbabb", "aaabaaab",
"aabbbaba", "aabaaabb", "abababba", "aabbaaaa", "aabbabaa",
"bababaaa", "aabaaaab", "bbbbaabb", "baaababb", "abaabbab",
"aabbbaaa", "baabbaba", "bbabbbaa", "aabbbbaa", "abbbaaab",
"abababbb", "ababaaba", "bababaaa"}
{"f", "C", "v", "g", "Q", "z", "n", "c", "B", "o", "M", "F",
"u", "x", "I", "T", "K", "L", "E", "U", "w", "A", "d", "t",
"e", "R", "D", "s", "p", "q", "m", "r", "H", "j", "J", "V",
"l", "a", "k", "h", "G", "y", "i", "P", "O", "N", "b", "S"}
{"bbbaabab", "bbabaabb", "ababbbbb", "bbbababb", "baababaa",
"bbaaabab", "abbabbaa", "bbbabbbb", "aabbabab", "abbababa",
"aababbbb", "bababaab", "aaababbb", "baabbaba", "abaaaaab",
"bbaababa", "babaabab", "abbabbba", "ababbbab", "baabbbab",
"babbaaab", "abbbbaba", "bbabbbba", "baaabaab", "ababbabb",
"abbbaabb", "bbbbaabb", "bbbaaabb", "baabbaba", "bbabaaab",
"aabbbaab", "abbbbabb", "bbaaaaba", "bbbababa", "abbaabba",
"bababbbb", "aabaaabb", "babbabab", "baaaabaa", "ababbaba",
"aaabaabb", "bbaaabaa", "baaaaabb", "bbaabaab", "bbababab",
"aabaaaab", "aaaaabab", "aabbaaba"}
"U"
Returns: "x"</p></li>
<li><p>{"q", "M", "w", "y", "p", "N", "s", "r", "a", "H", "o", "n", <br>
"F", "m", "l", "b", "D", "j", "C", "u", "f", "I", "g", "L",
"i", "x", "A", "G", "O", "k", "h", "d", "c", "E", "B", "v",
"J", "z", "K", "e", "t"}
{"aabbaaabb", "baabababb", "bbaababba", "bbbaaaaaa", "abaaaabaa",
"bababbbab", "abbaabbaa", "aabababbb", "bababaaaa", "abbababaa",
"aabbbbbba", "bbabbabab", "babaabbba", "babbabbbb", "baaabbbbb",
"baaabaaaa", "aaabbaaab", "abbaabbbb", "abbabbbab", "bbaaaabba",
"babbaaabb", "aabbabbab", "baaababba", "ababaabab", "bbbaabbab",
"aaaabbabb", "babaaaaaa", "abbbbaaab", "aabaaabba", "bbbaaaaba",
"bbbbbbaab", "aabbaaabb", "aabaabbab", "aababaaba", "bbabbbbab",
"abbabaaab", "babaaabbb", "bababbaaa", "aabbaabaa", "baaabbabb",
"bbbbbbbbb"}
{"m", "k", "n", "q", "L", "E", "M", "l", "w", "x", "g", "e",
"i", "z", "F", "r", "a", "h", "f", "D", "J", "K", "j", "v",
"A", "t", "N", "y", "s", "c", "o", "p", "d", "b", "B", "G",
"O", "I", "u", "C", "H"}
{"bbaaabbba", "bbaaaaaab", "abaaababb", "baaaabbbb", "abbbababa",
"baaaaaaaa", "aabbbbbab", "aaaaabbba", "baabababb", "babaaabab",
"baaababaa", "bbbbaabba", "bbaabbabb", "bbaaababb", "abbabbaba",
"aababaaab", "abbbbbbaa", "aabbaabaa", "bbbaabbba", "abbabbaba",
"aaabbbaaa", "bbaabaaaa", "aabababbb", "abbbbabab", "baaabbbba",
"bababbbba", "aababbaab", "bbaabbaab", "bbbaaabbb", "babbbbabb",
"ababababb", "babaaabab", "bbaaaaaba", "aaaaabaaa", "abbaaabbb",
"bbbbababb", "baabababb", "bbaabaaaa", "aaababbbb", "abbbbbbba",
"bbaabbaaa"}
"o"
Returns: "C"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;map&gt;

using namespace std;

class MatchMaking {  
    private:
        int mathches(string a, string b) {
            int match = 0;
            for (int i = 0; i &lt; a.size(); ++i) {
                if (a[i] == b[i]) {
                    ++match;
                }
            }
            return match;
        }

    public:
        string makeMatch(vector&lt;string&gt; namesWomen, vector&lt;string&gt; answerWomen, vector&lt;string&gt; namesMen, vector&lt;string&gt; answerMen, string queryWoman) {
            int n = namesMen.size();
            string theChosenOne = "";
            map&lt;string, string&gt; women, men;
            vector&lt;bool&gt; taken(n, false);
            for (int i = 0; i &lt; n; ++i) {
                women[namesWomen[i]] = answerWomen[i];
                men[namesMen[i]] = answerMen[i];
            }
            for (map&lt;string, string&gt; :: iterator i = women.begin(); 
                i != women.end(); ++i) {
                int compatibility = -1;
                int index = 0,
                    jn = 0;
                for (map&lt;string, string&gt; :: iterator j = 
                    men.begin(); j != men.end(); ++j, ++jn) {
                    if (!taken[jn]) {
                        int match = mathches(i-&gt;second, j-&gt;second);
                        if (match &gt; compatibility) {
                            compatibility = match;
                            index = jn;
                            theChosenOne = j-&gt;first;
                        }
                    }
                }
                taken[index] = true;
                if (i-&gt;first == queryWoman) {
                    break;
                }
            }
            return theChosenOne;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/matchmaking/</link><guid isPermaLink="false">42d8c9c0-ad89-4714-8b3f-6c6396e3864a</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 07:37:33 GMT</pubDate></item><item><title><![CDATA[BettingMoney]]></title><description><![CDATA[<p>Used In:    SRM 191 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You run a gambling business in which people place bets on the margin of victory in a football game. At the end of the day, the company would like to know what the day's net gain has been.</p>

<p>Just as in any other betting system, people place certain amounts as their bets and if they guess correctly, they get their money back plus a pre-specified percentage of their bet; otherwise they lose the money they bet. </p>

<p>You are given a int[], amounts, the ith element of which is the number of dollars people have placed on a victory margin of i (i = 0 refers to the first element). You are also given a int[], centsPerDollar, the ith element of which is the number of cents the company has to pay for every dollar the people bet on a victory margin of i, if the final outcome is a victory margin of i. Finally, you are given an int, finalResult, which is the final margin of victory. You have to determine what the net gain for the day was and return the amount in cents.</p>

<p>For example, if amounts were {10,20,30}, it would mean that people placed $10 on a draw outcome, $20 on a victory margin of 1 and $30 on a victory margin of 2, and if centsPerDollar were {20,30,40}, it would mean the people would win 20 cents per dollar bet if the match were a draw, 30 cents per dollar if the victory margin were 1 and 40 cents per dollar if the victory margin were 2. </p>

<p>Suppose the final result is a victory margin of 1 (i.e., finalResult = 1). Then the people who guessed the outcome as a margin of 0 or 2 were wrong and the company receives the amounts they bet, $10+$30. However, the people who guessed that the outcome would be a margin of 1 were correct, and they receive money from the company according to the amount they bet (20 dollars) and the pre-set payoff percentage (30 cents per dollar) . This amounts to 20*30 = 600 cents. Hence, the day's net gain is 40 dollars - 600 cents = 3400 cents. You should return 3400.</p>

<h6 id="definition">Definition</h6>

<p>Class:    BettingMoney <br>
Method:    moneyMade <br>
Parameters:    int[], int[], int <br>
Returns:    int <br>
Method signature:    int moneyMade(int[] amounts, int[] centsPerDollar, int finalResult) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>Keep in mind that it is not relevant which team wins. Only the margin of victory matters.</li>
<li>A victory margin of 0 and a draw are the same thing.</li>
<li>There are 100 cents in a dollar.</li>
<li>If the company has to pay more than it receives, the day's net gain will be negative.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>amounts will contain between 1 and 50 elements, inclusive.</li>
<li>centsPerDollar will contain the same number of elements as amounts.</li>
<li>finalResult will be between 0 and n-1, inclusive, where n is the number of elements in amounts.</li>
<li>Each element of amounts will be between 0 and 5000, inclusive.</li>
<li>Each element of centsPerDollar will be between 0 and 5000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{10,20,30} <br>
{20,30,40}
1 <br>
Returns: 3400 <br>
The case explained in the problem statement above.</p></li>
<li><p>{200,300,100} <br>
{10,10,10}
2 <br>
Returns: 49000 <br>
The company gains 200+300 = 500 dollars from the people who bet on margins of 0 and 1. The company loses 100*10 = 1000 cents to the people who bet on a victory margin of 2. Hence, the net gain is 49000 cents.</p></li>
<li><p>{100,100,100,100} <br>
{5,5,5,5}
0 <br>
Returns: 29500</p></li>
<li><p>{5000,5000} <br>
{100,2}
0 <br>
Returns: 0</p></li>
<li><p>{100} <br>
{10}
0 <br>
Returns: -1000 <br>
The company doesn't gain anything! It has to pay the people who bet on the only outcome possible. It pays 100*10 cents. Hence, the net gain is -1000. (Negative indicates loss.)</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class BettingMoney {  
    public:
        int moneyMade(vector&lt;int&gt; amounts, vector&lt;int&gt; centsPerDollar, int finalResult) {
            int profit = 0;
            for (int i = 0; i &lt; amounts.size(); ++i) {
                if (i == finalResult) {
                    profit -= (amounts[i] * centsPerDollar[i]);
                } else {
                    profit += (amounts[i] * 100);
                }
            }
            return profit;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/bettingname/</link><guid isPermaLink="false">99b30a41-e004-409d-a143-0e90ec6c8f90</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 05:18:42 GMT</pubDate></item><item><title><![CDATA[UserName]]></title><description><![CDATA[<p>Used In:    SRM 203 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You are implementing the member registration system of an online dating site. When a new member signs up, it is possible that she initially chooses the same username as an existing member. The system must then inform the new member of the conflict and suggest a variant of the chosen name with a number attached to the end.</p>

<p>If an existing member is named "FunkyMonkey", for example, and a new member wants the same username, the simplest suggestion the system can make is "FunkyMonkey1". If there is already a member by that name, the system must suggest "FunkyMonkey2", unless that variant is also taken. If all names from "FunkyMonkey1" through "FunkyMonkey9" are taken as well as the original "FunkyMonkey", the system moves on to consider "FunkyMonkey10", and so on. The goal is to use the smallest possible number in the variant. Note that each username consists of letters (the characters from 'a' to 'z' and from 'A' to 'Z') and numerals ('0' to '9').</p>

<p>You are given a String[], existingNames, containing all usernames that have already been registered in the system. You are also given a single String, newName, containing the username that a new member wants to use. In the event of a conflict, this member will accept the suggestion offered by your system in accordance with the principles above. Return a String containing the username finally assigned to the new member.</p>

<h6 id="definition">Definition</h6>

<p>Class:    UserName <br>
Method:    newMember <br>
Parameters:    String[], String <br>
Returns:    String <br>
Method signature:    String newMember(String[] existingNames, String newName) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>The constraints rule out names that end in a number with a leading zero, such as "grokster006" and "bart0".</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>existingNames contains between 1 and 50 elements, inclusive</li>
<li>each element of existingNames is between 1 and 50 characters long, inclusive</li>
<li>the only characters permitted in elements of existingNames are 'a' to 'z', 'A' to 'Z', and '0' to '9'</li>
<li>no element of existingNames ends in a number that has a leading zero</li>
<li>newName is between 1 and 50 characters long, inclusive</li>
<li>the only characters permitted in newName are 'a' to 'z' and 'A' to 'Z'</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{"MasterOfDisaster", "DingBat", "Orpheus", "WolfMan", "MrKnowItAll"} <br>
"TygerTyger"
Returns: "TygerTyger" <br>
"TygerTyger" is available.</p></li>
<li><p>{"MasterOfDisaster", "TygerTyger1", "DingBat", "Orpheus", <br>
"TygerTyger", "WolfMan", "MrKnowItAll"}
"TygerTyger"
Returns: "TygerTyger2" <br>
"TygerTyger" and "TygerTyger1" are taken.</p></li>
<li><p>{"TygerTyger2000", "TygerTyger1", "MasterDisaster", "DingBat", <br>
"Orpheus", "WolfMan", "MrKnowItAll"}
"TygerTyger"
Returns: "TygerTyger" <br>
There are higher-numbered variants of "TygerTyger", but the base name is available.</p></li>
<li><p>{"grokster2", "BrownEyedBoy", "Yoop", "BlueEyedGirl", <br>
"grokster", "Elemental", "NightShade", "Grokster1"}
"grokster"
Returns: "grokster1" <br>
Note that "Grokster1" is not the same as "grokster1".</p></li>
<li><p>{"Bart4", "Bart5", "Bart6", "Bart7", "Bart8", "Bart9", "Bart10", <br>
"Lisa", "Marge", "Homer", "Bart", "Bart1", "Bart2", "Bart3",
"Bart11", "Bart12"}
"Bart"
Returns: "Bart13"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;

using namespace std;

class UserName {  
    private:
        string intToString(int n) {
            ostringstream oss;
            oss &lt;&lt; n;
            return oss.str();
        }
    public:
        string newMember(vector&lt;string&gt; existingNames, string newName) {
            if (find(existingNames.begin(), existingNames.end(), 
               newName) == existingNames.end()) {
                return newName;
            }
            int i = 1;
            while (find(existingNames.begin(), existingNames.end(), 
            newName + intToString(i++)) != existingNames.end());
            return newName + intToString(--i);
        }   
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/username/</link><guid isPermaLink="false">be1ed185-8877-42a7-9d89-8f80236c99b0</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 04:18:37 GMT</pubDate></item><item><title><![CDATA[PIGBANK]]></title><description><![CDATA[<p>Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid.</p>

<p>But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!</p>

<h6 id="input">Input</h6>

<p>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it's weight in grams.</p>

<h6 id="output">Output</h6>

<p>Print exactly one line of output for each test case. The line must contain the sentence "The minimum amount of money in the piggy-bank is X." where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line "This is impossible.".</p>

<p>Example</p>

<p>Input: <br>
3 <br>
10 110 <br>
2 <br>
1 1 <br>
30 50 <br>
10 110 <br>
2 <br>
1 1 <br>
50 30 <br>
1 6 <br>
2 <br>
10 3 <br>
20 4</p>

<p>Output: <br>
The minimum amount of money in the piggy-bank is 60. <br>
The minimum amount of money in the piggy-bank is 100. <br>
This is impossible.</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int E,F;
        cin &gt;&gt; E &gt;&gt; F;
        F -= E;
        vector&lt;int&gt; dp(F + 1, 100000000);
        int N;
        cin &gt;&gt; N;
        for (int i = 0; i &lt; N; ++i) {
            int p, w;
            cin &gt;&gt; p &gt;&gt; w;
            if (dp[w] &gt; p) {
                dp[w] = p;
                for (int j = 1; j &lt;= F - w; ++j) {
                    if(dp[j + w] &gt; dp[j] + dp[w]) {
                        dp[j + w] = dp[j] + dp[w];
                    }
                }
            }
        }
        if(dp[F] &lt; 100000000) {
            cout &lt;&lt; "The minimum amount of money in the piggy-bank is " &lt;&lt; dp[F] &lt;&lt; ".\n";
        } else {
            cout &lt;&lt; "This is impossible.\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/29/pigbank/</link><guid isPermaLink="false">44f5c2a6-ccfd-484d-b43f-343a3c927f1e</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 29 Nov 2014 13:08:54 GMT</pubDate></item><item><title><![CDATA[PARTY]]></title><description><![CDATA[<p>You just received another bill which you cannot pay because you lack the money. Unfortunately, this is not the first time to happen, and now you decide to investigate the cause of your constant monetary shortness. The reason is quite obvious: the lion's share of your money routinely disappears at the entrance of party localities. </p>

<p>You make up your mind to solve the problem where it arises, namely at the parties themselves. You introduce a limit for your party budget and try to have the most possible fun with regard to this limit. </p>

<p>You inquire beforehand about the entrance fee to each party and estimate how much fun you might have there. The list is readily compiled, but how do you actually pick the parties that give you the most fun and do not exceed your budget? </p>

<p>Write a program which finds this optimal set of parties that offer the most fun. Keep in mind that your budget need not necessarily be reached exactly. Achieve the highest possible fun level, and do not spend more money than is absolutely necessary.</p>

<h6 id="input">Input</h6>

<p>The first line of the input specifies your party budget and the number n of parties. </p>

<p>The following n lines contain two numbers each. The first number indicates the entrance fee of each party. Parties cost between 5 and 25 francs. The second number indicates the amount of fun of each party, given as an integer number ranging from 0 to 10. </p>

<p>The budget will not exceed 500 and there will be at most 100 parties. All numbers are separated by a single space. </p>

<p>There are many test cases. Input ends with 0 0.</p>

<h6 id="output">Output</h6>

<p>For each test case your program must output the sum of the entrance fees and the sum of all fun values of an optimal solution. Both numbers must be separated by a single space.</p>

<p>Example</p>

<p>Input: <br>
50 10 <br>
12 3 <br>
15 8 <br>
16 9 <br>
16 6 <br>
10 2 <br>
21 9 <br>
18 4 <br>
12 4 <br>
17 8 <br>
18 9 </p>

<p>50 10 <br>
13 8 <br>
19 10 <br>
16 8 <br>
12 9 <br>
10 2 <br>
12 8 <br>
13 5 <br>
15 5 <br>
11 7 <br>
16 2</p>

<p>0 0</p>

<p>Output: <br>
49 26 <br>
48 32</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

pair&lt;int, int&gt; knapSack(int b, vector&lt;int&gt; budget, vector&lt;int&gt; fun) {  
    int n = budget.size();
    vector&lt;vector&lt;int&gt; &gt; k(n + 1, vector&lt;int&gt; (b + 1));
    for (int i = 0; i &lt;= n; ++i) {
        for (int j = 0; j &lt;= b; ++j) {
            if (i == 0 || j == 0) {
                k[i][j] = 0;
            } else if ((budget[i - 1] &lt;= j) &amp;&amp; (fun[i - 1] + k[i - 1][j - budget[i - 1]]) &gt; k[i - 1][j]) {
                k[i][j] = fun[i - 1] + k[i - 1][j - budget[i - 1]];
            } else {
                k[i][j] = k[i - 1][j];
            }
        }
    }
    int ans = 0;
    for (int i = 0; i &lt;= b; ++i) {
        if (k[n][i] == k[n][b]) {
            ans = i;
            break;
        }
    }
    return make_pair(ans, k[n][b]);
}

int main() {  
    int b, p;
    while ((cin &gt;&gt; b &gt;&gt; p) &amp;&amp; !(b == 0 &amp;&amp; p == 0)) {
        vector&lt;int&gt; budget(p),
                    fun(p);
        for (int i = 0; i &lt; p; ++i) {
            cin &gt;&gt; budget[i] &gt;&gt; fun[i];
        }
        pair&lt;int, int&gt; ans = knapSack(b, budget, fun);
        cout &lt;&lt; ans.first &lt;&lt; " " &lt;&lt; ans.second &lt;&lt; "\n";
    } 
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/29/party/</link><guid isPermaLink="false">1efbd2f9-8f70-4162-bc1e-79717acbe02e</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 29 Nov 2014 11:37:15 GMT</pubDate></item><item><title><![CDATA[CRDS]]></title><description><![CDATA[<p>Maricruz have a lot of cards, she always uses her cards to build pyramids as shown in the following image:</p>

<p><img src="http://code-jedi.chintanghate.me/content/images/2014/11/francky-cards.png" alt="Cards"></p>

<p>A pyramid card of 3 levels. <br>
She always wonder how many cards does she need to make a pyramid card of N levels. Your task is to answer that question.</p>

<h6 id="input">Input</h6>

<p>The first line of the input contains an integer 1&lt;= T &lt;= 1,000. Each of the following T lines will have an integer 1&lt;= N &lt;= 1,000,000.</p>

<h6 id="output">Output</h6>

<p>For each case, output a single line consisting of the number of cards needed to build a pyramid card of level N modulo 1,000,007.</p>

<p>Example</p>

<p>Input: <br>
2 <br>
3 <br>
7</p>

<p>Output: <br>
15 <br>
77</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        unsigned long long levels;
        cin &gt;&gt; levels;
        unsigned long long cards = 
        (((levels * (levels + 1) / 2) * 3) - levels);
        cout &lt;&lt; cards % 1000007 &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/crds/</link><guid isPermaLink="false">80d9e6f9-0109-4490-a9b5-32d931259a55</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 17:25:46 GMT</pubDate></item></channel></rss>