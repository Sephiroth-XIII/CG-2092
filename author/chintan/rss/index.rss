<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Chintan Ghate - Code Jedi]]></title><description><![CDATA[Code, algorithms and design.]]></description><link>http://code-jedi.chintanghate.me/</link><generator>Ghost 0.5</generator><lastBuildDate>Sun, 30 Nov 2014 10:57:03 GMT</lastBuildDate><atom:link href="http://code-jedi.chintanghate.me/author/chintan/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Poetry]]></title><description><![CDATA[<p>Used In:    SRM 170 <br>
Used As:    Division II Level Three</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Given a poem, determine its rhyme scheme.</p>

<p>To simplify things, because English is such a fickle language, there are some constraints:</p>

<p>A legal word is a sequence of lower or uppercase letters, containing at least one vowel, where a vowel is 'a', 'e', 'i', 'o', or 'u'. Also, 'y' is considered a vowel if it is not at the start or end of a word. Words are delimited by spaces.</p>

<p>Two words are considered rhyming if they have the same ending pattern (defined below). This comparison is case-insensitive (see Example 1.)</p>

<p>An ending pattern is a substring of a word such that:</p>

<p>The word ends with that substring, <br>
The substring contains exactly one contiguous string of vowels, <br>
The first letter of the substring is a vowel, and <br>
The substring must either be the whole string, or the letter immediately preceding the start of the substring must be a nonvowel. <br>
For example, the ending pattern of "bought" is "ought", the ending pattern of "spying" would be "ying", and the ending pattern of "all" would be "all". (Note that "spy" has no vowels, and thus is not a legal word.)</p>

<p>Two lines rhyme if their corresponding last words rhyme, and a line is empty if it contains no words.</p>

<p>The procedure for determinining rhyme scheme is as follows: The first non-empty line in the poem should be labeled with the lowercase letter 'a'. Every line that rhymes with that line should also be labeled with that letter. The next unlabeled non-empty line should be labeled with the letter 'b', and any rhyming lines should also be labeled in this manner. When you run out of lowercase letters, continue by using the uppercase letters 'A' to 'Z'. Empty lines should be labeled with ' ' (the space character).</p>

<p>The 0th character of the returned String should be the rhyme scheme label of the 0th line, the 1st character should be the label of the 1st line, and so on. This means that the returned String will have the same number of characters as there are elements in poem. Thus, given a String[] poem, then your method should return a String detailing the rhyme scheme.</p>

<h6 id="definition">Definition</h6>

<p>Class:    Poetry <br>
Method:    rhymeScheme <br>
Parameters:    String[] <br>
Returns:    String <br>
Method signature:    String rhymeScheme(String[] poem) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>If there is a blank line in the poem, there must be a corresponding space in the output. A blank line is one with no words. (See Example 1.)</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>poem will have between 1 and 50 elements, inclusive.</li>
<li>each element of poem will contain between 0 and 50 characters, inclusive.</li>
<li>the only allowable characters in poem will be upper and lowercase characters ('a'-'z' and 'A'-'Z') and the space character (' ').</li>
<li>there will be only legal words in poem</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{"I hope this problem", <br>
"is a whole lot better than",
"this stupid haiku"}
Returns: "abc" <br>
Doesn't even conceivably rhyme.</p></li>
<li><p>{"     ", <br>
"Measure your height",
"AND WEIGHT      ",
"said the doctor",
"",
"And make sure to take your pills",
"   to   cure   your    ills",
"Every",
"DAY"}
Returns: " aab ccde" <br>
Even though "height" and "weight" don't actually rhyme in English, they do by the rules laid out above.</p></li>
<li><p>{"One bright day in the middle of the night", <br>
"Two dead boys got up to fight",
"Back to back they faced each other",
"Drew their swords and shot each other",
"",
"A deaf policeman heard the noise",
"And came to arrest the two dead boys",
"And if you dont believe this lie is true",
"Ask the blind man he saw it too"}
Returns: "aabb cdef"</p></li>
<li><p>{"", <br>
"",
"",
""}
Returns: "    " <br>
Four lines from the mind of a blank poet.</p></li>
<li><p>{"This poem has uppercase letters", <br>
"In its rhyme scheme",
"Alpha", "Blaster", "Cat", "Desert", "Elephant", "Frog", "Gulch", 
"Horse", "Ireland", "Jam", "Krispy Kreme", "Loofah", "Moo", "Narf",
"Old", "Pink", "Quash", "Rainbow", "Star", "Tour", "Uvula", "Very",
"Will", "Xmas", "Young", "Zed", "deception", "comic", "grout",
"oval", "cable", "rob", "steal", "steel", "weak"}
Returns: "abcdefghibjkblmnopqrstcuvwxyzABCbDEFG"</p></li>
<li><p>{" ", <br>
"     ",
"This poem",
"         ",
" ",
" ",
"",
"Has lots of blank lines",
" ",
"      ",
"                                            ",
"         ",
" ",
"              ",
"                                                  ",
"  in      it           "}
Returns: "  a    b       c"</p></li>
<li><p>{"too bad   your", <br>
"     solution went   sour"}
Returns: "aa"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

using namespace std;

class Poetry {  
    private:
        bool isVowel(string s, int i) {
            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {
                return true;
            } else if (s[i] == 'y' &amp;&amp; i != 0 &amp;&amp; i != s.size() - 1) {
                return true;
            }
            return false;
        }
        string endPattern(string s) {
            string ep = "";
            bool flag = true;
            for (int i = s.size() - 1; i &gt;= 0; --i) {
                bool v = isVowel(s, i); 
                if (v) {
                    flag = false;
                }
                if (v || flag) {
                    ep = s[i] + ep;
                } else {
                    break;
                }
            }
            return ep;
        }
        bool isEmptyString(string s) {
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] != ' ') {
                    return false;
                }
            }
            return true;
        }
        string lastWord(string s) {
            istringstream iss(s);
            string lw;
            while (iss &gt;&gt; lw);
            return lw;
        }
    public:
        string rhymeScheme(vector&lt;string&gt; poem) {
            vector&lt;char&gt; rhymingSeq;
            for (char i = 'a'; i &lt;= 'z'; ++i) {
                rhymingSeq.push_back(i);
            }
            for (char i = 'A'; i &lt;= 'Z'; ++i) {
                rhymingSeq.push_back(i);
            }
            map&lt;string, char&gt; pattern;
            string scheme = "";
            int seq = 0;
            for (int i = 0; i &lt; poem.size(); ++i) {
                transform(poem[i].begin(), poem[i].end(), poem[i].begin(), ::tolower);
                if (!isEmptyString(poem[i])) {
                    string ep = endPattern(lastWord(poem[i]));
                    if (pattern.find(ep) == pattern.end()) {
                        pattern[ep] = rhymingSeq[seq++];
                    }
                    scheme += pattern[ep];
                } else {
                    scheme += " ";
                }
            }
            return scheme;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/poetry/</link><guid isPermaLink="false">7b987ce1-2551-4210-9070-76a824bb2ab6</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 10:25:31 GMT</pubDate></item><item><title><![CDATA[MatchMaking]]></title><description><![CDATA[<p>Used In:    SRM 203 <br>
Used As:    Division I Level One , Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You are developing the matchmaking component of an online dating site. Prospective members must fill out a questionnaire consisting of binary questions such as Do you prefer to vacation (a) in the mountains or (b) at the seaside? and Would you rather travel (a) by plane or (b) by train?</p>

<p>You are to match up men with women by maximizing the number of answers each couple has in common. A man and a woman have an answer in common whenever they give the same answer to the same question. Conflicts can easily arise due to numerical ties, but you will be able to resolve all such conflicts using the following procedure. Note that there will be equal numbers of men and women, with names being unique in each sex.</p>

<p>Take the woman whose name comes earliest in lexicographic order, and consider the men with whom she has the greatest number of answers in common. Among these men, pick the one whose name comes earliest in lexicographic order. You have found the woman's best match. Remove this couple from the dating pool, and repeat the matching procedure until there are no more singles left.</p>

<p>You are given a String[], namesWomen, containing the names of single women, and another String[], answersWomen, containing their answers. The kth element of answersWomen lists the answers of the woman whose name is the kth element of namesWomen. If there are n questions in the questionnaire, then every element of answersWomen consists of n characters, each of which is either 'a' or 'b'. The answers are always given in the fixed questionnaire order. You are similarly given the String[]s namesMen and answersMen for the single men. Lastly, you are given a String, queryWoman, containing the name of a woman. Return the name of the man to whom she is matched after you have formed all couples according to the above rules.</p>

<h6 id="definition">Definition</h6>

<p>Class:    MatchMaking <br>
Method:    makeMatch <br>
Parameters:    String[], String[], String[], String[], String <br>
Returns:    String <br>
Method signature:    String makeMatch(String[] namesWomen, String[] answersWomen, String[] namesMen, String[] answersMen, String queryWoman) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>Lexicographic order is like dictionary order, with the difference that case matters. All uppercase letters take precedence over all lowercase letters. Thus, "boolean" comes before "boot"; "boo" comes before "boolean"; "Boot" comes before "boo"; "Zoo" comes before "boo".</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>namesWomen contains between 1 and 50 elements, inclusive</li>
<li>if namesWomen consists of n elements, then answersWomen, namesMen, and answersMen consist of n elements each</li>
<li>each element of namesWomen and each element of namesMen is between 1 and 50 characters long, inclusive</li>
<li>the only characters that may appear in namesMen and namesWomen are 'a' to 'z' and 'A' to 'Z'</li>
<li>no two elements of namesWomen are alike</li>
<li>no two elements of namesMen are alike</li>
<li>the first element of answersWomen is between 1 and 50 characters long, inclusive</li>
<li>if the first element of answersWomen consists of m characters, then each element of answersWomen and of answersMen is m characters long</li>
<li>the only characters that may appear in answersWomen and answersMen are 'a' and 'b'</li>
<li>queryWoman is one of the Strings in namesWomen</li>
</ul>

<p>Examples</p>

<ol>
<li><p>{"Constance", "Bertha", "Alice"} <br>
{"aaba", "baab", "aaaa"}
{"Chip", "Biff", "Abe"}
{"bbaa", "baaa", "aaab"}
"Bertha"
Returns: "Biff" <br>
Alice has two answers in common with Chip and three answers in common with both Abe and Biff; Abe gets lexicographic preference. Bertha also has two answers in common with Chip and three answers in common with both Abe and Biff. Since Abe has already been matched to Alice, Bertha lands Biff.</p></li>
<li><p>{"Constance", "Bertha", "Alice"} <br>
{"aaba", "baab", "aaaa"}
{"Chip", "Biff", "Abe"}
{"bbaa", "baaa", "aaab"}
"Constance"
Returns: "Chip" <br>
We are dealing with the same names and answers as before. Constance is the last to go. Although she has two answers in common with Abe and Biff, they are both taken. She ends up with Chip, with whom she has only one answer in common.</p></li>
<li><p>{"Constance", "Alice", "Bertha", "Delilah", "Emily"} <br>
{"baabaa", "ababab", "aaabbb", "bababa", "baabba"}
{"Ed", "Duff", "Chip", "Abe", "Biff"}
{"aabaab", "babbab", "bbbaaa", "abbbba", "abaaba"}
"Constance"
Returns: "Duff"</p></li>
<li><p>{"Constance", "Alice", "Bertha", "Delilah", "Emily"} <br>
{"baabaa", "ababab", "aaabbb", "bababa", "baabba"}
{"Ed", "Duff", "Chip", "Abe", "Biff"}
{"aabaab", "babbab", "bbbaaa", "abbbba", "abaaba"}
"Delilah"
Returns: "Chip"</p></li>
<li><p>{"Constance", "Alice", "Bertha", "Delilah", "Emily"} <br>
{"baabaa", "ababab", "aaabbb", "bababa", "baabba"}
{"Ed", "Duff", "Chip", "Abe", "Biff"}
{"aabaab", "babbab", "bbbaaa", "abbbba", "abaaba"}
"Emily"
Returns: "Ed"</p></li>
<li><p>{"anne", "Zoe"} <br>
{"a", "a"}
{"bob", "chuck"}
{"a", "a"}
"Zoe"
Returns: "bob"</p></li>
<li><p>{"F", "M", "S", "h", "q", "g", "r", "N", "U", "x", "H", "P", <br>
"o", "E", "R", "z", "L", "m", "e", "u", "K", "A", "w", "Q",
"O", "v", "j", "a", "t", "p", "C", "G", "k", "c", "V", "B",
"D", "s", "n", "i", "f", "T", "I", "l", "d", "J", "y", "b"}
{"abaabbbb", "bbaabbbb", "aaabaaab", "aabbaaaa", "baabbaab",
"aaababba", "bbabbbbb", "bbbabbba", "aaabbbba", "aabbbaaa",
"abbabaaa", "babbabbb", "aaaaabba", "aaaabbaa", "abbbabaa",
"babababa", "abbaaaaa", "bbababba", "baaaaaba", "baaaaabb",
"bbbbabba", "ababbaaa", "abbbabab", "baabbbaa", "bbbaabbb",
"aababbab", "ababbabb", "abbaabba", "baabbabb", "aaabaaab",
"aabbbaba", "aabaaabb", "abababba", "aabbaaaa", "aabbabaa",
"bababaaa", "aabaaaab", "bbbbaabb", "baaababb", "abaabbab",
"aabbbaaa", "baabbaba", "bbabbbaa", "aabbbbaa", "abbbaaab",
"abababbb", "ababaaba", "bababaaa"}
{"f", "C", "v", "g", "Q", "z", "n", "c", "B", "o", "M", "F",
"u", "x", "I", "T", "K", "L", "E", "U", "w", "A", "d", "t",
"e", "R", "D", "s", "p", "q", "m", "r", "H", "j", "J", "V",
"l", "a", "k", "h", "G", "y", "i", "P", "O", "N", "b", "S"}
{"bbbaabab", "bbabaabb", "ababbbbb", "bbbababb", "baababaa",
"bbaaabab", "abbabbaa", "bbbabbbb", "aabbabab", "abbababa",
"aababbbb", "bababaab", "aaababbb", "baabbaba", "abaaaaab",
"bbaababa", "babaabab", "abbabbba", "ababbbab", "baabbbab",
"babbaaab", "abbbbaba", "bbabbbba", "baaabaab", "ababbabb",
"abbbaabb", "bbbbaabb", "bbbaaabb", "baabbaba", "bbabaaab",
"aabbbaab", "abbbbabb", "bbaaaaba", "bbbababa", "abbaabba",
"bababbbb", "aabaaabb", "babbabab", "baaaabaa", "ababbaba",
"aaabaabb", "bbaaabaa", "baaaaabb", "bbaabaab", "bbababab",
"aabaaaab", "aaaaabab", "aabbaaba"}
"U"
Returns: "x"</p></li>
<li><p>{"q", "M", "w", "y", "p", "N", "s", "r", "a", "H", "o", "n", <br>
"F", "m", "l", "b", "D", "j", "C", "u", "f", "I", "g", "L",
"i", "x", "A", "G", "O", "k", "h", "d", "c", "E", "B", "v",
"J", "z", "K", "e", "t"}
{"aabbaaabb", "baabababb", "bbaababba", "bbbaaaaaa", "abaaaabaa",
"bababbbab", "abbaabbaa", "aabababbb", "bababaaaa", "abbababaa",
"aabbbbbba", "bbabbabab", "babaabbba", "babbabbbb", "baaabbbbb",
"baaabaaaa", "aaabbaaab", "abbaabbbb", "abbabbbab", "bbaaaabba",
"babbaaabb", "aabbabbab", "baaababba", "ababaabab", "bbbaabbab",
"aaaabbabb", "babaaaaaa", "abbbbaaab", "aabaaabba", "bbbaaaaba",
"bbbbbbaab", "aabbaaabb", "aabaabbab", "aababaaba", "bbabbbbab",
"abbabaaab", "babaaabbb", "bababbaaa", "aabbaabaa", "baaabbabb",
"bbbbbbbbb"}
{"m", "k", "n", "q", "L", "E", "M", "l", "w", "x", "g", "e",
"i", "z", "F", "r", "a", "h", "f", "D", "J", "K", "j", "v",
"A", "t", "N", "y", "s", "c", "o", "p", "d", "b", "B", "G",
"O", "I", "u", "C", "H"}
{"bbaaabbba", "bbaaaaaab", "abaaababb", "baaaabbbb", "abbbababa",
"baaaaaaaa", "aabbbbbab", "aaaaabbba", "baabababb", "babaaabab",
"baaababaa", "bbbbaabba", "bbaabbabb", "bbaaababb", "abbabbaba",
"aababaaab", "abbbbbbaa", "aabbaabaa", "bbbaabbba", "abbabbaba",
"aaabbbaaa", "bbaabaaaa", "aabababbb", "abbbbabab", "baaabbbba",
"bababbbba", "aababbaab", "bbaabbaab", "bbbaaabbb", "babbbbabb",
"ababababb", "babaaabab", "bbaaaaaba", "aaaaabaaa", "abbaaabbb",
"bbbbababb", "baabababb", "bbaabaaaa", "aaababbbb", "abbbbbbba",
"bbaabbaaa"}
"o"
Returns: "C"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;map&gt;

using namespace std;

class MatchMaking {  
    private:
        int mathches(string a, string b) {
            int match = 0;
            for (int i = 0; i &lt; a.size(); ++i) {
                if (a[i] == b[i]) {
                    ++match;
                }
            }
            return match;
        }

    public:
        string makeMatch(vector&lt;string&gt; namesWomen, vector&lt;string&gt; answerWomen, vector&lt;string&gt; namesMen, vector&lt;string&gt; answerMen, string queryWoman) {
            int n = namesMen.size();
            string theChosenOne = "";
            map&lt;string, string&gt; women, men;
            vector&lt;bool&gt; taken(n, false);
            for (int i = 0; i &lt; n; ++i) {
                women[namesWomen[i]] = answerWomen[i];
                men[namesMen[i]] = answerMen[i];
            }
            for (map&lt;string, string&gt; :: iterator i = women.begin(); 
                i != women.end(); ++i) {
                int compatibility = -1;
                int index = 0,
                    jn = 0;
                for (map&lt;string, string&gt; :: iterator j = 
                    men.begin(); j != men.end(); ++j, ++jn) {
                    if (!taken[jn]) {
                        int match = mathches(i-&gt;second, j-&gt;second);
                        if (match &gt; compatibility) {
                            compatibility = match;
                            index = jn;
                            theChosenOne = j-&gt;first;
                        }
                    }
                }
                taken[index] = true;
                if (i-&gt;first == queryWoman) {
                    break;
                }
            }
            return theChosenOne;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/matchmaking/</link><guid isPermaLink="false">42d8c9c0-ad89-4714-8b3f-6c6396e3864a</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 07:37:33 GMT</pubDate></item><item><title><![CDATA[BettingMoney]]></title><description><![CDATA[<p>Used In:    SRM 191 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You run a gambling business in which people place bets on the margin of victory in a football game. At the end of the day, the company would like to know what the day's net gain has been.</p>

<p>Just as in any other betting system, people place certain amounts as their bets and if they guess correctly, they get their money back plus a pre-specified percentage of their bet; otherwise they lose the money they bet. </p>

<p>You are given a int[], amounts, the ith element of which is the number of dollars people have placed on a victory margin of i (i = 0 refers to the first element). You are also given a int[], centsPerDollar, the ith element of which is the number of cents the company has to pay for every dollar the people bet on a victory margin of i, if the final outcome is a victory margin of i. Finally, you are given an int, finalResult, which is the final margin of victory. You have to determine what the net gain for the day was and return the amount in cents.</p>

<p>For example, if amounts were {10,20,30}, it would mean that people placed $10 on a draw outcome, $20 on a victory margin of 1 and $30 on a victory margin of 2, and if centsPerDollar were {20,30,40}, it would mean the people would win 20 cents per dollar bet if the match were a draw, 30 cents per dollar if the victory margin were 1 and 40 cents per dollar if the victory margin were 2. </p>

<p>Suppose the final result is a victory margin of 1 (i.e., finalResult = 1). Then the people who guessed the outcome as a margin of 0 or 2 were wrong and the company receives the amounts they bet, $10+$30. However, the people who guessed that the outcome would be a margin of 1 were correct, and they receive money from the company according to the amount they bet (20 dollars) and the pre-set payoff percentage (30 cents per dollar) . This amounts to 20*30 = 600 cents. Hence, the day's net gain is 40 dollars - 600 cents = 3400 cents. You should return 3400.</p>

<h6 id="definition">Definition</h6>

<p>Class:    BettingMoney <br>
Method:    moneyMade <br>
Parameters:    int[], int[], int <br>
Returns:    int <br>
Method signature:    int moneyMade(int[] amounts, int[] centsPerDollar, int finalResult) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>Keep in mind that it is not relevant which team wins. Only the margin of victory matters.</li>
<li>A victory margin of 0 and a draw are the same thing.</li>
<li>There are 100 cents in a dollar.</li>
<li>If the company has to pay more than it receives, the day's net gain will be negative.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>amounts will contain between 1 and 50 elements, inclusive.</li>
<li>centsPerDollar will contain the same number of elements as amounts.</li>
<li>finalResult will be between 0 and n-1, inclusive, where n is the number of elements in amounts.</li>
<li>Each element of amounts will be between 0 and 5000, inclusive.</li>
<li>Each element of centsPerDollar will be between 0 and 5000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{10,20,30} <br>
{20,30,40}
1 <br>
Returns: 3400 <br>
The case explained in the problem statement above.</p></li>
<li><p>{200,300,100} <br>
{10,10,10}
2 <br>
Returns: 49000 <br>
The company gains 200+300 = 500 dollars from the people who bet on margins of 0 and 1. The company loses 100*10 = 1000 cents to the people who bet on a victory margin of 2. Hence, the net gain is 49000 cents.</p></li>
<li><p>{100,100,100,100} <br>
{5,5,5,5}
0 <br>
Returns: 29500</p></li>
<li><p>{5000,5000} <br>
{100,2}
0 <br>
Returns: 0</p></li>
<li><p>{100} <br>
{10}
0 <br>
Returns: -1000 <br>
The company doesn't gain anything! It has to pay the people who bet on the only outcome possible. It pays 100*10 cents. Hence, the net gain is -1000. (Negative indicates loss.)</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class BettingMoney {  
    public:
        int moneyMade(vector&lt;int&gt; amounts, vector&lt;int&gt; centsPerDollar, int finalResult) {
            int profit = 0;
            for (int i = 0; i &lt; amounts.size(); ++i) {
                if (i == finalResult) {
                    profit -= (amounts[i] * centsPerDollar[i]);
                } else {
                    profit += (amounts[i] * 100);
                }
            }
            return profit;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/bettingname/</link><guid isPermaLink="false">99b30a41-e004-409d-a143-0e90ec6c8f90</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 05:18:42 GMT</pubDate></item><item><title><![CDATA[UserName]]></title><description><![CDATA[<p>Used In:    SRM 203 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You are implementing the member registration system of an online dating site. When a new member signs up, it is possible that she initially chooses the same username as an existing member. The system must then inform the new member of the conflict and suggest a variant of the chosen name with a number attached to the end.</p>

<p>If an existing member is named "FunkyMonkey", for example, and a new member wants the same username, the simplest suggestion the system can make is "FunkyMonkey1". If there is already a member by that name, the system must suggest "FunkyMonkey2", unless that variant is also taken. If all names from "FunkyMonkey1" through "FunkyMonkey9" are taken as well as the original "FunkyMonkey", the system moves on to consider "FunkyMonkey10", and so on. The goal is to use the smallest possible number in the variant. Note that each username consists of letters (the characters from 'a' to 'z' and from 'A' to 'Z') and numerals ('0' to '9').</p>

<p>You are given a String[], existingNames, containing all usernames that have already been registered in the system. You are also given a single String, newName, containing the username that a new member wants to use. In the event of a conflict, this member will accept the suggestion offered by your system in accordance with the principles above. Return a String containing the username finally assigned to the new member.</p>

<h6 id="definition">Definition</h6>

<p>Class:    UserName <br>
Method:    newMember <br>
Parameters:    String[], String <br>
Returns:    String <br>
Method signature:    String newMember(String[] existingNames, String newName) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>The constraints rule out names that end in a number with a leading zero, such as "grokster006" and "bart0".</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>existingNames contains between 1 and 50 elements, inclusive</li>
<li>each element of existingNames is between 1 and 50 characters long, inclusive</li>
<li>the only characters permitted in elements of existingNames are 'a' to 'z', 'A' to 'Z', and '0' to '9'</li>
<li>no element of existingNames ends in a number that has a leading zero</li>
<li>newName is between 1 and 50 characters long, inclusive</li>
<li>the only characters permitted in newName are 'a' to 'z' and 'A' to 'Z'</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{"MasterOfDisaster", "DingBat", "Orpheus", "WolfMan", "MrKnowItAll"} <br>
"TygerTyger"
Returns: "TygerTyger" <br>
"TygerTyger" is available.</p></li>
<li><p>{"MasterOfDisaster", "TygerTyger1", "DingBat", "Orpheus", <br>
"TygerTyger", "WolfMan", "MrKnowItAll"}
"TygerTyger"
Returns: "TygerTyger2" <br>
"TygerTyger" and "TygerTyger1" are taken.</p></li>
<li><p>{"TygerTyger2000", "TygerTyger1", "MasterDisaster", "DingBat", <br>
"Orpheus", "WolfMan", "MrKnowItAll"}
"TygerTyger"
Returns: "TygerTyger" <br>
There are higher-numbered variants of "TygerTyger", but the base name is available.</p></li>
<li><p>{"grokster2", "BrownEyedBoy", "Yoop", "BlueEyedGirl", <br>
"grokster", "Elemental", "NightShade", "Grokster1"}
"grokster"
Returns: "grokster1" <br>
Note that "Grokster1" is not the same as "grokster1".</p></li>
<li><p>{"Bart4", "Bart5", "Bart6", "Bart7", "Bart8", "Bart9", "Bart10", <br>
"Lisa", "Marge", "Homer", "Bart", "Bart1", "Bart2", "Bart3",
"Bart11", "Bart12"}
"Bart"
Returns: "Bart13"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;

using namespace std;

class UserName {  
    private:
        string intToString(int n) {
            ostringstream oss;
            oss &lt;&lt; n;
            return oss.str();
        }
    public:
        string newMember(vector&lt;string&gt; existingNames, string newName) {
            if (find(existingNames.begin(), existingNames.end(), 
               newName) == existingNames.end()) {
                return newName;
            }
            int i = 1;
            while (find(existingNames.begin(), existingNames.end(), 
            newName + intToString(i++)) != existingNames.end());
            return newName + intToString(--i);
        }   
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/username/</link><guid isPermaLink="false">be1ed185-8877-42a7-9d89-8f80236c99b0</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 04:18:37 GMT</pubDate></item><item><title><![CDATA[PIGBANK]]></title><description><![CDATA[<p>Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid.</p>

<p>But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!</p>

<h6 id="input">Input</h6>

<p>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it's weight in grams.</p>

<h6 id="output">Output</h6>

<p>Print exactly one line of output for each test case. The line must contain the sentence "The minimum amount of money in the piggy-bank is X." where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line "This is impossible.".</p>

<p>Example</p>

<p>Input: <br>
3 <br>
10 110 <br>
2 <br>
1 1 <br>
30 50 <br>
10 110 <br>
2 <br>
1 1 <br>
50 30 <br>
1 6 <br>
2 <br>
10 3 <br>
20 4</p>

<p>Output: <br>
The minimum amount of money in the piggy-bank is 60. <br>
The minimum amount of money in the piggy-bank is 100. <br>
This is impossible.</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int E,F;
        cin &gt;&gt; E &gt;&gt; F;
        F -= E;
        vector&lt;int&gt; dp(F + 1, 100000000);
        int N;
        cin &gt;&gt; N;
        for (int i = 0; i &lt; N; ++i) {
            int p, w;
            cin &gt;&gt; p &gt;&gt; w;
            if (dp[w] &gt; p) {
                dp[w] = p;
                for (int j = 1; j &lt;= F - w; ++j) {
                    if(dp[j + w] &gt; dp[j] + dp[w]) {
                        dp[j + w] = dp[j] + dp[w];
                    }
                }
            }
        }
        if(dp[F] &lt; 100000000) {
            cout &lt;&lt; "The minimum amount of money in the piggy-bank is " &lt;&lt; dp[F] &lt;&lt; ".\n";
        } else {
            cout &lt;&lt; "This is impossible.\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/29/pigbank/</link><guid isPermaLink="false">44f5c2a6-ccfd-484d-b43f-343a3c927f1e</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 29 Nov 2014 13:08:54 GMT</pubDate></item><item><title><![CDATA[PARTY]]></title><description><![CDATA[<p>You just received another bill which you cannot pay because you lack the money. Unfortunately, this is not the first time to happen, and now you decide to investigate the cause of your constant monetary shortness. The reason is quite obvious: the lion's share of your money routinely disappears at the entrance of party localities. </p>

<p>You make up your mind to solve the problem where it arises, namely at the parties themselves. You introduce a limit for your party budget and try to have the most possible fun with regard to this limit. </p>

<p>You inquire beforehand about the entrance fee to each party and estimate how much fun you might have there. The list is readily compiled, but how do you actually pick the parties that give you the most fun and do not exceed your budget? </p>

<p>Write a program which finds this optimal set of parties that offer the most fun. Keep in mind that your budget need not necessarily be reached exactly. Achieve the highest possible fun level, and do not spend more money than is absolutely necessary.</p>

<h6 id="input">Input</h6>

<p>The first line of the input specifies your party budget and the number n of parties. </p>

<p>The following n lines contain two numbers each. The first number indicates the entrance fee of each party. Parties cost between 5 and 25 francs. The second number indicates the amount of fun of each party, given as an integer number ranging from 0 to 10. </p>

<p>The budget will not exceed 500 and there will be at most 100 parties. All numbers are separated by a single space. </p>

<p>There are many test cases. Input ends with 0 0.</p>

<h6 id="output">Output</h6>

<p>For each test case your program must output the sum of the entrance fees and the sum of all fun values of an optimal solution. Both numbers must be separated by a single space.</p>

<p>Example</p>

<p>Input: <br>
50 10 <br>
12 3 <br>
15 8 <br>
16 9 <br>
16 6 <br>
10 2 <br>
21 9 <br>
18 4 <br>
12 4 <br>
17 8 <br>
18 9 </p>

<p>50 10 <br>
13 8 <br>
19 10 <br>
16 8 <br>
12 9 <br>
10 2 <br>
12 8 <br>
13 5 <br>
15 5 <br>
11 7 <br>
16 2</p>

<p>0 0</p>

<p>Output: <br>
49 26 <br>
48 32</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

pair&lt;int, int&gt; knapSack(int b, vector&lt;int&gt; budget, vector&lt;int&gt; fun) {  
    int n = budget.size();
    vector&lt;vector&lt;int&gt; &gt; k(n + 1, vector&lt;int&gt; (b + 1));
    for (int i = 0; i &lt;= n; ++i) {
        for (int j = 0; j &lt;= b; ++j) {
            if (i == 0 || j == 0) {
                k[i][j] = 0;
            } else if ((budget[i - 1] &lt;= j) &amp;&amp; (fun[i - 1] + k[i - 1][j - budget[i - 1]]) &gt; k[i - 1][j]) {
                k[i][j] = fun[i - 1] + k[i - 1][j - budget[i - 1]];
            } else {
                k[i][j] = k[i - 1][j];
            }
        }
    }
    int ans = 0;
    for (int i = 0; i &lt;= b; ++i) {
        if (k[n][i] == k[n][b]) {
            ans = i;
            break;
        }
    }
    return make_pair(ans, k[n][b]);
}

int main() {  
    int b, p;
    while ((cin &gt;&gt; b &gt;&gt; p) &amp;&amp; !(b == 0 &amp;&amp; p == 0)) {
        vector&lt;int&gt; budget(p),
                    fun(p);
        for (int i = 0; i &lt; p; ++i) {
            cin &gt;&gt; budget[i] &gt;&gt; fun[i];
        }
        pair&lt;int, int&gt; ans = knapSack(b, budget, fun);
        cout &lt;&lt; ans.first &lt;&lt; " " &lt;&lt; ans.second &lt;&lt; "\n";
    } 
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/29/party/</link><guid isPermaLink="false">1efbd2f9-8f70-4162-bc1e-79717acbe02e</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sat, 29 Nov 2014 11:37:15 GMT</pubDate></item><item><title><![CDATA[CRDS]]></title><description><![CDATA[<p>Maricruz have a lot of cards, she always uses her cards to build pyramids as shown in the following image:</p>

<p><img src="http://code-jedi.chintanghate.me/content/images/2014/11/francky-cards.png" alt="Cards"></p>

<p>A pyramid card of 3 levels. <br>
She always wonder how many cards does she need to make a pyramid card of N levels. Your task is to answer that question.</p>

<h6 id="input">Input</h6>

<p>The first line of the input contains an integer 1&lt;= T &lt;= 1,000. Each of the following T lines will have an integer 1&lt;= N &lt;= 1,000,000.</p>

<h6 id="output">Output</h6>

<p>For each case, output a single line consisting of the number of cards needed to build a pyramid card of level N modulo 1,000,007.</p>

<p>Example</p>

<p>Input: <br>
2 <br>
3 <br>
7</p>

<p>Output: <br>
15 <br>
77</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        unsigned long long levels;
        cin &gt;&gt; levels;
        unsigned long long cards = 
        (((levels * (levels + 1) / 2) * 3) - levels);
        cout &lt;&lt; cards % 1000007 &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/crds/</link><guid isPermaLink="false">80d9e6f9-0109-4490-a9b5-32d931259a55</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 17:25:46 GMT</pubDate></item><item><title><![CDATA[EGYPIZZA]]></title><description><![CDATA[<p>Abotrika is having a party because his team won the african cup so he is inviting his friends to eat some pizza. Unfortunately, Abotrika's friends can't eat an entire pizza but all of them know exactly how much pizza they can eat and insist on getting the exact amount of pizza but Abotrika eats one complete pizza and all of them wants his amount of pizza in one slice.</p>

<p>Their requests break down to three different pizza slices-either one quarter or a half or three quarters of pizza. write a program that will help Abotrika to find out what is the minimal number of pizzas he has to order so that everyone gets exact amount of pizza they want.</p>

<h6 id="input">Input</h6>

<p>First line contains an integer N, 0&lt;=N&lt;=10000, number of friends. In each of next N lines there is amount of pizza that each of Abotrika's friends wants to eat,that is the fraction 1/4, 1/2 or 3/4.</p>

<h6 id="output">Output</h6>

<p>In the first and only line you should write the minimal number of pizzas Abotrika has order don't forget to order one complete pizza for Abotrika</p>

<p>Example</p>

<p>Input: <br>
3 <br>
1/2 <br>
3/4 <br>
3/4</p>

<p>Output: <br>
4</p>

<p>Input: <br>
5 <br>
1/2 <br>
3/4 <br>
1/2 <br>
1/4 <br>
1/4</p>

<p>Output: <br>
4</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {  
    int N;
    cin &gt;&gt; N;
    long long a = 1,
              q = 0,
              h = 0,
              t = 0;
    for (;N--;) {
        string s;
        cin &gt;&gt; s;
        if (s == "1/2") {
            ++h;
        } else if (s == "3/4") {
            ++t;
        } else {
            ++q;
        }
    }
    a += h / 2;
    a += (h % 2);
    if (h % 2 == 1) {
        q -= 2;
    }
    if (t &gt;= q) {
        a += t;
    } else {
        a += t;
        q -= t;
        a += q/4;
        a += (q % 4 &gt; 0 ? 1 : 0);
    }
    cout &lt;&lt; a &lt;&lt; "\n";
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/egypizza/</link><guid isPermaLink="false">848e8203-7cb7-4208-8e48-e6956466548d</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 15:38:00 GMT</pubDate></item><item><title><![CDATA[OLOLOL]]></title><description><![CDATA[<p>Onotole has a lot of pyani. Each pyani has a number, writing on it. Pyanis with equal numbers are indistinguishable. Onotole knows everything, so, he knows that each pyani appeared twice, and only one pyani is unique. He wants to get вздръжни эффект, and he needs the unique pyani. Given the list of pyanis denote which one of them appeared once (it is guaranteed that other pyanis appeared twice).</p>

<h6 id="input">Input</h6>

<p>First line of input contains number of pyanis N&lt;=500 000. Next N lines contain a single positive integer 1 &lt;= Pi &lt;= 10^9.</p>

<h6 id="output">Output</h6>

<p>Output one positive integer on pyani, which appeared once.</p>

<p>Example</p>

<p>Input: <br>
3 <br>
1 <br>
8 <br>
1</p>

<p>Output: <br>
8</p>

<p>Onotole has found not optimal AC algorithms, so all solutions will be rejudged. He is watching you.</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;

using namespace std;

int main() {  
    int n;
    scanf("%d",&amp;n);
    long long x, res = 0;
    for (;n--;) {
        scanf("%lld",&amp;x);
        res ^= x;
    }
    cout &lt;&lt; res &lt;&lt; "\n";
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/ololol/</link><guid isPermaLink="false">d8be6bbf-e8dd-4d91-b1b3-1098c55c5425</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 13:18:27 GMT</pubDate></item><item><title><![CDATA[HYPNOS]]></title><description><![CDATA[<p>The process of “breaking” an integer is defined as summing the squares of its digits. For example, the result of breaking the integer 125 is (12 + 22 + 52) = 30. An integer N is happy if after “breaking” it repeatedly the result reaches 1. If the result never reaches 1 no matter how many times the “breaking” is repeated, then N is not a happy number.</p>

<h6 id="task">Task</h6>

<p>Write a program that given an integer N, determines whether it is a happy number or not.</p>

<h6 id="constraints">Constraints</h6>

<p>2 ≤ N ≤ 2,147,483,647</p>

<h6 id="input">Input</h6>

<p>A single line containing a single integer N.</p>

<h6 id="output">Output</h6>

<p>A single line containing a single integer T which is the number of times the process had to be done to determine that N is happy, or -1 if N is not happy.</p>

<p>Example</p>

<p>Input: <br>
19</p>

<p>Output: <br>
4</p>

<p>1) 19   : 12 + 92 = 82 <br>
2) 82   : 82 + 22 = 68 <br>
3) 68   : 62 + 82 = 100 <br>
4) 100 : 12 + 02 + 02 = 1</p>

<p>The solution is 4 because we discovered that the integer 19 is happy after we repeated the process 4 <br>
times.</p>

<p>Example</p>

<p>Input: <br>
204</p>

<p>Output: <br>
-1</p>

<p>204 –> 20 –> 4 –> 16 –> 37 –> 58 –> 89 –> 145 –> 42 –> 20 –> 4 –> 16 –> 37 –> 58 –> 89 –> 145 ……..</p>

<p>204 is not a happy number because after breaking it several times the results start repeating so we can deduce that if we continue breaking it, the result will never reach 1.</p>

<p>Number of test cases is 32.</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;set&gt;

using namespace std;

typedef long long ll;

ll breakNumber(ll N) {  
    ll res = 0;
    while (N != 0) {
        int n = N % 10;
        res += (n * n);
        N /= 10;
    }
    return res;
}

int main() {  
    int N;
    cin &gt;&gt; N;
    set&lt;ll&gt; pows;
    pows.insert(N);
    ll count = 0;
    while (N != 1) {
        N = breakNumber(N);
        if (pows.find(N) != pows.end()) {
            count = -1;
            break;
        } else {
            pows.insert(N);
            ++count;
        }
    }
    cout &lt;&lt; count &lt;&lt; "\n";
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/hypnos/</link><guid isPermaLink="false">cb4b527e-e33c-4e14-b403-967f3a1b9757</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 13:09:53 GMT</pubDate></item><item><title><![CDATA[BITMAP]]></title><description><![CDATA[<p>There is given a rectangular bitmap of size n*m. Each pixel of the bitmap is either white or black, but at least one is white. The pixel in i-th line and j-th column is called the pixel (i,j). The distance between two pixels p1=(i1,j1) and p2=(i2,j2) is defined as:</p>

<p>d(p1,p2)=|i1-i2|+|j1-j2|.</p>

<h6 id="task">Task</h6>

<p>Write a program which:</p>

<ul>
<li>reads the description of the bitmap from the standard input,</li>
<li>for each pixel, computes the distance to the nearest white pixel,</li>
<li>writes the results to the standard output.</li>
</ul>

<h6 id="input">Input</h6>

<p>The number of test cases t is in the first line of input, then t test cases follow separated by an empty line. In the first line of each test case there is a pair of integer numbers n, m separated by a single space, 1&lt;=n &lt;=182, 1&lt;=m&lt;=182. In each of the following n lines of the test case exactly one zero-one word of length m, the description of one line of the bitmap, is written. On the j-th position in the line (i+1), 1 &lt;= i &lt;= n, 1 &lt;= j &lt;= m, is '1' if, and only if the pixel (i,j) is white.</p>

<h6 id="output">Output</h6>

<p>In the i-th line for each test case, 1&lt;=i&lt;=n, there should be written m integers f(i,1),...,f(i,m) separated by single spaces, where f(i,j) is the distance from the pixel (i,j) to the nearest white pixel.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
3 4 <br>
0001 <br>
0011 <br>
0110</p>

<p>Output: <br>
3 2 1 0 <br>
2 1 0 0 <br>
1 0 0 1</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

void bfs(vector&lt;vector&lt;int&gt; &gt; &amp;dist, int x, int y, int d) {  
    int n = dist.size(),
        m = dist[0].size();
    if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; dist[x][y] &gt; d) {
        dist[x][y] = d;
        bfs(dist, x + 1, y, d + 1);
        bfs(dist, x - 1, y, d + 1);
        bfs(dist, x, y + 1, d + 1);
        bfs(dist, x, y - 1, d + 1);
    }
    return;
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int n, m;
        cin &gt;&gt; n &gt;&gt; m;
        vector&lt;string&gt; grid(n);
        vector&lt;vector&lt;int&gt; &gt; dist(n, vector&lt;int&gt; (m, 400));
        for (int i = 0; i &lt; n; ++i) {
            cin &gt;&gt; grid[i];
        }
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; m; ++j) {
                if (grid[i][j] == '1') {
                    bfs(dist, i, j, 0);
                }
            }
        }
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; m; ++j) {
                cout &lt;&lt; dist[i][j] &lt;&lt; " ";
            }
            cout &lt;&lt; "\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/28/bitmap/</link><guid isPermaLink="false">09df0738-8c1b-4b87-8029-6ae6968f1869</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Fri, 28 Nov 2014 04:07:25 GMT</pubDate></item><item><title><![CDATA[ACODE]]></title><description><![CDATA[<p>Alice and Bob need to send secret messages to each other and are discussing ways to encode their messages:  </p>

<pre><code>Alice: “Let’s just use a very simple code: We’ll assign ‘A’ the code word 1, ‘B’ will be 2, and so on down to ‘Z’ being assigned 26.”

Bob: “That’s a stupid code, Alice. Suppose I send you the word ‘BEAN’ encoded as 25114. You could decode that in many different ways!”

Alice: “Sure you could, but what words would you get? Other than ‘BEAN’, you’d get ‘BEAAD’, ‘YAAD’, ‘YAN’, ‘YKD’ and ‘BEKD’. I think you would be able to figure out the correct decoding. And why would you send me the word ‘BEAN’ anyway?”

Bob: “OK, maybe that’s a bad example, but I bet you that if you got a string of length 5000 there would be tons of different decodings and with that many you would find at least two different ones that would make sense.”

Alice: “How many different decodings?”

Bob: “Jillions!”  
</code></pre>

<p>For some reason, Alice is still unconvinced by Bob’s argument, so she requires a program that will determine how many decodings there can be for a given string using her code.</p>

<h6 id="input">Input</h6>

<p>Input will consist of multiple input sets. Each set will consist of a single line of at most 5000 digits representing a valid encryption (for example, no line will begin with a 0). There will be no spaces between the digits. An input line of ‘0’ will terminate the input and should not be processed.</p>

<h6 id="output">Output</h6>

<p>For each input set, output the number of possible decodings for the input string. All answers will be within the range of a 64 bit signed integer.</p>

<p>Example</p>

<p>Input: <br>
25114 <br>
1111111111 <br>
3333333333 <br>
0</p>

<p>Output: <br>
6 <br>
89 <br>
1</p>

<hr>

<h6 id="usingdynamicprogramming">Using Dynamic Programming:</h6>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int main() {  
    string s;
    while ((cin &gt;&gt; s) &amp;&amp; s != "0") {
        vector&lt;int&gt; ones(s.size(), 0),
                    tens(s.size(), 0),
                    ways(s.size(), 0);
        for (int i = 0; i &lt; s.size(); ++i) {
            ones[i] = s[i] - '0';
        }
        for (int i = 1; i &lt; s.size(); ++i) {
            tens[i] = 10 * ones[i - 1] + ones[i];
        }
        ways[0] = 1;
        if (s.size() &gt; 1) {
            ways[1] = (ones[1] != 0 ? 1 : 0);
            if (tens[1] &gt; 9 &amp;&amp; tens[1] &lt; 27) {
                ++ways[1];
            }
            for (int i = 2; i &lt; s.size(); ++i) {
                ways[i] = (ones[i] != 0 ? ways[i - 1] : 0);
                if (tens[i] &gt; 9 &amp;&amp; tens[i] &lt; 27) {
                    ways[i] += ways[i - 2];
                }
            }
        }
        cout &lt;&lt; ways.back() &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>

<hr>

<h6 id="using2variables">Using 2 variables:</h6>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {  
    string s;
    while ((cin &gt;&gt; s) &amp;&amp; s != "0") {
        int good = 1,
            bad = 0;
        for (int i = 1; i &lt; s.size(); ++i) {
            int n = (10 * (s[i - 1] - '0') + (s[i] - '0'));
            if (s[i] == '0') {
                if (n &gt;= 27) {
                    good = 0;
                    bad = 0;
                    break;
                }
                bad = good;
                good = 0; 
            } else if (n &lt; 27 &amp;&amp; n &gt; 9) {
                good += bad;
                bad = good - bad;
            } else {
                good += bad;
                bad = 0;
            }
        }
        cout &lt;&lt; good + bad &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/acode/</link><guid isPermaLink="false">66e0fc84-f274-4962-8e98-51a5c0ee2e29</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Thu, 27 Nov 2014 07:31:59 GMT</pubDate></item><item><title><![CDATA[MARBLES]]></title><description><![CDATA[<p>Hänschen dreams he is in a shop with an infinite amount of marbles. He is allowed to select n marbles. There are marbles of k different colors. From each color there are also infinitely many marbles. Hänschen wants to have at least one marble of each color, but still there are a lot of possibilities for his selection. In his effort to make a decision he wakes up. Now he asks you how many possibilites for his selection he would have had. Assume that marbles of equal color can't be distinguished, and the order of the marbles is irrelevant.</p>

<h6 id="input">Input</h6>

<p>The first line of input contains a number T &lt;= 100 that indicates the number of test cases to follow. Each test case consists of one line containing n and k, where n is the number of marbles Hänschen selects and k is the number of different colors of the marbles. You can assume that 1&lt;=k&lt;=n&lt;=1000000.</p>

<h6 id="output">Output</h6>

<p>For each test case print the number of possibilities that Hänschen would have had. You can assume that this number fits into a signed 64 bit integer.</p>

<p>Example</p>

<p>Input: <br>
2 <br>
10 10 <br>
30 7</p>

<p>Output: <br>
1 <br>
475020</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

unsigned long long gcd(unsigned long long a, unsigned long long b) {  
    return (b == 0 ? a : gcd(b, a % b));
}

unsigned long long NCR(unsigned long long N, unsigned long long K) {  
    if(K &gt; N) {
        return 0;
    }
    K = min(N - K, K);
    unsigned long long p = 1;
    for (unsigned long long i = 1; i &lt;= K ; ++i) {
        unsigned long long g = gcd(p, i);
        p /= g;
        p *= (N - i + 1) / (i / g);
    }
    return p;
}

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        unsigned long long N, K;
        cin &gt;&gt; N &gt;&gt; K;
        --N, --K;
        cout &lt;&lt; NCR(N, K) &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/marbles/</link><guid isPermaLink="false">bea21dd8-92e3-4b40-a042-f2f4e9f409fd</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Thu, 27 Nov 2014 04:19:00 GMT</pubDate></item><item><title><![CDATA[BYTESM2]]></title><description><![CDATA[<p>One of the secret chambers in Hogwarts is full of philosopher’s stones. The floor of the chamber is covered by h × w square tiles, where there are h rows of tiles from front (first row) to back (last row) and w columns of tiles from left to right. Each tile has 1 to 100 stones on it. Harry has to grab as many philosopher’s stones as possible, subject to the following restrictions:</p>

<ul>
<li>He starts by choosing any tile in the first row, and collects the philosopher’s stones on that tile. Then, he moves to a tile in the next row, collects the philosopher’s stones on the tile, and so on until he reaches the last row.</li>
<li>When he moves from one tile to a tile in the next row, he can only move to the tile just below it or diagonally to the left or right.</li>
</ul>

<p>Given the values of h and w, and the number of philosopher’s stones on each tile, write a program to compute the maximum possible number of philosopher’s stones Harry can grab in one single trip from the first row to the last row.</p>

<h6 id="input">Input</h6>

<p>The first line consists of a single integer T, the number of test cases. In each of the test cases, the first line has two integers. The first integer h (1&lt;=h&lt;=100) is the number of rows of tiles on the floor. The second integer w (1&lt;=w&lt;=100) is the number of columns of tiles on the floor. Next, there are h lines of inputs. The ith line of these, specifies the number of philosopher’s stones in each tile of the ith row from the front. Each line has w integers, where each integer m (0&lt;=m&lt;=100) is the number of philosopher’s stones on that tile. The integers are separated by a space character.</p>

<h6 id="output">Output</h6>

<p>The output should consist of T lines, (1&lt;=T&lt;=100), one for each test case. Each line consists of a single integer, which is the maximum possible number of philosopher’s stones Harry can grab, in one single trip from the first row to the last row for the corresponding test case.</p>

<p>Example</p>

<p>Input: <br>
1 <br>
6 5 <br>
3 1 7 4 2 <br>
2 1 3 1 1 <br>
1 2 2 1 8 <br>
2 2 1 5 3 <br>
2 1 4 4 4 <br>
5 2 7 5 1</p>

<p>Output: <br>
32     </p>

<p>//7+1+8+5+4+7=32</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {  
    int T;
    cin &gt;&gt; T;
    for (;T--;) {
        int h, w;
        cin &gt;&gt; h &gt;&gt; w;
        vector&lt;vector&lt;int&gt; &gt; grid(h, vector&lt;int&gt;(w));
        for (int i = 0; i &lt; h; ++i) {
            for (int j = 0; j &lt; w; ++j) {
                cin &gt;&gt; grid[i][j];
            }
        }
        for (int i = h - 2; i &gt;= 0; --i) {
            for (int j = 0; j &lt; w; ++j) {
                int maximum = 0;
                if (j - 1 &gt;= 0 &amp;&amp; grid[i + 1][j - 1] &gt; maximum) {
                    maximum = grid[i + 1][j - 1];
                }
                if (grid[i + 1][j] &gt; maximum) {
                    maximum = grid[i + 1][j];
                }
                if (j + 1 &lt; w &amp;&amp; grid[i + 1][j + 1] &gt; maximum) {
                    maximum = grid[i + 1][j + 1];
                }
                grid[i][j] += maximum;
            }
        }
        cout &lt;&lt; *max_element(grid[0].begin(), grid[0].end()) 
             &lt;&lt; "\n";
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/bytesm2/</link><guid isPermaLink="false">4ee19633-c9f6-4361-996d-71226822d994</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 20:01:46 GMT</pubDate></item><item><title><![CDATA[JAVAC]]></title><description><![CDATA[<p>Apologists of Java and C++ can argue for hours proving each other that their programming language is the best one. Java people will tell that their programs are clearer and less prone to errors, while C++ people will laugh at their inability to instantiate an array of generics or tell them that their programs are slow and have long source code.</p>

<p>Another issue that Java and C++ people could never agree on is identifier naming. In Java a multiword identifier is constructed in the following manner: the first word is written starting from the small letter, and the following ones are written starting from the capital letter, no separators are used. All other letters are small. Examples of a Java identifier are javaIdentifier, longAndMnemonicIdentifier, name, nEERC.</p>

<p>Unlike them, C++ people use only small letters in their identifiers. To separate words they use underscore character ‘<em>’. Examples of C++ identifiers are c</em>identifier, long<em>and</em>mnemonic<em>identifier, name (you see that when there is just one word Java and C++ people agree), n</em>e<em>e</em>r_c.</p>

<p>You are writing a translator that is intended to translate C++ programs to Java and vice versa. Of course, identifiers in the translated program must be formatted due to its language rules — otherwise people will never like your translator.</p>

<p>The first thing you would like to write is an identifier translation routine. Given an identifier, it would detect whether it is Java identifier or C++ identifier and translate it to another dialect. If it is neither, then your routine should report an error. Translation must preserve the order of words and must only change the case of letters and/or add/remove underscores.</p>

<h6 id="input">Input</h6>

<p>The input file consists of several lines that contains an identifier. It consists of letters of the English alphabet and underscores. Its length does not exceed 100.</p>

<h6 id="output">Output</h6>

<p>If the input identifier is Java identifier, output its C++ version. If it is C++ identifier, output its Java version. If it is none, output 'Error!' instead.</p>

<p>Example</p>

<p>Input: <br>
long_and_mnemonic_identifier <br>
anotherExample <br>
i <br>
bad_Style</p>

<p>Output: <br>
longAndMnemonicIdentifier <br>
another_example <br>
i <br>
Error!</p>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cctype&gt;

using namespace std;

bool isJavaIdentifier(string s) {  
    if (!islower(s[0])) {
        return false;
    }
    for (int i = 0; i &lt; s.size(); ++i) {
        if (!isalpha(s[i])) {
            return false;
        }
    }
    return true;
}

bool isCIdentifier(string s) {  
    if (!islower(s[0])) {
        return false;
    }
    for (int i = 0; i &lt; s.size(); ++i) {
        if (!islower(s[i]) &amp;&amp; s[i] != '_') {
            return false;
        }
        if (s[i] == '_' &amp;&amp; !islower(s[i+1])) {
            return false;
        }
    }
    return true;
}

int main() {  
    string s;
    while (cin &gt;&gt; s) {
        bool java = isJavaIdentifier(s),
             c = isCIdentifier(s);
        if (!java &amp;&amp; !c) {
            cout &lt;&lt; "Error!\n";
        } else if (java) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if (isupper(s[i])) {
                    o += '_';
                }
                o += tolower(s[i]);
            }
            cout &lt;&lt; o &lt;&lt; "\n";
        } else if (c) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] == '_') {
                    ++i;
                    o += toupper(s[i]);
                } else {
                    o += s[i];
                }
            }
            cout &lt;&lt; o &lt;&lt; "\n";
        }
    }
    return 0;
}
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/27/javac/</link><guid isPermaLink="false">4077835d-1bca-4079-96f6-0e3e12e31991</guid><category><![CDATA[SPOJ]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 26 Nov 2014 18:49:32 GMT</pubDate></item></channel></rss>