<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Chintan Ghate - Code Jedi]]></title><description><![CDATA[Code, algorithms and design.]]></description><link>http://code-jedi.chintanghate.me/</link><generator>Ghost 0.5</generator><lastBuildDate>Wed, 03 Dec 2014 18:04:04 GMT</lastBuildDate><atom:link href="http://code-jedi.chintanghate.me/author/chintan/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Jumper]]></title><description><![CDATA[<p>Used In:    SRM 158 <br>
Used As:    Division I Level Three</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>In a certain video game, a jumping player must jump across an area which has floating hoverpads in it. The hoverpads are organized on the screen into evenly spaced rows that move left or right across the screen with a constant speed and direction. The jumper can only cross the area by jumping onto the pads. If the jumper lands on a space that is not a pad, he loses the game. If the jumper is standing on a pad that goes off the side of the screen, he loses the game. The jumper starts out on the bottom of the screen in a non-moving row of solid ground. He must use the pads to jump all the way to the top of the screen, where there is another non-moving row of solid ground. The score of the game depends on how fast the player jumps to the other side.</p>

<p>The screen is made up of 1x1 blocks and is 20 blocks wide. Each pad is comprised of 1 or more 1x1 blocks in a horizontal line. The jumper can only jump a distance of 1 block at a time, and can only jump from one row to another, or to another part of the pad he is currently on that is 1 block away. At the beginning of each second, the jumper either jumps or does not move, and then the pads move a certain distance for the remainder of the second. Jumping takes no time at all, but the jumper must wait for the next second to move again.</p>

<p>You will be given three arguments. patterns will be a String[], with each element having a 5-character pattern in it. In each pattern, a '#' represents hoverpad, and a '.' represents empty space. speeds will be a int[] which represents the speeds of each of the patterns in blocks per second. Positive speeds are to the right, negative speeds are to the left. rows is a String where each character specifies what pattern and speed each row has (Note that this does not include the non-moving solid ground on the bottom and top of the screen). Characters that appear earlier in rows represent rows that are closer to the player's starting row. For example, if rows starts with "01", it would mean that the first row (the row closest to the starting row) is using element 0 of patterns and speeds to define its hoverpads, and the next row is using element 1.</p>

<p>Each row starts out filled with repeated values of its given pattern. For example, the pattern "#..##" would start out as:</p>

<p>"#..###..###..###..##"</p>

<p>The speed determines how fast and in what direction the pads move. As the pads move off the screen, more pads move in on the opposite side of the screen to fill in the space. The pads which move in take on exactly the same pattern as the pads that moved out. For example, if the above pattern had a speed of 3, then ".##" would move off of the right side of the screen and ".##" would move in on the left side, to get:</p>

<p>".###..###..###..###."</p>

<p>Note that if the player were standing on either of the blocks which moved off the screen, he would lose the game.</p>

<p>The character starts on the bottom of the screen in the leftmost column on solid ground (which has no holes and does not move). He can wait any amount of time before jumping onto the first row of hoverpads, and may jump left or right on the solid ground. The player may also jump back to solid ground after jumping to a hoverpad. The player wins if he jumps off of the last row of pads to the solid ground at the top of the screen.</p>

<p>Your method should return the minimum time it takes to get from the bottom to the top of the screen, or -1 if it is not possible.</p>

<h6 id="definition">Definition</h6>

<p>Class:    Jumper <br>
Method:    minTime <br>
Parameters:    String[], int[], String <br>
Returns:    int <br>
Method signature:    int minTime(String[] patterns, int[] speeds, String rows) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>Since it takes no time to jump, the pads do not move while the actual jump is occurring. They move after the jumper lands.</li>
<li>A pad with the player on it also moves the player.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>patterns will have between 1 and 4 elements, inclusive</li>
<li>Each element of patterns will consist of exactly 5 characters, and will only contain the characters '#' and '.'.</li>
<li>speeds will have the same number of elements as patterns.</li>
<li>Each element of speeds will be between -10 and 10, inclusive except 0.</li>
<li>rows will have between 2 and 20 characters, inclusive.</li>
<li>Each character in rows will be a digit between 0 and the number of elements in patterns - 1, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li>{"###..", "..###"} <br>
{1,1}
"01"
Returns: 5  </li>
</ol>

<pre><code>The screen looks like this at the beginning:

..###..###..###..###
###..###..###..###..
P###################  
The player can jump up once, and then both rows of pads move to the right 1 space. The screen is now:

#..###..###..###..##
.P##..###..###..###.
####################
The player can now jump twice to the right. By this time, the pads have moved over twice:

###..###..###..###..
#..##P..###..###..##
####################
Now, the player jumps up to the second row of pads:

.###..P##..###..###.
##..###..###..###..#
####################
And finally, jumps up one more time to victory.  
</code></pre>

<ol>
<li>{"###..", "..###"} <br>
{5,5}
"01"
Returns: 5 <br>
The player cannot follow the same pattern as above, because he would lose when the pads go off the right side of the screen. Instead, he can jump to the right twice, and then he has a straight path up. In the following sequence, remember that the pads move to the right 5 spaces, even though they do not appear to move from frame to frame:  </li>
</ol>

<pre><code>..###..###..###..###
###..###..###..###..  Start
P###################

..###..###..###..###
###..###..###..###..  Right
#P##################

..###..###..###..###
###..###..###..###..  Right
##P#################

..###..###..###..###
###..##P..###..###..  Up (pad carries player right 5 spaces)
####################

..###..###..P##..###
###..###..###..###..  Up (pad carries player right 5 spaces)
####################

Final jump up.  
</code></pre>

<ol>
<li><p>{"....#", "....#"} <br>
{4,5}
"0111"
Returns: 9 <br>
In this example, the only way to make it up to the top is to wait for the first row of pads to line up with the left-most column. Then the player barely has time to jump up through all three other rows of pads before jumping to the very top. It takes 4 seconds for the pads to line up with the player, so he waits for 4 seconds, then he jumps up 5 times to get to the top.</p></li>
<li><p>{"#....", "#...."} <br>
{-4,-5}
"0111"
Returns: 24 <br>
This is the same as the last example, except everything is reversed. Since the only safe place to jump off the bottom is the right-most square, the player must first jump right 19 spaces before jumping up 5 times.</p></li>
<li><p>{"#####","#####"} <br>
{10,10}
"01"
Returns: -1 <br>
Although a straight path exists, the player cannot jump up twice without hitting the wall on the right.</p></li>
<li><p>{"#####","#####","....."} <br>
{1,-1,1}
"01010101010101010102"
Returns: -1 <br>
Be careful of timeouts.</p></li>
<li><p>{"#....", "#....", "#...."} <br>
{5,-5,6}
"2012"
Returns: 12 <br>
Here, in order to use 12 jumps, the player must jump back at least once. One possible ordering of jumps is: <br>
Right, Right, Right, Right, Up, Up, Up, Stand, Down, Up, Up, Up.</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;

#define X front().first.first
#define Y front().first.second
#define T front().second

using namespace std;

class Jumper {

    private:
        int mod(int a, int b) {
            return a % b &lt; 0 ? a % b + b : a % b;
        }

        bool isValidPos(vector&lt;pair&lt;string,int&gt; &gt; patternNSpeed, int x, int y, int t) {
            if(x &lt; 0 || x &gt;= patternNSpeed.size()) {
                return false;
            }
            int s = patternNSpeed[x].second;
            if (y &lt; 0 || y &gt; 19 || y + s &lt; 0 || y + s &gt; 19) {
                return false;
            }
            string p = patternNSpeed[x].first;
            if (p[mod(y - t * s, 20)] != '#') {
                return false;
            }
            return true;
        }

    public:
        int minTime(vector&lt;string&gt; patterns, vector&lt;int&gt; speeds, string rows) {
            int n = rows.size();
            vector&lt;pair&lt;string,int&gt; &gt; patternNSpeed(n + 2);
            patternNSpeed[0] = patternNSpeed[n + 1] = make_pair("####################", 0);
            for (int i = 1; i &lt;= n; ++i) {
                int j = rows[i - 1] - '0';
                string p = patterns[j];
                int s = speeds[j];
                patternNSpeed[i] = make_pair(p + p + p + p, s);
            }   

            int x = 0,
                y = 0,
                t = 0;
            queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt; &gt; bfsQ;
            set&lt;pair&lt;pair&lt;int, int&gt;, int&gt; &gt; uniquePos;
            int Time = -1;
            bfsQ.push(make_pair(make_pair(x, y), t));
            while (!bfsQ.empty()) {
                x = bfsQ.X, y = bfsQ.Y, t = bfsQ.T;
                bfsQ.pop();
                if (x == n + 1) {
                    Time = t;
                    break;
                }
                if (t == 200) {
                    t = -1;
                    break;
                }
                pair&lt;pair&lt;int, int&gt;, int&gt; temp = make_pair(make_pair(x, y), t % 5);
                if (uniquePos.find(temp) != uniquePos.end()) {
                    if (isValidPos(patternNSpeed, x, y - 1, t)) {
                        bfsQ.push(make_pair(make_pair(x, y - 1 + patternNSpeed[x].second), t + 1));
                    }
                    continue;
                }
                uniquePos.insert(make_pair(make_pair(x, y), t % 5));

                if (y + patternNSpeed[x].second &gt;= 0 &amp;&amp; y + patternNSpeed[x].second &lt;= 19) {
                    bfsQ.push(make_pair(make_pair(x, y + patternNSpeed[x].second), t + 1));
                }
                if (isValidPos(patternNSpeed, x + 1, y, t)) {
                    bfsQ.push(make_pair(make_pair(x + 1, y + patternNSpeed[x + 1].second), t + 1));
                }
                if (isValidPos(patternNSpeed, x - 1, y, t)) {
                    bfsQ.push(make_pair(make_pair(x - 1, y + patternNSpeed[x - 1].second), t + 1));
                }
                if (isValidPos(patternNSpeed, x, y + 1, t)) {
                    bfsQ.push(make_pair(make_pair(x, y + 1 + patternNSpeed[x].second), t + 1));
                }
                if (isValidPos(patternNSpeed, x, y - 1, t)) {
                    bfsQ.push(make_pair(make_pair(x, y - 1 + patternNSpeed[x].second), t + 1));
                }
            }
            return Time;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/03/jumper/</link><guid isPermaLink="false">78d6e088-7b26-477b-9fc3-74a1cb1b400a</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Wed, 03 Dec 2014 17:58:14 GMT</pubDate></item><item><title><![CDATA[Twain]]></title><description><![CDATA[<p>Used In:    SRM 169 <br>
Used As:    Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Spelling in the English language doesn't make sense. Congress has enacted a plan for orthographical reform (loosely based on Mark Twain's plan for the improvement of English spelling) which will change the spelling of words in the English language gradually over the next 7 years. The plan is as follows:</p>

<h6 id="year1">Year 1:</h6>

<ul>
<li>If a word starts with "x", replace the "x" with a "z".</li>
<li>Change all remaining "x"s to "ks"s.</li>
</ul>

<h6 id="year2">Year 2:</h6>

<ul>
<li>Change all "y"s to "i"s.</li>
</ul>

<h6 id="year3">Year 3:</h6>

<ul>
<li>If a "c" is directly followed by an "e" or "i", change the "c" to an "s".</li>
</ul>

<h6 id="year4">Year 4:</h6>

<ul>
<li>If a "c" is directly followed by a "k", remove the "c". Keep applying this rule as necessary (Example: "cck" becomes "k".)</li>
</ul>

<h6 id="year5">Year 5:</h6>

<ul>
<li>If a word starts with "sch", change the "sch" to a "sk".</li>
<li>If a "ch" is directly followed by an "r", change the "ch" to a "k".</li>
<li>After applying the above rules, change all "c"s that are not directly followed by an "h", to a "k". (This includes all "c"s that are the last letter of a word.)</li>
</ul>

<h6 id="year6">Year 6:</h6>

<ul>
<li>If a word starts with "kn" change the "kn" to an "n".</li>
</ul>

<h6 id="year7">Year 7:</h6>

<ul>
<li>Change all double consonants of the same letter to a single consonant. A consonant is any letter that is not one of "a, e, i, o, u." (Example: "apple" becomes "aple"). Keep applying this rule as necessary (Example: "zzz" becomes "z".)</li>
</ul>

<p>The plan requires that rules for each year are followed in the order they are presented, and changes for each year occur after all the changes from previous years.</p>

<p>Write a class Twain, which contains a method getNewSpelling. getNewSpelling takes as parameters an int year representing the number of years that have passed since the plan to improve the English language began, and a String phrase representing the English phrase to convert. For the purposes of the plan, a word is a sequence of lowercase letters ('a'-'z') bounded by spaces or the start/end of phrase. The method returns a String representing the converted phrase.</p>

<h6 id="definition">Definition</h6>

<p>Class:    Twain <br>
Method:    getNewSpelling <br>
Parameters:    int, String <br>
Returns:    String <br>
Method signature:    String getNewSpelling(int year, String phrase) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>year will be between 0 and 7, inclusive</li>
<li>phrase will be between 0 and 50 characters, inclusive</li>
<li>phrase will contain only lowercase letters ('a'-'z') and spaces (' ').</li>
<li>phrase will not contain three or more of the same consonant in a row</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>1 <br>
"i fixed the chrome xerox by the cyclical church"
Returns: "i fiksed the chrome zeroks by the cyclical church" <br>
In year 1, the first "x" in "xerox" is changed to a "z". Then, the "x"s in "fixed" and "zerox" are changed to "ks"s.</p></li>
<li><p>2 <br>
"i fixed the chrome xerox by the cyclical church"
Returns: "i fiksed the chrome zeroks bi the ciclical church" <br>
In year 2, the "y"s in "by" and "cyclical" are changed to "i"s.</p></li>
<li><p>0 <br>
"this is unchanged"
Returns: "this is unchanged" <br>
Since the year is 0, no changes occur.</p></li>
<li><p>7 <br>
"sch kn x xschrx cknnchc cyck xxceci"
Returns: "sk n z zskrks nchk sik zksesi" <br>
In year 1, the phrase becomes "sch kn z zschrks cknnchc cyck zksceci" due to rules concerning the letter "x". In year 2, all "y"s are changed to "i"s yielding "sch kn z zschrks cknnchc cick zksceci". In year 3, "ce" and "ci" are changed to "se" and "si" yielding "sch kn z zschrks cknnchc sick zkssesi". In year 4, "ck" is changed to "k" and the phrase becomes "sch kn z zschrks knnchc sik zkssesi". In year 5, words that begin with "sch" are made to begin with "sk", "chr" is changed to "kr", and all "c"s not followed by an "h" are changed to "k" yielding "sk kn z zskrks knnchk sik zkssesi". In year 6, words that start with "kn" now start with "n" and the phrase becomes "sk n z zskrks nnchk sik zkssesi". Finally, in year 7, double consonants are removed yielding the final result.</p></li>
<li><p>7 <br>
"  concoction   convalescence   cyclical   cello   "
Returns: "  konkoktion   konvalesense   siklikal   selo   " <br>
Beware of extra spaces.</p></li>
<li><p>7 <br>
""
Returns: "" <br>
Don't forget the empty case.</p></li>
<li><p>7 <br>
"cck xzz aaaaa"
Returns: "k z aaaaa"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Twain {  
    private:
        string year1(string s) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if ((i == 0 || s[i - 1] == ' ' ) &amp;&amp; s[i] == 'x') {
                    o += "z";
                } else if (s[i] == 'x') {
                    o += "ks";
                } else {
                    o += s[i];
                }
            }
            return o;
        }
        string year2(string s) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] == 'y') {
                    o += 'i';
                } else {
                    o += s[i];
                }
            }
            return o;
        }
        string year3(string s) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] == 'c' &amp;&amp; i != s.size() - 1 &amp;&amp; (s[i + 1] == 'e' || s[i + 1] == 'i')) {
                    o += 's';
                } else {
                    o += s[i];
                }
            }
            return o;
        }
        string year4(string s) {
            string o = "";
            for (int i = s.size() - 1; i &gt;= 0; --i) {
                if (o.size() &gt; 0 &amp;&amp; o[0] == 'k' &amp;&amp; s[i] == 'c') {
                    continue;
                } else {
                    o = s[i] + o;
                }
            }
            return o;
        }
        string year5(string s) {
            string o = "";

            for (int i = 0; i &lt; s.size(); ++i) {
                if ((i == 0 || s[i - 1] == ' ') &amp;&amp; i &lt;= s.size() - 3 &amp;&amp; s[i] == 's' &amp;&amp; s[i + 1] == 'c' &amp;&amp; s[i + 2] == 'h') {
                    o += "sk";
                    i += 2;
                } else {
                    o += s[i];
                }
            }

            string o1 = "";
            for (int i = 0; i &lt; o.size(); ++i) {
                if (i &lt;= o.size() - 3 &amp;&amp; o[i] == 'c' &amp;&amp; o[i + 1] == 'h' &amp;&amp; o[i + 2] == 'r') {
                    o1 += "kr";
                    i += 2;
                } else {
                    o1 += o[i];
                }
            }
            for (int i = 0; i &lt; o1.size(); ++i) {
                if ((i != o1.size() - 1 &amp;&amp; o1[i] == 'c' &amp;&amp; o1[i + 1] != 'h') || (i == o1.size() - 1 &amp;&amp; o1[i] == 'c')) {
                    o1[i] = 'k';
                }
            }
            return o1;
        }
        string year6(string s) {
            string o = "";
            for (int i = 0; i &lt; s.size(); ++i) {
                if ((i == 0 || s[i - 1] == ' ') &amp;&amp;  i &lt;= s.size() - 2 &amp;&amp; s[i] == 'k' &amp;&amp; s[i + 1] == 'n') {
                    o += "n";
                    i += 1;
                } else {
                    o += s[i];
                }
            }
            return o;
        }
        string year7(string s) {
            string o = "";
            o += s[0];
            for (int i = 1; i &lt; s.size(); ++i) {
                if (s[i] != 'a' &amp;&amp; s[i] != 'e' &amp;&amp; s[i] != 'i' &amp;&amp; s[i] != 'o' &amp;&amp; s[i] != 'u' &amp;&amp; s[i] != ' ' &amp;&amp; s[i] == s[i - 1]) {
                    continue;
                } else {
                    o += s[i];
                }
            }
            return o;
        }
    public:
        string getNewSpelling(int year, string phrase) {
            if (phrase == "") {
                return phrase;
            }
            if (year == 0) {
                return phrase;
            }
            if (year &gt;= 1) {
                phrase = year1(phrase);
            }
            if (year &gt;= 2) {
                phrase = year2(phrase);
            }
            if (year &gt;= 3) {
                phrase = year3(phrase);
            }
            if (year &gt;= 4) {
                phrase = year4(phrase);
            }
            if (year &gt;= 5) {
                phrase = year5(phrase);
            }
            if (year &gt;= 6) {
                phrase = year6(phrase);
            }
            if (year &gt;= 7) {
                phrase = year7(phrase);
            }
            return phrase;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/02/twain/</link><guid isPermaLink="false">d68a33ab-cfce-48eb-a690-a3a92f7f59be</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Mon, 01 Dec 2014 19:52:01 GMT</pubDate></item><item><title><![CDATA[RecurrenceRelation]]></title><description><![CDATA[<p>Used In:    SRM 170 <br>
Used As:    Division I Level One , Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Consider a sequence {x0, x1, x2, ...}. A relation that defines some term xn in terms of previous terms is called a recurrence relation. A linear recurrence relation is one where the recurrence is of the form xn = ck-1xn-1 + ck-2xn-2 + ... + c0xn-k, where all the ci are real-valued constants, k is the length of the recurrence relation, and n is an arbitrary positive integer which is greater than or equal to k.</p>

<p>You will be given a int[] coefficients, indicating, in order, c0, c1, ..., ck-1. You will also be given a int[] initial, giving the values of x0, x1, ..., xk-1, and an int N. Your method should return xN modulo 10.</p>

<p>Note that the value of X modulo 10 equals the last digit of X if X is non-negative. However, if X is negative, this is not true; instead, X modulo 10 equals ((10 - ((-X) modulo 10)) modulo 10). For example, (-16) modulo 10 = ((10 - (16 modulo 10)) modulo 10) = (10 - 6) modulo 10 = 4.</p>

<p>More specifically, if coefficients is of size k, then the recurrence relation will be</p>

<p>xn = coefficients[k - 1] * xn-1 + coefficients[k - 2] * xn-2 + ... + coefficients[0] * xn-k. <br>
For example, if coefficients = {2,1}, initial = {9,7}, and N = 6, then our recurrence relation is xn = xn-1 + 2 * xn-2 and we have x0 = 9 and x1 = 7. Then x2 = x1 + 2 * x0 = 7 + 2 * 9 = 25, and similarly, x3 = 39, x4 = 89, x5 = 167, and x6 = 345, so your method would return (345 modulo 10) = 5.</p>

<h6 id="definition">Definition</h6>

<p>Class:    RecurrenceRelation <br>
Method:    moduloTen <br>
Parameters:    int[], int[], int <br>
Returns:    int <br>
Method signature:    int moduloTen(int[] coefficients, int[] initial, int N) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>(a + b) modulo x = ( (a modulo x) + (b modulo x) ) modulo x for any values of a, b, and x.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>coefficients will have between 1 and 10 elements, inclusive.</li>
<li>initial will have the same number of elements as coefficients.</li>
<li>Each element of coefficients will be between -1000 and 1000, inclusive.</li>
<li>Each element of initial will be between -1000 and 1000, inclusive.</li>
<li>N will be between 0 and 100000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{2,1} <br>
{9,7}
6 <br>
Returns: 5 <br>
As described in the problem statement.</p></li>
<li><p>{1,1} <br>
{0,1}
9 <br>
Returns: 4 <br>
This is the famous Fibonacci sequence, which goes 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</p></li>
<li><p>{2} <br>
{1}
20 <br>
Returns: 6 <br>
This sequence is 1, 2, 4, 8, 16, ...</p></li>
<li><p>{2} <br>
{1}
64 <br>
Returns: 6 <br>
Watch out for overflow.</p></li>
<li><p>{25,143} <br>
{0,0}
100000 <br>
Returns: 0 <br>
This sequence will always be zero.</p></li>
<li><p>{9,8,7,6,5,4,3,2,1,0} <br>
{1,2,3,4,5,6,7,8,9,10}
654 <br>
Returns: 5</p></li>
<li><p>{901,492,100} <br>
{-6,-15,-39}
0 <br>
Returns: 4 <br>
Watch out for negative numbers.</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class RecurrenceRelation {  
    private:
        int mod(int a, int b) {
            return a % b &lt; 0 ? a % b + b : a % b;
        }
    public:
        int moduloTen(vector&lt;int&gt; coefficients, vector&lt;int&gt; initial, int N) {
            vector&lt;int&gt; ans(N + 1, 0);
            for (int i = 0; i &lt;= N; ++i) {
                if (i &lt; initial.size()) {
                    ans[i] = mod(initial[i], 10);
                } else {
                    for (int j = 0, k = coefficients.size(); j &lt; coefficients.size(); ++j, --k) {
                        ans[i] = mod(ans[i] + (ans[i - k] * coefficients[j]), 10);
                    }
                }
            }
            return ans[N];
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/01/recurrencerelation/</link><guid isPermaLink="false">9054eb6f-d90c-4b5b-a168-e7a7f09bf156</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Mon, 01 Dec 2014 06:08:07 GMT</pubDate></item><item><title><![CDATA[QuickSums]]></title><description><![CDATA[<p>Used In:    SRM 197 <br>
Used As:    Division II Level Three</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Given a string of digits, find the minimum number of additions required for the string to equal some target number. Each addition is the equivalent of inserting a plus sign somewhere into the string of digits. After all plus signs are inserted, evaluate the sum as usual. For example, consider the string "12" (quotes for clarity). With zero additions, we can achieve the number 12. If we insert one plus sign into the string, we get "1+2", which evaluates to 3. So, in that case, given "12", a minimum of 1 addition is required to get the number 3. As another example, consider "303" and a target sum of 6. The best strategy is not "3+0+3", but "3+03". You can do this because leading zeros do not change the result.</p>

<p>Write a class QuickSums that contains the method minSums, which takes a String numbers and an int sum. The method should calculate and return the minimum number of additions required to create an expression from numbers that evaluates to sum. If this is impossible, return -1.</p>

<h6 id="definition">Definition</h6>

<p>Class:    QuickSums <br>
Method:    minSums <br>
Parameters:    String, int <br>
Returns:    int <br>
Method signature:    int minSums(String numbers, int sum) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>numbers will contain between 1 and 10 characters, inclusive.</li>
<li>Each character in numbers will be a digit.</li>
<li>sum will be between 0 and 100, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"99999" <br>
45 <br>
Returns: 4 <br>
In this case, the only way to achieve 45 is to add 9+9+9+9+9. This requires 4 additions.</p></li>
<li><p>"1110" <br>
3 <br>
Returns: 3 <br>
Be careful with zeros. 1+1+1+0=3 and requires 3 additions.</p></li>
<li><p>"0123456789" <br>
45 <br>
Returns: 8</p></li>
<li><p>"99999" <br>
100 <br>
Returns: -1</p></li>
<li><p>"382834" <br>
100 <br>
Returns: 2 <br>
There are 3 ways to get 100. They are 38+28+34, 3+8+2+83+4 and 3+82+8+3+4. The minimum required is 2.</p></li>
<li><p>"9230560001" <br>
71 <br>
Returns: 4</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
#include &lt;cmath&gt;

using namespace std;

class QuickSums {  
    public:
        int minSums(string numbers, int sum) {
            int n = numbers.size() - 1;
            int limit = int(pow(2, n));
            int counter = 10;
            for (int i = 0; i &lt; limit; ++i) {
                bitset&lt;9&gt; plusPos(i);
                long long ans = 0;
                long long temp = numbers[0] - '0';
                for (int j = 1; j &lt; numbers.size(); ++j) {
                    if (plusPos[j - 1]) {
                        ans += temp;
                        temp = numbers[j] - '0';
                    } else {
                        temp *= 10;
                        temp += numbers[j] - '0';
                    }
                }
                ans += temp;
                if (ans == sum &amp;&amp; plusPos.count() &lt; counter) {
                    counter = plusPos.count();
                }
            }
            return (counter == 10 ? -1 : counter);
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/01/quicksums/</link><guid isPermaLink="false">a5e43d8b-2870-4bb1-b8e8-6501937eb179</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Mon, 01 Dec 2014 04:06:14 GMT</pubDate></item><item><title><![CDATA[PaperFold]]></title><description><![CDATA[<p>Used In:    SRM 162 <br>
Used As:    Division I Level One , Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You have a piece of paper that you need to fold to fit into a box with a given width and length. Each time you fold the paper, you can fold it in half across either its width or length, but you can only fold the paper 8 times (after 8 times, the paper is too dense to fold again).</p>

<p>You will be given a int[] paper, which contains the width and length of the paper in inches, and a int[] box, which contains the width and length of the box in inches. In both cases, the first element is the width and the second element is the length. Your method should return the fewest number of folds which would allow you to fit the paper into the box. You can rotate the paper 90 degrees if it will fit with fewer folds, but the paper must lie completely flat inside the box. If the paper cannot be fit into the box with 8 folds or fewer, return -1.</p>

<h6 id="definition">Definition</h6>

<p>Class:    PaperFold <br>
Method:    numFolds <br>
Parameters:    int[], int[] <br>
Returns:    int <br>
Method signature:    int numFolds(int[] paper, int[] box) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>After the paper is folded, it is possible that it has fractional dimensions.</li>
<li>The paper will fit into the box even if one or both of the dimensions are exactly the same as the corresponding box dimensions.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>paper will contain exactly two elements.</li>
<li>box will contain exactly two elements.</li>
<li>Each element of paper and box will be between 1 and 10000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{8, 11} <br>
{6, 10}
Returns: 1 <br>
By folding the paper so that the length is reduced from 11 to 5.5 inches, it will fit inside the box if you rotate it 90 degrees.</p></li>
<li><p>{11, 17} <br>
{6, 4}
Returns: 4 <br>
There are two ways to fold the paper so that it fits within the box.</p></li>
</ol>

<p>First, you could fold the width in half to get 5.5 inches, and then fold the length in half three times to get 2.125 inches.</p>

<p>Second, you could fold the width in half twice to get 2.25 inches, and then fold the length in half twice to get 4.25 inches. In this case, you must also rotate 90 degrees to fit the paper in.</p>

<ol>
<li><p>{11, 17} <br>
{5, 4}
Returns: 4 <br>
Now, you must use the second method to get it to fit: Fold the width and length each twice, and rotate 90 degrees. If you try fitting without rotating, it would take 5 folds.</p></li>
<li><p>{1000,1000} <br>
{62,63}
Returns: -1 <br>
Folding in each direction 4 times, you can get the paper down to 62.5 x 62.5. However, this will not fit into the box because neither dimension fits in 62.</p></li>
<li><p>{100,30} <br>
{60,110}
Returns: 0</p></li>
<li><p>{1895, 6416} <br>
{401, 1000}
Returns: 5</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

class PaperFold {

    private:
        bool fits(double pl, double pw, double bl, double bw) {
            if (pl &lt;= bl &amp;&amp; pw &lt;= bw) {
                return true;
            } else if (pl &lt;= bw &amp;&amp; pw &lt;= bl) {
                return true;
            } 
            return false;
        }

    public:
        int numFolds(vector&lt;int&gt; paper, vector&lt;int&gt; box) {
            vector&lt;pair&lt;double, double&gt; &gt; pos(512);
            pos[0] = make_pair(0, 0);
            pos[1] = make_pair(paper[0]*1.0, paper[1]*1.0);
            for (int i = 1; i &lt;= 255; ++i) {
                pos[i * 2] = make_pair(pos[i].first / 2.0, 
                             pos[i].second);
                pos[i * 2 + 1] = make_pair(pos[i].first, 
                                 pos[i].second / 2.0);
            }
            int ans = -1;
            for (int i = 1; i &lt;= 511; ++i) {
                if (fits(pos[i].first, pos[i].second, 
                    box[0]*1.0, box[1]*1.0)) {
                    ans = floor(log(i)/ log(2));
                    break;
                }
            }
            return ans;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/12/01/paperfold/</link><guid isPermaLink="false">f52e3fcd-2fd8-4b9d-956c-f288879bf1f8</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 20:30:05 GMT</pubDate></item><item><title><![CDATA[WordForm]]></title><description><![CDATA[<p>Used In:    SRM 173 <br>
Used As:    Division I Level One , Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>In English, the letters A, E, I, O and U are the vowels. Y is also considered to be a vowel if it's not preceded by another vowel and is not the first letter in a word (the fact that a vowel is defined to some extent in terms of itself does not make it ambiguous). If a letter is not a vowel then it is a consonant. So in "TOY" the consonants are T and Y, and in "SYZYGY" they are S, Z and G.</p>

<p>A sequence of vowels will be denoted by uppercase letter 'V' and a sequence of consonants will be denoted by uppercase letter 'C'. A word can then be described as an alternating sequence of 'C' and 'V'. For instance, the word "WHEREABOUTS" has the sequence CVCVCVC, and the words "YORK" and "TOY" both have the sequence CVC. It's not permissible to have two or more consecutive 'V' or 'C' in the sequence.</p>

<p>Create a class WordForm containing the method getSequence which takes a String word and returns a String containing the word's sequence as described above. The word may contain both uppercase and lowercase letters, but your method should be case insensitive (see example 2).</p>

<h6 id="definition">Definition</h6>

<p>Class:    WordForm <br>
Method:    getSequence <br>
Parameters:    String <br>
Returns:    String <br>
Method signature:    String getSequence(String word) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>word may not be an English word, or a word in any language at all, but you should still use the rules defined above. See example 3.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>word will contain between 1 and 50 characters, inclusive.</li>
<li>word will only contain the characters 'A'-'Z' and 'a'-'z', both inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"WHEREABOUTS" <br>
Returns: "CVCVCVC" <br>
Here we have consonant-consonant-vowel-consonant-vowel-vowel-consonant-vowel-vowel-consonant-consonant. Putting together consecutive consonants and vowels gives us CVCVCVC.</p></li>
<li><p>"yoghurt" <br>
Returns: "CVCVC"</p></li>
<li><p>"YipPy" <br>
Returns: "CVCV" <br>
Mixing lowercase and uppercase does not affect the result.</p></li>
<li><p>"AyYyEYye" <br>
Returns: "VCVCVCV" <br>
Even though this isn't an English word, we use the rules defined in the statement to find the consonant-vowel pattern.</p></li>
<li><p>"yC" <br>
Returns: "C"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

class WordForm {  
    private:
        bool isVowel(string s, int i, bool lastCharWasVowel) {
            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {
                return true;
            } else if (s[i] == 'y' &amp;&amp; i != 0 &amp;&amp; !lastCharWasVowel) {
                return true;
            }
            return false;
        }
    public:
        string getSequence(string word) {
            transform(word.begin(), word.end(), word.begin(), ::tolower);
            string seq = "";
            bool lastCharWasVowel = false;
            for (int i = 0; i &lt; word.size(); ++i) {
                if (isVowel(word, i , lastCharWasVowel)) {
                    seq += 'V';
                    lastCharWasVowel = true;
                } else {
                    seq += 'C';
                    lastCharWasVowel = false;
                }
            }
            string finalSeq = "";
            for (int i = 0; i &lt; seq.size(); ++i) {
                if (i == 0 || seq[i] != seq[i - 1]) {
                    finalSeq += seq[i];
                }
            }
            return finalSeq;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/wordform/</link><guid isPermaLink="false">456b88d7-a6dd-4ef9-b518-1651953291c5</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 18:10:25 GMT</pubDate></item><item><title><![CDATA[TallPeople]]></title><description><![CDATA[<p>Used In:    SRM 208 <br>
Used As:    Division I Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>A group of people stand before you arranged in rows and columns. Looking from above, they form an R by C rectangle of people. You will be given a String[] people containing the height of each person. Elements of people correspond to rows in the rectangle. Each element contains a space-delimited list of integers representing the heights of the people in that row. Your job is to return 2 specific heights in a int[]. The first is computed by finding the shortest person in each row, and then finding the tallest person among them (the "tallest-of-the-shortest"). The second is computed by finding the tallest person in each column, and then finding the shortest person among them (the "shortest-of-the-tallest").</p>

<h6 id="definition">Definition</h6>

<p>Class:    TallPeople <br>
Method:    getPeople <br>
Parameters:    String[] <br>
Returns:    int[] <br>
Method signature:    int[] getPeople(String[] people) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>people will contain between 2 and 50 elements inclusive.</li>
<li>Each element of people will contain between 3 and 50 characters inclusive.</li>
<li>Each element of people will be a single space-delimited list of positive integers such that: </li>
<li>Each positive integer is between 1 and 1000 inclusive with no extra leading zeros.</li>
<li>Each element contains the same number of integers.</li>
<li>Each element contains at least 2 positive integers.</li>
<li>Each element does not contain leading or trailing whitespace.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{"9 2 3", <br>
"4 8 7"}
Returns: { 4,  7 } <br>
The heights 2 and 4 are the shortest from the rows, so 4 is the taller of the two. The heights 9, 8, and 7 are the tallest from the columns, so 7 is the shortest of the 3.</p></li>
<li><p>{"1 2", <br>
"4 5",
"3 6"}
Returns: { 4,  4 }</p></li>
<li><p>{"1 1", <br>
"1 1"}
Returns: { 1,  1 }</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;

using namespace std;

class TallPeople {  
    public:
        vector&lt;int&gt; getPeople(vector&lt;string&gt; people) {
            vector&lt;vector&lt;int&gt; &gt; grid(people.size());
            for (int i = 0; i &lt; people.size(); ++i) {
                istringstream iss(people[i]);
                int n;
                while (iss &gt;&gt; n) {
                    grid[i].push_back(n);
                }
            }
            int tos = 0;
            for (int i = 0; i &lt; grid.size(); ++i) {
                int shortInRow = grid[i][0];
                for (int j = 1; j &lt; grid[i].size(); ++j) {
                    if (grid[i][j] &lt; shortInRow) {
                        shortInRow = grid[i][j];
                    }
                }
                if (shortInRow &gt; tos) {
                    tos = shortInRow;
                }
            }
            int sot = 10000;
            for (int i = 0; i &lt; grid[0].size(); ++i) {
                int tallestInColumn = grid[0][i];
                for (int j = 1; j &lt; grid.size(); ++j) {
                    if (grid[j][i] &gt; tallestInColumn) {
                        tallestInColumn = grid[j][i];
                    }
                }
                if (tallestInColumn &lt; sot) {
                    sot = tallestInColumn;
                }
            }
            vector&lt;int&gt; ans(2);
            ans[0] = tos, ans[1] = sot;
            return ans;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/tallpeople/</link><guid isPermaLink="false">e0b8eb11-f510-4350-ac79-bf6a0f38b70c</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 17:26:21 GMT</pubDate></item><item><title><![CDATA[CCipher]]></title><description><![CDATA[<p>Used In:    SRM 147 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Julius Caesar used a system of cryptography, now known as Caesar Cipher, which shifted each letter 2 places further through the alphabet (e.g. 'A' shifts to 'C', 'R' shifts to 'T', etc.). At the end of the alphabet we wrap around, that is 'Y' shifts to 'A'.</p>

<p>We can, of course, try shifting by any number. Given an encoded text and a number of places to shift, decode it.</p>

<p>For example, "TOPCODER" shifted by 2 places will be encoded as "VQREQFGT". In other words, if given (quotes for clarity) "VQREQFGT" and 2 as input, you will return "TOPCODER". See example 0 below.</p>

<h6 id="definition">Definition</h6>

<p>Class:    CCipher <br>
Method:    decode <br>
Parameters:    String, int <br>
Returns:    String <br>
Method signature:    String decode(String cipherText, int shift) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>cipherText has between 0 to 50 characters inclusive</li>
<li>each character of cipherText is an uppercase letter 'A'-'Z'</li>
<li>shift is between 0 and 25 inclusive</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"VQREQFGT" <br>
2 <br>
Returns: "TOPCODER"</p></li>
<li><p>"ABCDEFGHIJKLMNOPQRSTUVWXYZ" <br>
10 <br>
Returns: "QRSTUVWXYZABCDEFGHIJKLMNOP"</p></li>
<li><p>"TOPCODER" <br>
0 <br>
Returns: "TOPCODER"</p></li>
<li><p>"ZWBGLZ" <br>
25 <br>
Returns: "AXCHMA"</p></li>
<li><p>"DBNPCBQ" <br>
1 <br>
Returns: "CAMOBAP"</p></li>
<li><p>"LIPPSASVPH" <br>
4 <br>
Returns: "HELLOWORLD"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class CCipher {  
    private:
        int mod(int n, int m) {
            return n % m &lt; 0 ? n % m + m : n % m;
        }
    public:
        string  decode(string cipherText, int shift) {
            string original = "";
            for (int i = 0; i &lt; cipherText.size(); ++i) {
                original += 'A' + mod(cipherText[i] - 'A' - shift, 26);
            }
            return original;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/ccipher/</link><guid isPermaLink="false">8e0f378a-be43-4ab5-b543-a8ee2bebda7a</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 15:33:19 GMT</pubDate></item><item><title><![CDATA[Quipu]]></title><description><![CDATA[<p>Used In:    SRM 155 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>The Incas used a sophisticated system of record keeping consisting of bundles of knotted cords. Such a bundle of cords is called a quipu. Each individual cord represents a single number. Surprisingly, the Incas used a base-10 positional system, just like we do today. Each digit of a number is represented by a cluster of adjacent knots, with spaces between neighboring clusters. The digit is determined by the number of knots in the cluster. For example, the number 243 would be represented by a cord with knots tied in the following pattern</p>

<pre><code> -XX-XXXX-XXX-
</code></pre>

<p>where each uppercase 'X' represents a knot and each '-' represents an unknotted segment of cord (all quotes for clarity only).</p>

<p>Unlike many ancient civilizations, the Incas were aware of the concept of zero, and used it in their quipus. A zero is represented by a cluster containing no knots. For example, the number 204003 would be represented by a cord with knots tied in the following pattern</p>

<pre><code> -XX--XXXX---XXX-
    ^^    ^^^
    ^^    ^^^
    ^^    two zeros between these three segments
    ^^
    one zero between these two segments
</code></pre>

<p>Notice how adjacent dashes signal the presence of a zero. <br>
Your task is to translate a single quipu cord into an integer. The cord will be given as a String knots containing only the characters 'X' and '-'. There will be a single '-' between each cluster of 'X's, as well as a leading '-' and a trailing '-'. The first cluster will not be empty.</p>

<h6 id="definition">Definition</h6>

<p>Class:    Quipu <br>
Method:    readKnots <br>
Parameters:    String <br>
Returns:    int <br>
Method signature:    int readKnots(String knots) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>knots contains between 3 and 50 characters, inclusive.</li>
<li>knots contains only the characters 'X' and '-'. Note that 'X' is uppercase.</li>
<li>The first and last characters of knots are '-'s. The second character is 'X'.</li>
<li>knots does not contain 10 consecutive 'X's.</li>
<li>knots will represent a number between 1 and 1000000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"-XX-XXXX-XXX-" <br>
Returns: 243 <br>
The first example above.</p></li>
<li><p>"-XX--XXXX---XXX-" <br>
Returns: 204003 <br>
The second example above.</p></li>
<li><p>"-X-" <br>
Returns: 1</p></li>
<li><p>"-X-------" <br>
Returns: 1000000</p></li>
<li><p>"-XXXXXXXXX--XXXXXXXXX-XXXXXXXXX-XXXXXXX-XXXXXXXXX-" <br>
Returns: 909979</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Quipu {  
    public:
        int readKnots(string knots) {
            int countX = 0,
                num = 0;
            for (int i = 0; i &lt; knots.size(); ++i) {
                if (knots[i] == 'X') {
                    ++countX;
                } else {
                    num *= 10;
                    num += countX;
                    countX = 0;
                }
            }
            return num;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/quipu/</link><guid isPermaLink="false">d7e628c2-a900-435b-93fb-56a47ef9a54b</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 15:08:32 GMT</pubDate></item><item><title><![CDATA[PassingGrade]]></title><description><![CDATA[<p>Used In:    SRM 185 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You are studying for the final exam in a tough course, and want to know how many points you need to score on the final to pass the course. You know how many points you earned on each assignment (pointsEarned), how many points were possible on each assignment (pointsPossible), and how many points are possible on the final exam (finalExam). You need to earn a minimum of 65% of the total possible points to pass the course. Assume your score on the final exam will be an integral number of points between 0 and finalExam, inclusive. Return the number of points you need to score on the final to pass the course, or -1 if it is impossible for you to pass the course.</p>

<h6 id="definition">Definition</h6>

<p>Class:    PassingGrade <br>
Method:    pointsNeeded <br>
Parameters:    int[], int[], int <br>
Returns:    int <br>
Method signature:    int pointsNeeded(int[] pointsEarned, int[] pointsPossible, int finalExam) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>pointsEarned contains between 1 and 20 elements, inclusive.</li>
<li>pointsPossible contains the same number of elements as pointsEarned.</li>
<li>Each element of pointsPossible is between 1 and 1000, inclusive.</li>
<li>Element i of pointsEarned is between 0 and element i of pointsPossible, inclusive.</li>
<li>finalExam is between 1 and 3000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{55,77,82,60} <br>
{100,100,100,100}
300 <br>
Returns: 181 <br>
If you score 181 points on the final, then you will finish the course with exactly 65% of the possible points.</p></li>
<li><p>{ 1, 2, 3, 4 } <br>
{ 2, 3, 4, 5 }
7 <br>
Returns: 4 <br>
If you score 4 points on the final, then you pass with 66.7% of the total possible points, but if you score 3 points on the final, then you fail with 61.9% of the possible points.</p></li>
<li><p>{ 1, 2, 2, 1 } <br>
{ 9, 9, 9, 9 }
9 <br>
Returns: -1 <br>
Even if you score 9 points on the final, you still fail with 33.3% of the possible points.</p></li>
<li><p>{ 7, 8, 7, 6 } <br>
{ 8, 8, 8, 8 }
9 <br>
Returns: 0 <br>
You will pass even if you score 0 points on the final.</p></li>
<li><p>{ 17, 23, 50, 200, 19, 56, 83, 91, 77, 9, 0 } <br>
{ 20, 30, 50, 250, 20, 70, 100, 100, 100, 10, 10 }
400 <br>
Returns: 129</p></li>
<li><p>{600,600,600,600,600,600,600,600,600,600, <br>
600,600,600,600,600,600,600,600,600,600}
{1000,1000,1000,1000,1000,1000,1000,1000,
1000,1000,1000,1000,1000,1000,1000,1000,
1000,1000,1000,901}
3000 <br>
Returns: 2886</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

using namespace std;

class PassingGrade {  
    public:
        int pointsNeeded (vector&lt;int&gt; pointsEarned, vector&lt;int&gt; pointsPossible, int finalExam) {
            int totalEarned = accumulate(pointsEarned.begin(), 
                              pointsEarned.end(), 0);
            int totalPossible = accumulate(pointsPossible.begin(), 
                                pointsPossible.end(), finalExam);
            int required = ceil(totalPossible * 0.65);
            if (required - totalEarned &gt; finalExam) {
                return -1;
            } 
            return max(0, required - totalEarned);
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/passinggrade/</link><guid isPermaLink="false">ccc63d54-9c8e-4f89-9b6b-6ffc0c500bf9</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 14:35:38 GMT</pubDate></item><item><title><![CDATA[NoOrderOfOperations]]></title><description><![CDATA[<p>Used In:    SRM 200 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>When evaluating a mathematical expression, there is the possibility of ambiguity. If you wanted to know the result of "3 + 5 * 7", you might first evaluate the (3+5) and get 56, or first evaluate the (5*7) and get 38. This ambiguity can be resolved by using the order of operations: first do multiplication and division (from left to right), and then after all those are done, do addition and subtraction (again from left to right). Here, the correct result would be the 38.</p>

<p>While this is unambiguous, it certainly is somewhat annoying. You think it would be easier if people did all math from left to right, all the time, and want to make a simple expression evaluator to do so.</p>

<p>The expression will be given to you as a String expr. It will consist of one digit numbers (0 through 9) alternating with operators (+, -, or *), with no spaces between them. Thus, expr would follow the format Digit Operator Digit Operator .... Digit. For example, the expression given above would be given as "3+5*7".</p>

<p>Your method should return an int representing the value of the expression when evaluated from left to right.</p>

<h6 id="definition">Definition</h6>

<p>Class:    NoOrderOfOperations <br>
Method:    evaluate <br>
Parameters:    String <br>
Returns:    int <br>
Method signature:    int evaluate(String expr) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>expr will be between 1 and 17 characters in length, inclusive.</li>
<li>expr will contain an odd number of characters.</li>
<li>expr will follow the format Digit Operator Digit Operator ... Digit, where each Digit is a single character from '0' to '9', and each Operator is either +, -, or *.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>"3+5*7" <br>
Returns: 56 <br>
First we add 3 + 5 to get 8. Then, we multiply 8 by 7 to get 56.</p></li>
<li><p>"4-8*9*1" <br>
Returns: -36 <br>
Results can be negative.</p></li>
<li><p>"0" <br>
Returns: 0</p></li>
<li><p>"1*2*3*4*5*6*7*8*9" <br>
Returns: 362880</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class NoOrderOfOperations {  
    public:
        int evaluate(string expr) {
            char op = '+';
            int ans = 0;
            for (int i = 0; i &lt; expr.size(); ++i) {
                if (expr[i] &gt;= '0' &amp;&amp; expr[i] &lt;= '9') {
                    if (op == '+') {
                        ans += (expr[i] - '0');
                    } else if (op == '-') {
                        ans -= (expr[i] - '0');
                    } else if (op == '*') {
                        ans *= (expr[i] - '0');
                    } else if (op == '/') {
                        ans /= (expr[i] - '0');
                    }
                } else {
                    op = expr[i];
                }
            }
            return ans;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/noorderofoperations/</link><guid isPermaLink="false">f24d48f1-a658-4d19-b7ee-0754106d783e</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 11:38:04 GMT</pubDate></item><item><title><![CDATA[Yahtzee]]></title><description><![CDATA[<p>Used In:    SRM 146 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>This task is about the scoring in the first phase of the die-game Yahtzee, where five dice are used. The score is determined by the values on the upward die faces after a roll. The player gets to choose a value, and all dice that show the chosen value are considered active. The score is simply the sum of values on active dice.</p>

<p>Say, for instance, that a player ends up with the die faces showing 2, 2, 3, 5 and 4. Choosing the value two makes the dice showing 2 active and yields a score of 2 + 2 = 4, while choosing 5 makes the one die showing 5 active, yielding a score of 5.</p>

<p>Your method will take as input an int[] toss, where each element represents the upward face of a die, and return the maximum possible score with these values.</p>

<h6 id="definition">Definition</h6>

<p>Class:    YahtzeeScore <br>
Method:    maxPoints <br>
Parameters:    int[] <br>
Returns:    int <br>
Method signature:    int maxPoints(int[] toss) <br>
(be sure your method is public)</p>

<h6 id="constraints">Constraints</h6>

<ul>
<li>toss will contain exactly 5 elements.</li>
<li>Each element of toss will be between 1 and 6, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{ 2, 2, 3, 5, 4 } <br>
Returns: 5 <br>
The example from the text.</p></li>
<li><p>{ 6, 4, 1, 1, 3 } <br>
Returns: 6 <br>
Selecting 1 as active yields 1 + 1 = 2, selecting 3 yields 3, selecting 4 yields 4 and selecting 6 yields 6, which is the maximum number of points.</p></li>
<li><p>{ 5, 3, 5, 3, 3 } <br>
Returns: 10</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

class YahtzeeScore {  
    public:
        int maxPoints(vector&lt;int&gt; toss) {
            vector&lt;int&gt; sum(7, 0);
            for (int i = 0; i &lt; 5; ++i) {
                sum[toss[i]] += toss[i];
            }
            return *max_element(sum.begin(), sum.end());
        }   
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/yahtzee/</link><guid isPermaLink="false">8d1b1abb-1fbf-4698-a399-c75134b67896</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 11:15:17 GMT</pubDate></item><item><title><![CDATA[Poetry]]></title><description><![CDATA[<p>Used In:    SRM 170 <br>
Used As:    Division II Level Three</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>Given a poem, determine its rhyme scheme.</p>

<p>To simplify things, because English is such a fickle language, there are some constraints:</p>

<p>A legal word is a sequence of lower or uppercase letters, containing at least one vowel, where a vowel is 'a', 'e', 'i', 'o', or 'u'. Also, 'y' is considered a vowel if it is not at the start or end of a word. Words are delimited by spaces.</p>

<p>Two words are considered rhyming if they have the same ending pattern (defined below). This comparison is case-insensitive (see Example 1.)</p>

<p>An ending pattern is a substring of a word such that:</p>

<p>The word ends with that substring, <br>
The substring contains exactly one contiguous string of vowels, <br>
The first letter of the substring is a vowel, and <br>
The substring must either be the whole string, or the letter immediately preceding the start of the substring must be a nonvowel. <br>
For example, the ending pattern of "bought" is "ought", the ending pattern of "spying" would be "ying", and the ending pattern of "all" would be "all". (Note that "spy" has no vowels, and thus is not a legal word.)</p>

<p>Two lines rhyme if their corresponding last words rhyme, and a line is empty if it contains no words.</p>

<p>The procedure for determinining rhyme scheme is as follows: The first non-empty line in the poem should be labeled with the lowercase letter 'a'. Every line that rhymes with that line should also be labeled with that letter. The next unlabeled non-empty line should be labeled with the letter 'b', and any rhyming lines should also be labeled in this manner. When you run out of lowercase letters, continue by using the uppercase letters 'A' to 'Z'. Empty lines should be labeled with ' ' (the space character).</p>

<p>The 0th character of the returned String should be the rhyme scheme label of the 0th line, the 1st character should be the label of the 1st line, and so on. This means that the returned String will have the same number of characters as there are elements in poem. Thus, given a String[] poem, then your method should return a String detailing the rhyme scheme.</p>

<h6 id="definition">Definition</h6>

<p>Class:    Poetry <br>
Method:    rhymeScheme <br>
Parameters:    String[] <br>
Returns:    String <br>
Method signature:    String rhymeScheme(String[] poem) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>If there is a blank line in the poem, there must be a corresponding space in the output. A blank line is one with no words. (See Example 1.)</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>poem will have between 1 and 50 elements, inclusive.</li>
<li>each element of poem will contain between 0 and 50 characters, inclusive.</li>
<li>the only allowable characters in poem will be upper and lowercase characters ('a'-'z' and 'A'-'Z') and the space character (' ').</li>
<li>there will be only legal words in poem</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{"I hope this problem", <br>
"is a whole lot better than",
"this stupid haiku"}
Returns: "abc" <br>
Doesn't even conceivably rhyme.</p></li>
<li><p>{"     ", <br>
"Measure your height",
"AND WEIGHT      ",
"said the doctor",
"",
"And make sure to take your pills",
"   to   cure   your    ills",
"Every",
"DAY"}
Returns: " aab ccde" <br>
Even though "height" and "weight" don't actually rhyme in English, they do by the rules laid out above.</p></li>
<li><p>{"One bright day in the middle of the night", <br>
"Two dead boys got up to fight",
"Back to back they faced each other",
"Drew their swords and shot each other",
"",
"A deaf policeman heard the noise",
"And came to arrest the two dead boys",
"And if you dont believe this lie is true",
"Ask the blind man he saw it too"}
Returns: "aabb cdef"</p></li>
<li><p>{"", <br>
"",
"",
""}
Returns: "    " <br>
Four lines from the mind of a blank poet.</p></li>
<li><p>{"This poem has uppercase letters", <br>
"In its rhyme scheme",
"Alpha", "Blaster", "Cat", "Desert", "Elephant", "Frog", "Gulch", 
"Horse", "Ireland", "Jam", "Krispy Kreme", "Loofah", "Moo", "Narf",
"Old", "Pink", "Quash", "Rainbow", "Star", "Tour", "Uvula", "Very",
"Will", "Xmas", "Young", "Zed", "deception", "comic", "grout",
"oval", "cable", "rob", "steal", "steel", "weak"}
Returns: "abcdefghibjkblmnopqrstcuvwxyzABCbDEFG"</p></li>
<li><p>{" ", <br>
"     ",
"This poem",
"         ",
" ",
" ",
"",
"Has lots of blank lines",
" ",
"      ",
"                                            ",
"         ",
" ",
"              ",
"                                                  ",
"  in      it           "}
Returns: "  a    b       c"</p></li>
<li><p>{"too bad   your", <br>
"     solution went   sour"}
Returns: "aa"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

using namespace std;

class Poetry {  
    private:
        bool isVowel(string s, int i) {
            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {
                return true;
            } else if (s[i] == 'y' &amp;&amp; i != 0 &amp;&amp; i != s.size() - 1) {
                return true;
            }
            return false;
        }
        string endPattern(string s) {
            string ep = "";
            bool flag = true;
            for (int i = s.size() - 1; i &gt;= 0; --i) {
                bool v = isVowel(s, i); 
                if (v) {
                    flag = false;
                }
                if (v || flag) {
                    ep = s[i] + ep;
                } else {
                    break;
                }
            }
            return ep;
        }
        bool isEmptyString(string s) {
            for (int i = 0; i &lt; s.size(); ++i) {
                if (s[i] != ' ') {
                    return false;
                }
            }
            return true;
        }
        string lastWord(string s) {
            istringstream iss(s);
            string lw;
            while (iss &gt;&gt; lw);
            return lw;
        }
    public:
        string rhymeScheme(vector&lt;string&gt; poem) {
            vector&lt;char&gt; rhymingSeq;
            for (char i = 'a'; i &lt;= 'z'; ++i) {
                rhymingSeq.push_back(i);
            }
            for (char i = 'A'; i &lt;= 'Z'; ++i) {
                rhymingSeq.push_back(i);
            }
            map&lt;string, char&gt; pattern;
            string scheme = "";
            int seq = 0;
            for (int i = 0; i &lt; poem.size(); ++i) {
                transform(poem[i].begin(), poem[i].end(), poem[i].begin(), ::tolower);
                if (!isEmptyString(poem[i])) {
                    string ep = endPattern(lastWord(poem[i]));
                    if (pattern.find(ep) == pattern.end()) {
                        pattern[ep] = rhymingSeq[seq++];
                    }
                    scheme += pattern[ep];
                } else {
                    scheme += " ";
                }
            }
            return scheme;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/poetry/</link><guid isPermaLink="false">7b987ce1-2551-4210-9070-76a824bb2ab6</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 10:25:31 GMT</pubDate></item><item><title><![CDATA[MatchMaking]]></title><description><![CDATA[<p>Used In:    SRM 203 <br>
Used As:    Division I Level One , Division II Level Two</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You are developing the matchmaking component of an online dating site. Prospective members must fill out a questionnaire consisting of binary questions such as Do you prefer to vacation (a) in the mountains or (b) at the seaside? and Would you rather travel (a) by plane or (b) by train?</p>

<p>You are to match up men with women by maximizing the number of answers each couple has in common. A man and a woman have an answer in common whenever they give the same answer to the same question. Conflicts can easily arise due to numerical ties, but you will be able to resolve all such conflicts using the following procedure. Note that there will be equal numbers of men and women, with names being unique in each sex.</p>

<p>Take the woman whose name comes earliest in lexicographic order, and consider the men with whom she has the greatest number of answers in common. Among these men, pick the one whose name comes earliest in lexicographic order. You have found the woman's best match. Remove this couple from the dating pool, and repeat the matching procedure until there are no more singles left.</p>

<p>You are given a String[], namesWomen, containing the names of single women, and another String[], answersWomen, containing their answers. The kth element of answersWomen lists the answers of the woman whose name is the kth element of namesWomen. If there are n questions in the questionnaire, then every element of answersWomen consists of n characters, each of which is either 'a' or 'b'. The answers are always given in the fixed questionnaire order. You are similarly given the String[]s namesMen and answersMen for the single men. Lastly, you are given a String, queryWoman, containing the name of a woman. Return the name of the man to whom she is matched after you have formed all couples according to the above rules.</p>

<h6 id="definition">Definition</h6>

<p>Class:    MatchMaking <br>
Method:    makeMatch <br>
Parameters:    String[], String[], String[], String[], String <br>
Returns:    String <br>
Method signature:    String makeMatch(String[] namesWomen, String[] answersWomen, String[] namesMen, String[] answersMen, String queryWoman) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>Lexicographic order is like dictionary order, with the difference that case matters. All uppercase letters take precedence over all lowercase letters. Thus, "boolean" comes before "boot"; "boo" comes before "boolean"; "Boot" comes before "boo"; "Zoo" comes before "boo".</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>namesWomen contains between 1 and 50 elements, inclusive</li>
<li>if namesWomen consists of n elements, then answersWomen, namesMen, and answersMen consist of n elements each</li>
<li>each element of namesWomen and each element of namesMen is between 1 and 50 characters long, inclusive</li>
<li>the only characters that may appear in namesMen and namesWomen are 'a' to 'z' and 'A' to 'Z'</li>
<li>no two elements of namesWomen are alike</li>
<li>no two elements of namesMen are alike</li>
<li>the first element of answersWomen is between 1 and 50 characters long, inclusive</li>
<li>if the first element of answersWomen consists of m characters, then each element of answersWomen and of answersMen is m characters long</li>
<li>the only characters that may appear in answersWomen and answersMen are 'a' and 'b'</li>
<li>queryWoman is one of the Strings in namesWomen</li>
</ul>

<p>Examples</p>

<ol>
<li><p>{"Constance", "Bertha", "Alice"} <br>
{"aaba", "baab", "aaaa"}
{"Chip", "Biff", "Abe"}
{"bbaa", "baaa", "aaab"}
"Bertha"
Returns: "Biff" <br>
Alice has two answers in common with Chip and three answers in common with both Abe and Biff; Abe gets lexicographic preference. Bertha also has two answers in common with Chip and three answers in common with both Abe and Biff. Since Abe has already been matched to Alice, Bertha lands Biff.</p></li>
<li><p>{"Constance", "Bertha", "Alice"} <br>
{"aaba", "baab", "aaaa"}
{"Chip", "Biff", "Abe"}
{"bbaa", "baaa", "aaab"}
"Constance"
Returns: "Chip" <br>
We are dealing with the same names and answers as before. Constance is the last to go. Although she has two answers in common with Abe and Biff, they are both taken. She ends up with Chip, with whom she has only one answer in common.</p></li>
<li><p>{"Constance", "Alice", "Bertha", "Delilah", "Emily"} <br>
{"baabaa", "ababab", "aaabbb", "bababa", "baabba"}
{"Ed", "Duff", "Chip", "Abe", "Biff"}
{"aabaab", "babbab", "bbbaaa", "abbbba", "abaaba"}
"Constance"
Returns: "Duff"</p></li>
<li><p>{"Constance", "Alice", "Bertha", "Delilah", "Emily"} <br>
{"baabaa", "ababab", "aaabbb", "bababa", "baabba"}
{"Ed", "Duff", "Chip", "Abe", "Biff"}
{"aabaab", "babbab", "bbbaaa", "abbbba", "abaaba"}
"Delilah"
Returns: "Chip"</p></li>
<li><p>{"Constance", "Alice", "Bertha", "Delilah", "Emily"} <br>
{"baabaa", "ababab", "aaabbb", "bababa", "baabba"}
{"Ed", "Duff", "Chip", "Abe", "Biff"}
{"aabaab", "babbab", "bbbaaa", "abbbba", "abaaba"}
"Emily"
Returns: "Ed"</p></li>
<li><p>{"anne", "Zoe"} <br>
{"a", "a"}
{"bob", "chuck"}
{"a", "a"}
"Zoe"
Returns: "bob"</p></li>
<li><p>{"F", "M", "S", "h", "q", "g", "r", "N", "U", "x", "H", "P", <br>
"o", "E", "R", "z", "L", "m", "e", "u", "K", "A", "w", "Q",
"O", "v", "j", "a", "t", "p", "C", "G", "k", "c", "V", "B",
"D", "s", "n", "i", "f", "T", "I", "l", "d", "J", "y", "b"}
{"abaabbbb", "bbaabbbb", "aaabaaab", "aabbaaaa", "baabbaab",
"aaababba", "bbabbbbb", "bbbabbba", "aaabbbba", "aabbbaaa",
"abbabaaa", "babbabbb", "aaaaabba", "aaaabbaa", "abbbabaa",
"babababa", "abbaaaaa", "bbababba", "baaaaaba", "baaaaabb",
"bbbbabba", "ababbaaa", "abbbabab", "baabbbaa", "bbbaabbb",
"aababbab", "ababbabb", "abbaabba", "baabbabb", "aaabaaab",
"aabbbaba", "aabaaabb", "abababba", "aabbaaaa", "aabbabaa",
"bababaaa", "aabaaaab", "bbbbaabb", "baaababb", "abaabbab",
"aabbbaaa", "baabbaba", "bbabbbaa", "aabbbbaa", "abbbaaab",
"abababbb", "ababaaba", "bababaaa"}
{"f", "C", "v", "g", "Q", "z", "n", "c", "B", "o", "M", "F",
"u", "x", "I", "T", "K", "L", "E", "U", "w", "A", "d", "t",
"e", "R", "D", "s", "p", "q", "m", "r", "H", "j", "J", "V",
"l", "a", "k", "h", "G", "y", "i", "P", "O", "N", "b", "S"}
{"bbbaabab", "bbabaabb", "ababbbbb", "bbbababb", "baababaa",
"bbaaabab", "abbabbaa", "bbbabbbb", "aabbabab", "abbababa",
"aababbbb", "bababaab", "aaababbb", "baabbaba", "abaaaaab",
"bbaababa", "babaabab", "abbabbba", "ababbbab", "baabbbab",
"babbaaab", "abbbbaba", "bbabbbba", "baaabaab", "ababbabb",
"abbbaabb", "bbbbaabb", "bbbaaabb", "baabbaba", "bbabaaab",
"aabbbaab", "abbbbabb", "bbaaaaba", "bbbababa", "abbaabba",
"bababbbb", "aabaaabb", "babbabab", "baaaabaa", "ababbaba",
"aaabaabb", "bbaaabaa", "baaaaabb", "bbaabaab", "bbababab",
"aabaaaab", "aaaaabab", "aabbaaba"}
"U"
Returns: "x"</p></li>
<li><p>{"q", "M", "w", "y", "p", "N", "s", "r", "a", "H", "o", "n", <br>
"F", "m", "l", "b", "D", "j", "C", "u", "f", "I", "g", "L",
"i", "x", "A", "G", "O", "k", "h", "d", "c", "E", "B", "v",
"J", "z", "K", "e", "t"}
{"aabbaaabb", "baabababb", "bbaababba", "bbbaaaaaa", "abaaaabaa",
"bababbbab", "abbaabbaa", "aabababbb", "bababaaaa", "abbababaa",
"aabbbbbba", "bbabbabab", "babaabbba", "babbabbbb", "baaabbbbb",
"baaabaaaa", "aaabbaaab", "abbaabbbb", "abbabbbab", "bbaaaabba",
"babbaaabb", "aabbabbab", "baaababba", "ababaabab", "bbbaabbab",
"aaaabbabb", "babaaaaaa", "abbbbaaab", "aabaaabba", "bbbaaaaba",
"bbbbbbaab", "aabbaaabb", "aabaabbab", "aababaaba", "bbabbbbab",
"abbabaaab", "babaaabbb", "bababbaaa", "aabbaabaa", "baaabbabb",
"bbbbbbbbb"}
{"m", "k", "n", "q", "L", "E", "M", "l", "w", "x", "g", "e",
"i", "z", "F", "r", "a", "h", "f", "D", "J", "K", "j", "v",
"A", "t", "N", "y", "s", "c", "o", "p", "d", "b", "B", "G",
"O", "I", "u", "C", "H"}
{"bbaaabbba", "bbaaaaaab", "abaaababb", "baaaabbbb", "abbbababa",
"baaaaaaaa", "aabbbbbab", "aaaaabbba", "baabababb", "babaaabab",
"baaababaa", "bbbbaabba", "bbaabbabb", "bbaaababb", "abbabbaba",
"aababaaab", "abbbbbbaa", "aabbaabaa", "bbbaabbba", "abbabbaba",
"aaabbbaaa", "bbaabaaaa", "aabababbb", "abbbbabab", "baaabbbba",
"bababbbba", "aababbaab", "bbaabbaab", "bbbaaabbb", "babbbbabb",
"ababababb", "babaaabab", "bbaaaaaba", "aaaaabaaa", "abbaaabbb",
"bbbbababb", "baabababb", "bbaabaaaa", "aaababbbb", "abbbbbbba",
"bbaabbaaa"}
"o"
Returns: "C"</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;map&gt;

using namespace std;

class MatchMaking {  
    private:
        int mathches(string a, string b) {
            int match = 0;
            for (int i = 0; i &lt; a.size(); ++i) {
                if (a[i] == b[i]) {
                    ++match;
                }
            }
            return match;
        }

    public:
        string makeMatch(vector&lt;string&gt; namesWomen, vector&lt;string&gt; answerWomen, vector&lt;string&gt; namesMen, vector&lt;string&gt; answerMen, string queryWoman) {
            int n = namesMen.size();
            string theChosenOne = "";
            map&lt;string, string&gt; women, men;
            vector&lt;bool&gt; taken(n, false);
            for (int i = 0; i &lt; n; ++i) {
                women[namesWomen[i]] = answerWomen[i];
                men[namesMen[i]] = answerMen[i];
            }
            for (map&lt;string, string&gt; :: iterator i = women.begin(); 
                i != women.end(); ++i) {
                int compatibility = -1;
                int index = 0,
                    jn = 0;
                for (map&lt;string, string&gt; :: iterator j = 
                    men.begin(); j != men.end(); ++j, ++jn) {
                    if (!taken[jn]) {
                        int match = mathches(i-&gt;second, j-&gt;second);
                        if (match &gt; compatibility) {
                            compatibility = match;
                            index = jn;
                            theChosenOne = j-&gt;first;
                        }
                    }
                }
                taken[index] = true;
                if (i-&gt;first == queryWoman) {
                    break;
                }
            }
            return theChosenOne;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/matchmaking/</link><guid isPermaLink="false">42d8c9c0-ad89-4714-8b3f-6c6396e3864a</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 07:37:33 GMT</pubDate></item><item><title><![CDATA[BettingMoney]]></title><description><![CDATA[<p>Used In:    SRM 191 <br>
Used As:    Division II Level One</p>

<h6 id="problemstatement">Problem Statement</h6>

<p>You run a gambling business in which people place bets on the margin of victory in a football game. At the end of the day, the company would like to know what the day's net gain has been.</p>

<p>Just as in any other betting system, people place certain amounts as their bets and if they guess correctly, they get their money back plus a pre-specified percentage of their bet; otherwise they lose the money they bet. </p>

<p>You are given a int[], amounts, the ith element of which is the number of dollars people have placed on a victory margin of i (i = 0 refers to the first element). You are also given a int[], centsPerDollar, the ith element of which is the number of cents the company has to pay for every dollar the people bet on a victory margin of i, if the final outcome is a victory margin of i. Finally, you are given an int, finalResult, which is the final margin of victory. You have to determine what the net gain for the day was and return the amount in cents.</p>

<p>For example, if amounts were {10,20,30}, it would mean that people placed $10 on a draw outcome, $20 on a victory margin of 1 and $30 on a victory margin of 2, and if centsPerDollar were {20,30,40}, it would mean the people would win 20 cents per dollar bet if the match were a draw, 30 cents per dollar if the victory margin were 1 and 40 cents per dollar if the victory margin were 2. </p>

<p>Suppose the final result is a victory margin of 1 (i.e., finalResult = 1). Then the people who guessed the outcome as a margin of 0 or 2 were wrong and the company receives the amounts they bet, $10+$30. However, the people who guessed that the outcome would be a margin of 1 were correct, and they receive money from the company according to the amount they bet (20 dollars) and the pre-set payoff percentage (30 cents per dollar) . This amounts to 20*30 = 600 cents. Hence, the day's net gain is 40 dollars - 600 cents = 3400 cents. You should return 3400.</p>

<h6 id="definition">Definition</h6>

<p>Class:    BettingMoney <br>
Method:    moneyMade <br>
Parameters:    int[], int[], int <br>
Returns:    int <br>
Method signature:    int moneyMade(int[] amounts, int[] centsPerDollar, int finalResult) <br>
(be sure your method is public)</p>

<h6 id="notes">Notes</h6>

<ul>
<li>Keep in mind that it is not relevant which team wins. Only the margin of victory matters.</li>
<li>A victory margin of 0 and a draw are the same thing.</li>
<li>There are 100 cents in a dollar.</li>
<li>If the company has to pay more than it receives, the day's net gain will be negative.</li>
</ul>

<h6 id="constraints">Constraints</h6>

<ul>
<li>amounts will contain between 1 and 50 elements, inclusive.</li>
<li>centsPerDollar will contain the same number of elements as amounts.</li>
<li>finalResult will be between 0 and n-1, inclusive, where n is the number of elements in amounts.</li>
<li>Each element of amounts will be between 0 and 5000, inclusive.</li>
<li>Each element of centsPerDollar will be between 0 and 5000, inclusive.</li>
</ul>

<h6 id="examples">Examples</h6>

<ol>
<li><p>{10,20,30} <br>
{20,30,40}
1 <br>
Returns: 3400 <br>
The case explained in the problem statement above.</p></li>
<li><p>{200,300,100} <br>
{10,10,10}
2 <br>
Returns: 49000 <br>
The company gains 200+300 = 500 dollars from the people who bet on margins of 0 and 1. The company loses 100*10 = 1000 cents to the people who bet on a victory margin of 2. Hence, the net gain is 49000 cents.</p></li>
<li><p>{100,100,100,100} <br>
{5,5,5,5}
0 <br>
Returns: 29500</p></li>
<li><p>{5000,5000} <br>
{100,2}
0 <br>
Returns: 0</p></li>
<li><p>{100} <br>
{10}
0 <br>
Returns: -1000 <br>
The company doesn't gain anything! It has to pay the people who bet on the only outcome possible. It pays 100*10 cents. Hence, the net gain is -1000. (Negative indicates loss.)</p></li>
</ol>

<hr>

<pre><code class="prettyprint">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class BettingMoney {  
    public:
        int moneyMade(vector&lt;int&gt; amounts, vector&lt;int&gt; centsPerDollar, int finalResult) {
            int profit = 0;
            for (int i = 0; i &lt; amounts.size(); ++i) {
                if (i == finalResult) {
                    profit -= (amounts[i] * centsPerDollar[i]);
                } else {
                    profit += (amounts[i] * 100);
                }
            }
            return profit;
        }
};
</code></pre>]]></description><link>http://code-jedi.chintanghate.me/2014/11/30/bettingname/</link><guid isPermaLink="false">99b30a41-e004-409d-a143-0e90ec6c8f90</guid><category><![CDATA[TopCoder]]></category><dc:creator><![CDATA[Chintan Ghate]]></dc:creator><pubDate>Sun, 30 Nov 2014 05:18:42 GMT</pubDate></item></channel></rss>